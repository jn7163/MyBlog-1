<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wincer&#39;s Blog</title>
  
  <subtitle>言念君子，温其如玉。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.itswincer.com/"/>
  <updated>2018-07-16T11:48:15.000Z</updated>
  <id>https://blog.itswincer.com/</id>
  
  <author>
    <name>WincerChan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hitokoto（一言）API 2.0 正式上线</title>
    <link href="https://blog.itswincer.com/posts/a5c39267/"/>
    <id>https://blog.itswincer.com/posts/a5c39267/</id>
    <published>2018-07-16T11:48:15.000Z</published>
    <updated>2018-07-16T11:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年夏天的时候，用 Flask 开发了一个<a href="../f6e1eb2a/">简易版的一言</a>，算是最初的 beta 版，部署在了 Heroku 上面（那时我还没购买服务器），由于 Heroku 免费版是时间池的限制，在我购置了服务器后就重新用 Go 重写了一下<a href="../b3085a7/#搭建-API">部署在自己的服务器上</a>，算是 1.0 版，这两天又重新拾坑，开发出了 2.0 版本。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 1.0 版本使用了较长的时间后，基于以下考量，我还是重构了部分代码：</p><ol><li>收录一言数太少：我没事的时候就喜欢刷新玩，经常发现眼熟的，毕竟也就不到一千条；</li><li>性能：由于使用的是 SQLite，在每秒请求数在 1000 的时候就 GG 了；</li><li>查询参数：返回不超过查询长度参数的一言，但翻了一大堆 API，都并没有提供这个功能；</li></ol><p>于是乎，本着「生命不死，折腾不止」的态度，2.0 版本诞生了。</p><blockquote><p>本 API 的<a href="https://github.com/WincerChan/Hitokoto" target="_blank" rel="noopener">源码</a>已开源至 GitHub，如有需要的可自行搭建。</p></blockquote><p>以下是 2.0 版本的更新日志：</p><h2 id="数量问题"><a href="#数量问题" class="headerlink" title="数量问题"></a>数量问题</h2><p>爬取数据时采用了异步爬虫，解决了 1.0 版本爬取时效率低下的问题，同时选取了 xxhash 作为散列函数，将一言主体 hash 后，得到的 64bit 的无符号整数作为主键，这样如果爬取到了重复的一言也不会插入数据库中。</p><p>得益于异步爬虫的高效率，在很短的时间内，爬取到了足够的一言数。目前，数据库内共有 <code>15371</code> 条一言。以后数量还会不断地增加。<a href="https://github.com/WincerChan/Hitokoto-Spider" target="_blank" rel="noopener">爬虫程序</a>已托管至 GitHub。</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>数据库更换成了 MySQL，以承受高并发访问，以下为建表语句：</p><pre><code class="mysql">+----------+---------------------+------+-----+---------+-------+| Field    | Type                | Null | Key | Default | Extra |+----------+---------------------+------+-----+---------+-------+| id       | bigint(20) unsigned | NO   | PRI | NULL    |       || hitokoto | varchar(300)        | NO   |     | NULL    |       || source   | varchar(64)         | NO   |     | NULL    |       || origin   | varchar(12)         | NO   |     | NULL    |       |+----------+---------------------+------+-----+---------+-------+</code></pre><h2 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h2><p>2.0 版本共包含以下请求参数：</p><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>格式为 <code>encode=</code>，包含以下四个参数值：</p><ul><li>js：JavaScript 脚本，将一言插入 HTML 中第一次出现 <code>class = &#39;hitokoto&#39;</code> 的标签中</li><li>json：JSON 格式的字符串，包含主体（hitokoto），出处（source）</li><li>text：一言句子的主体</li><li>默认为：<code>×××××——「×××」</code>，即主体 + 出处</li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>格式为 <code>charset=</code>，包含以下两个参数值：</p><ul><li>utf-8：在 Header 中的 <code>content-type</code> 字段添加 <code>charset=utf-8</code></li><li>gbk：同上</li></ul><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>格式为 <code>length=</code>，会随机返回一条不超过这个查询长度的语句。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>格式为 <code>callback=</code>，会根据回调参数的值返回对应的函数调用，其中函数的参数为一个字典，key 分别为 <code>hitokoto</code> 和 <code>source</code>。</p><blockquote><p><strong>注意：callback 参数会覆盖掉 encode 参数</strong></p></blockquote><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>调用地址：<code>https://api.itswincer.com/hitokoto/v2/</code></p><p>例如，我想请求一个长度不超过 10 的一言，并以 JSON 格式返回：</p><pre><code class="bash">curl &#39;https://api.itswincer.com/hitokoto/v2/?encode=json&amp;length=10&#39;{&quot;hitokoto&quot;:&quot;(눈_눈)&quot;,&quot;source&quot;:&quot;进击的巨人&quot;}</code></pre><p>如果想在自己的网页使用的话，可以采取以下两种方法：</p><h3 id="JS-方法"><a href="#JS-方法" class="headerlink" title="JS 方法"></a>JS 方法</h3><p>只需要在想要展示的标签加上 <code>class=&#39;hitokoto&#39;</code> 属性，随后在任何地方加上：</p><pre><code class="html">&lt;script src=&quot;https://api.itswincer.com/hitokoto/v2/?encode=js&quot;&gt;&lt;/script&gt;</code></pre><p>插入页面的显示结果是：××××××× ——「×××」形式。</p><p>展示结果见：<a href="https://www.itswincer.com/" target="_blank" rel="noopener">我的主页</a>。</p><h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><p>如果对 <code>encode=js</code> 返回的格式不满意，可自行定义页面展示的格式：比如以下代码仅展示一言的主体部分：</p><p>定义标签和函数：</p><pre><code class="html">&lt;p class=&quot;hitokoto&quot;&gt;&lt;/p&gt;&lt;script&gt;    // 定义回调函数名 showHitokoto    function showHitokoto(data){        // 比如我只想展示一言主体部分        var hitokoto = data.hitokoto;        // 插入 class=hitokoto 的标签        var dom = document.querySelector(&#39;.hitokoto&#39;);        Array.isArray(dom)?dom[0].innerText=hitokoto:dom.innerText=hitokoto;    }&lt;/script&gt;</code></pre><p>随后将请求地址加上参数 <code>callback=showHitokoto</code>：</p><pre><code class="html">&lt;script src=&quot;https://api.itswincer.com/hitokoto/v2/?callback=showHitokoto&quot;&gt;&lt;/script&gt;</code></pre><p>以上示例将会在 HTML 标签首个包含 <code>class=&#39;hitokoto&#39;</code> 的标签内部插入仅包含一言主体的部分。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>你看到某句熟悉的一言从屏幕上显示的时候，勾起了之前第一次看到这句话时或感动、或开心、或难过的回忆，而某个陌生人也会因此和你一样陷入属于他的短暂回忆——想到这些不是很快乐吗？而我想那个陌生人一定也正想着同样的事情。我一直这样觉得。</p><p>而这，应当就是文字赋予一言的最大作用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年夏天的时候，用 Flask 开发了一个&lt;a href=&quot;../f6e1eb2a/&quot;&gt;简易版的一言&lt;/a&gt;，算是最初的 beta 版，部署在了 Heroku 上面（那时我还没购买服务器），由于 Heroku 免费版是时间池的限制，在我购置了服务器后就重新用 Go 重写了一下&lt;a href=&quot;../b3085a7/#搭建-API&quot;&gt;部署在自己的服务器上&lt;/a&gt;，算是 1.0 版，这两天又重新拾坑，开发出了 2.0 版本。&lt;/p&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="一言" scheme="https://blog.itswincer.com/tags/%E4%B8%80%E8%A8%80/"/>
    
      <category term="API" scheme="https://blog.itswincer.com/tags/API/"/>
    
      <category term="Hitokoto" scheme="https://blog.itswincer.com/tags/Hitokoto/"/>
    
  </entry>
  
  <entry>
    <title>博客访问统计报告（2017.6.20-2018.7.4）</title>
    <link href="https://blog.itswincer.com/posts/790223d2/"/>
    <id>https://blog.itswincer.com/posts/790223d2/</id>
    <published>2018-07-05T10:52:34.000Z</published>
    <updated>2018-07-08T10:51:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客<a href="../4a17b156/">建站至今</a>也一年有余了，本想着在一周年（今年 5 月初）之际写一篇文章纪念一下，顺便公布一下本博客在这一年的访问情况，可当时发现统计记录还没有满一年（我是在 2017 年 6 月底才开始使用的 Google 分析），于是就想干脆等到 6 月底再写。而前段时间又忙于准备期末考试，直到昨天放假回家，似乎才有时间写这一篇文章。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先我并不确定 Google 分析的准确性有多高，因为当我查看 Cloudflare 自带的分析功能是，得到的数据与 Google 分析的有很大很大的差别。以近一周的数据做对比：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1531016567/blog/blog_reporter/ga_vs_cf.png" alt="左 Google，右 Cloudflare" title="左 Google，右 Cloudflare"></p><p>虽说 Cloudflare 统计了所有的 HTTP 请求，但<strong>我博客实则只有 html 页面才会走 Cloudflare 的线路</strong>，其它的静态资源我都放在 CDN 了。而 Cloudflare 对于近一周访问 html 页面给出的数据是占总请求数的 48%——约 3411 次，这应该是与 Google 的页面浏览量（540）作为对比（加上其余两个子网站的浏览量分别为 121、4），可以看到仍然有将近 7 倍的差距，用户数也有近 5 倍差距——我确实想不出一个合理的解释（根据 Cloudflare 给出的解释，可能是由于某些网络爬虫，故与基于 Javascript 的统计工具来说有较大出入）。</p><p>但 Cloudflare 无法给出像 Google 分析那样包括平均会话、每次会话浏览数、跳出率等等指标，故本篇博客还是选取 Google 分析的数据进行分析。</p><h2 id="受众群体"><a href="#受众群体" class="headerlink" title="受众群体"></a>受众群体</h2><p>在过去的一年零两周内，本博客的基本访问情况如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530761892/blog/blog_reporter/overview.png" alt="概览"></p><p>这期间，本博客一共迎来了 5,446 位用户，他们一共产生了 10,508 次会话以及 19,989 次浏览。平均每天 14 位用户、28 次会话、53 次浏览。</p><p>图表中有一个较为凸出的高峰（5 月 29 日），原因是我在 V2EX 发了帖介绍自己写的一个<a href="https://www.v2ex.com/t/458433#reply23" target="_blank" rel="noopener">表情包生成工具</a>，这个工具中算是间接性的把用户引导至本博客了。</p><h2 id="流量获取"><a href="#流量获取" class="headerlink" title="流量获取"></a>流量获取</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530763252/blog/blog_reporter/traffic_overview.png" alt="流量"></p><p>其中流量获取的来源主要是三部分：Referral（引荐）、Organic Search（搜索引擎）、Direct（直连）。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530766976/blog/blog_reporter/traffic_cmp.png" alt="对比"></p><p>其中 Google 的流量占了大多数：36.80%，其次是本博客自身的引荐；本博客并没有添加百度站长的信息，并且主动屏蔽了百度蜘蛛的爬取，故并没有来自百度的流量。</p><p>现在的 Google 分析为了保护用户隐私，已经无法显示用户查询的关键词了。</p><h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530766078/blog/blog_reporter/location.png" alt="地理"></p><p>毫无疑问，本博客的主要流量都来自于中国大陆，不过令我感到奇怪的是第二名是美国。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530766008/blog/blog_reporter/language.png" alt="语言"></p><p>在操作系统语言中：</p><p>简体中文（zh-CN + zh-cn）占了 72.27%，较地理为中国大陆的 68.93% 多出了 3.34 个百分点；</p><p>英语（en-US + en-us）占了 16.91%，较地理为美国的 11.06% 也多出了 5.85 个百分点；</p><p>也就是说，并非只有美国地区的人才会使用英文，也并非中国地区的人才会使用中文。</p><h2 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530768660/blog/blog_reporter/browser.png" alt="浏览器"></p><p>首先看看浏览器的占用，由于本博客的类型更偏技术一些，故 Chrome、Safari、Firefox 的使用占据前三甲，其中 IE 的份额不足 0.4%，这意味着我并不需要照顾 IE 的用户，可以尽情使用各种新技术。</p><p>第四的 Android Webview 应该是指 App（QQ、微信） 内置的浏览器。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530765885/blog/blog_reporter/system.png" alt="操作系统"></p><p>操作系统毫无疑问是以 Windows 独占鳌头，其次是 Linux，我一直使用 Manjaro Linux 作为日常开发，比 Windows 方便许多，也没有 Windows 那么多 Bug，由于娱乐方式的缺乏，在 Linux 下开发也会更加专注。</p><h2 id="浏览页面"><a href="#浏览页面" class="headerlink" title="浏览页面"></a>浏览页面</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530767677/blog/blog_reporter/page.png" alt="页面浏览"></p><p>在本站可访问页面中（仅统计文章页面），浏览量的前六名分别是：</p><ol><li><a href="../ad42f575/">Linux 与 Windows 10 用 GRUB 引导教程</a></li><li><a href="../cfd78fa9/">解除百度云下载限速</a></li><li><a href="../2aa541e6/">Spacemacs 生存指北</a></li><li><a href="../bf0413ac/">Nextcloud 搭建私人云服务教程</a></li><li><a href="../72171293/">QQ 音乐外链解析</a></li><li><a href="../8575e868/">Sorry，会写代码真的能为所欲为</a></li></ol><p>（唉，最满意的几篇文章浏览量反倒是挺低的，心情复杂.jpg。）</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>自本博客运营至今共发布了 53 篇文章，其中自 17 年 9 月以来，发文的频率明显降低：首 4 个月发了 33 篇文章，17 年 9 月至今却只发了 20 篇。一方面是刚建站的时候事比较多；另一方面是相较于博客数量来说，更开始注重博客质量了。</p><p>当我选择运营独立博客开始，并没有想从中得到什么实质性的好处。在快餐时代似乎坚持写独立文章的人越来越少了，这也无可厚非，毕竟短期内看不到结果的话，有些人就无法坚持了。周围的人似乎对此（我写博客这件事）表示不太理解，当然别人的看法并不重要，重要的是，自己想坚持做下去，而只要能长期的投入一件事中，最终一定能从中获取乐趣和满足感。</p><p>我就是如此。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的博客&lt;a href=&quot;../4a17b156/&quot;&gt;建站至今&lt;/a&gt;也一年有余了，本想着在一周年（今年 5 月初）之际写一篇文章纪念一下，顺便公布一下本博客在这一年的访问情况，可当时发现统计记录还没有满一年（我是在 2017 年 6 月底才开始使用的 Google 分析），于是就想干脆等到 6 月底再写。而前段时间又忙于准备期末考试，直到昨天放假回家，似乎才有时间写这一篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="博客栈" scheme="https://blog.itswincer.com/categories/%E5%8D%9A%E5%AE%A2%E6%A0%88/"/>
    
    
      <category term="博客" scheme="https://blog.itswincer.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Google Analytics" scheme="https://blog.itswincer.com/tags/Google-Analytics/"/>
    
      <category term="访问统计" scheme="https://blog.itswincer.com/tags/%E8%AE%BF%E9%97%AE%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用持续集成（CI）开发项目</title>
    <link href="https://blog.itswincer.com/posts/f011ea9c/"/>
    <id>https://blog.itswincer.com/posts/f011ea9c/</id>
    <published>2018-06-09T10:22:34.000Z</published>
    <updated>2018-06-15T12:34:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客在建站后不久就使用了 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 自动部署服务，即我只需要将修改的源码推送至 GitHub，Travis CI 会自动将我提交的代码拉取，在 Travis CI 端生成静态文件后，同步至我的服务器，这样可以减少一些麻烦的步骤：可以直接在 GitHub 端修改代码；不用等待生成静态文件、压缩静态文件的时间。<a id="more"></a></p><h2 id="Circle-CI"><a href="#Circle-CI" class="headerlink" title="Circle CI"></a>Circle CI</h2><p>虽然使用 Travis CI 是能简化部分开发流程，但这货和 GitHub 是一对一的，只支持在 GitHub 托管的项目，并不支持 Bitbucket 和 GitLab，而 GitHub 免费版在私人仓库这一方面是比不上 Bitbucket 和 GitLab 的（虽然我是学生，可以使用 GitHub 私人仓库，可我也不一直是学生呀），同时支持 Bitbucket 的和 GitHub 私人仓库的 CI 工具（自建的除外）好像真的也就 <a href="https://circleci.com/" target="_blank" rel="noopener">CircleCI</a> 了，这里之所以没有考虑 GitLab 是因为 GitLab 自带有 CI/CD，而且这家公司给我的印象实在不太好（包括之前的删库事件，以及莫名奇妙的 Bug）。</p><p>在了解 CircleCI 后发现比 Travis CI 真是强不少（CircleCI 是基于 Docker 和 Workflows 设定模式的），不过在网上并没有很完善的中文教程<del>（虽然官方英文文档已经很完善了）</del>。所以如果你懒得翻官方文档的话，继续往下看我这篇文章就好了🤓。</p><h2 id="选择仓库"><a href="#选择仓库" class="headerlink" title="选择仓库"></a>选择仓库</h2><p>CircleCI 支持 GitHub 和 Bitbucket 帐号的登录，授权登录完成后，就可以添加 Projects 了，支持 GitHub 和 Bitbucket 的公有及私有仓库。这里以我的 <a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 仓库为例。</p><p>选完仓库后，就可以开始配置 CircleCI 了。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="添加-SSH-密钥"><a href="#添加-SSH-密钥" class="headerlink" title="添加 SSH 密钥"></a>添加 SSH 密钥</h3><p><a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 仓库用到 SSH 密钥的地方有两处：</p><ol><li>从 GitHub 克隆仓库</li><li>将编译后的静态文件推送至我的服务器</li></ol><p>如果你是用来推送至 GitHub 的话，可以直接用 GitHub 提供为该仓库提供的 Token 密钥，第一点也可以使用 HTTPS 方式克隆，就可以省去添加 SSH 密钥这个步骤。</p><p>点击 CircleCI 个人主页的 JOBS 菜单项，随后点击仓库名称右边的齿轮按钮 -&gt; 点击 <code>SSH Permissions</code> -&gt; 点击蓝色的 <code>Add SSH Key</code> 按钮，将<strong>私钥</strong>（看清楚了，是私钥）粘贴进去（超级良心有木有啊，比 Travis CI 将私钥加密上传这种土办法不知道高到哪里去了）。</p><h3 id="添加-IP-至-known-hosts"><a href="#添加-IP-至-known-hosts" class="headerlink" title="添加 IP 至 known_hosts"></a>添加 IP 至 known_hosts</h3><p>添加 SSH 密钥后，还需要将服务器的 IP 添加至 known_hosts 列表，否则每次部署的时候都会让你确认以下消息：</p><pre><code class="bash">The authenticity of host &#39;××.×××.×××.×××&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:7hkfahfla8VeiuyF/TLHKfhakgcJ0sHjaLxDyIKlfhak9fuaofoa.Are you sure you want to continue connecting (yes/no)?</code></pre><p>同 Travis CI 类似，CircleCI 在运行的过程中也是不接受命令行输入的（当然运行完成后就更不行了），所以我们需要提前将 IP 写入 known_hosts（在 CircleCI 中如何做？继续往后看）：</p><pre><code class="bash">ssh-keyscan $SSH_IP &gt;&gt; ~/.ssh/known_hosts</code></pre><p>在该仓库的管理页面中的 <code>Environment Variables</code> 选项卡中添加 SSH_IP 的环境变量。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>由于我的配置文件太过长了，先以一个简化版为例：</p><pre><code class="yaml">version: 2jobs:  build:    docker:      - image: circleci/node:10.4.0    steps:      - checkout      - run:          name: Install Dependence          command: |            yarn install &amp;&amp; yarn build      - run:            name: Deploy            command: |              echo &quot;Denpendence installed.&quot;</code></pre><p>首先指明 CircleCI 的版本号——2.0（1.0 在 18 年 9 月之后就停止支持了）。</p><p>其次，为 Docker 指定 image（<a href="https://circleci.com/docs/2.0/circleci-images/" target="_blank" rel="noopener">这是</a>官方已经构建完成的镜像列表），可以指定多个 image。先前提到过，CircleCI 并不默认像 Travis CI 那样提供 Linux 虚拟机镜像，推荐使用的是 Docker（当然你也可以指定工作方式为 Machine），这是官方针对 Docker 和 Machine 的<a href="https://circleci.com/docs/2.0/executor-types/#overview" target="_blank" rel="noopener">对比报告</a>。</p><p>随后在 <code>steps</code> 里面是需要运行的指令：</p><ol><li><code>checkout</code> 是一个用于检查配置路径的源代码的特殊步骤，并可以通过 SSH 来 clone 远程仓库的代码（如果你已经添加了 SSH 私钥的话，不然就只好手动 clone 了），详解见<a href="https://circleci.com/docs/2.0/configuration-reference/#checkout" target="_blank" rel="noopener">官方文档</a></li><li><code>run:</code> 后面接的是 bash 命令，<code>name</code> 该任务的名称，<code>command</code> 为具体 bash 的指令</li></ol><h3 id="安装额外命令"><a href="#安装额外命令" class="headerlink" title="安装额外命令"></a>安装额外命令</h3><p>需要注意的是，如果你需要将生成的静态文件同步至服务器所用的 <code>rsync</code> 命令是没有被安装的，只有<a href="https://circleci.com/docs/2.0/circleci-images/#pre-installed-tools" target="_blank" rel="noopener">这些命令</a>是被安装在所有镜像中的。</p><p>docker 镜像预装的系统是 Ubuntu，可采取 <code>apt-get</code> 命令来安装需要的软件包：</p><pre><code class="yaml">run:   name: Update System  command: |    sudo apt-get update &amp;&amp; sudo apt-get install rsync</code></pre><h3 id="设置缓存"><a href="#设置缓存" class="headerlink" title="设置缓存"></a>设置缓存</h3><p>CircleCI 建议的 Workflows 中建议将整个工作流分割成不同的子作业，比如说以 Yarn 项目为例，可以分成 <code>build</code> 和 <code>deploy</code> 两个流程。其中 <code>build</code> 用以安装依赖和生成待部署的静态文件；<code>deploy</code> 用以将生成的静态文件部署至服务器。</p><p>可以看出，静态文件是横跨两个作业的，所以我们需要将包含静态文件的文件夹缓存下来（当然你也可以选择不使用 Workflows，这样就只需创建一个工作就好了），在 <code>build</code> 工作中缓存采取如下命令：</p><pre><code class="yaml">steps:  - restore_cache:    keys:      - build-v1-{{ checksum "package.json" }}    paths:      - &quot;build&quot;</code></pre><p>以上命令是将 <code>build</code> 文件夹以 <code>key-value</code> 形式缓存，其中 <code>key</code> 选择的是 <code>package.json</code> 的哈希值。这里的文件名最好选择仓库自带的文件。更多 <code>key</code> 的形式可以参考<a href="https://circleci.com/docs/2.0/caching/#using-keys-and-templates" target="_blank" rel="noopener">这里</a>。</p><p>在 <code>deploy</code> 工作中恢复缓存采取以下命令：</p><pre><code class="yaml">steps:  - checkout  - restore_cache:    keys:      - meme-v1-{{ checksum "package.json" }}</code></pre><p>注意在 <code>restore_cache</code> 之前一定要有 <code>checkout</code> 命令。</p><h3 id="完整的示例"><a href="#完整的示例" class="headerlink" title="完整的示例"></a>完整的示例</h3><p>直接贴 <a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 项目的配置代码了：</p><button class="load_gist" gist="04b5e1ee8a1fbc8bc2e078d2c354bd7b"></button><p>每次构建完成后，commits 列表的画风就变成这样了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858045/blog/ci_project/circleci_construction.png" alt="CircleCI 构建"></p><p>点击 Details 就会显示每次构建的详细过程。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>虽然本文名为「使用持续集成（CI）开发项目」，但实际却好像只介绍了 CircleCI，当然我的意思不是钦定 CircleCI 作为最好的持续集成系统，我没有说 CircleCI 是最好的持续集成系统，没有任何这个意思。但你一定要问我为什么选 CircleCI，它现在对 Bitbucket 和 GitHub 的私人仓库支持最完善，我怎么能不支持它呢？</p><p>参考：</p><ul><li><a href="https://circleci.com/docs/2.0/" target="_blank" rel="noopener">2.0 Docs</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的博客在建站后不久就使用了 &lt;a href=&quot;https://travis-ci.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Travis CI&lt;/a&gt; 自动部署服务，即我只需要将修改的源码推送至 GitHub，Travis CI 会自动将我提交的代码拉取，在 Travis CI 端生成静态文件后，同步至我的服务器，这样可以减少一些麻烦的步骤：可以直接在 GitHub 端修改代码；不用等待生成静态文件、压缩静态文件的时间。
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="CI" scheme="https://blog.itswincer.com/tags/CI/"/>
    
      <category term="持续集成" scheme="https://blog.itswincer.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Sorry，会写代码真的能为所欲为</title>
    <link href="https://blog.itswincer.com/posts/8575e868/"/>
    <id>https://blog.itswincer.com/posts/8575e868/</id>
    <published>2018-05-27T10:34:21.000Z</published>
    <updated>2018-05-27T10:35:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间「这个仇我先记下了」的表情包突然火了，导致我也萌生了自己写一个表情包生成工具的想法，毕竟我是重度表情包玩家😌。其实之前我就很喜欢做表情包，不过是用的 PS 等软件，有些麻烦，而且改 GIF 也不太方便。</p><p>于是乎，我决定也蹭一波热度，也写了一个，最初是只有「记仇」这个静态表情包的，现在加上了王境泽、为所欲为、打工是不可能打工的等等动图，模板后续还会添加，如果有好的素材可以私我。<a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>当然网上也有一些表情包生成器，比如「<a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">sorry</a>」，但界面我不太喜欢，而且我觉得这类较为简单的处理没必要借助服务器端渲染合成，直接在浏览器端渲染就好了，<del>毕竟 JavaScript 算是一门「万能的语言」</del>。</p><p>核心思路是采用 omggif 对 GIF 进行解码，再用 Canvas 将文字绘制在每一帧上，最后再用 gif.js 将每一帧合成，再渲染后输出成 Blob 文件对象（<a href="https://caniuse.com/#search=blob" target="_blank" rel="noopener">现在不支持 Blob 的浏览器应该没有了吧？</a>），传递给 IMG 标签进行显示。</p><p>这是解码过程：</p><pre><code class="javascript">// 解码let gifReader = new omggif.GifReader(buffer);    // 获取帧let frameZero = girReader.frameInfo(0)            // 获取帧的宽高，绘制 Canvas 的时候会用到let [width, height] = [frameZero.width, frameZero.height]    let imageBuffer = new Uint8ClampedArray(width * height * 4)gifReader.decodeAndBlitFrameRGBA(frameNum, imageBuffer);// 生成图像数据，供 Canvas 使用let imageData = new window.ImageData(imageBuffer, width, height)</code></pre><p>这是绘制过程：</p><pre><code class="javascript">ctx.putImageData(imageData, 0, 0)// 这是字幕的白边ctx.strokeText(caption, width / 2, height - 5, width);// 这是字幕的主体ctx.fillText(caption, width / 2, height - 5, width)</code></pre><p>这是编码（渲染）过程：</p><pre><code class="javascript">let gif = new GIF({    workers: 3,    quality: 10,    width: imageWidth,    height: imageHeight,})// Canvas 的数据加入帧gif.addFrame(ctx, {    copy: true,    delay: frameInfo.delay,    dispose: -1})// 开始渲染gif.render()// 渲染完成gif.on(&#39;finished&#39;, Blob =&gt; {    gifUrl = window.URL.createObjectURL(Blob);    img.src = gifUrl;})</code></pre><p>以上是动图的设计思路，静态图就显得简单多了，采用 dom-to-img 绘制就行了，但是在 Edge 上似乎是无法使用的，作者提到似乎是因为添加了 foreignObject 标签，导致 toDataUrl() 在 Edge 上无法工作，所以 Edge 用户只能使用动图部分了。</p><p>其实核心思路很简单， gif.js 和 omggif 提供的 API 也不复杂，但我还是花了将近一周的时间，因为这是我首次使用 React 开发应用，所以有大半时间都花在了学习 React 上，然而写出来的结果还是偏「Pure JavaScript」一些。</p><p><a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">本项目</a>采用 <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> 构建，CSS 框架采用了 <a href="https://github.com/jgthms/bulma" target="_blank" rel="noopener">bulma</a>，部分动图模板来自 <a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">sorry</a>。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>刚刚有提到，我在设计该工具的时候大部分时间都没有花在核心思路部分，而是花在了——我称为「薛定谔的 Bug」上，即：你在设计该工具的蓝图的时候，没有设想到会出现这些 Bug，而实际编程中，也不一定会遇到，只有你亲自编写了，才知道这 Bug 是否会出现。</p><p>我在这次编程中就遇到了四个「薛定谔的 Bug」：</p><h3 id="Blob-文件对象"><a href="#Blob-文件对象" class="headerlink" title="Blob 文件对象"></a>Blob 文件对象</h3><p>关于静态图部分，我设计了两个按钮：「戳我预览」和「戳我下载」，其实本应该只需要一个下载按钮就够了，因为我使用 contenteditable 属性以编辑 p 标签。和生成的预览图几乎没什么差别，那么为什么要设计两个呢？就是因为 Blob 对象（后续思考了一下，虽然可以先行判断浏览器是否支持 Blob 下载，但针对动态图还是需要预览修正的，故为了设计上的统一性，还是将预览按钮保留了）。</p><p>其实大部分人应该是没有听说过这个名词的（包括我），但它还真的不是一个新玩意，甚至都不是 HTML5 新增的 API，相比于 HTML5 在 2014 年才完成标准制定，在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">MDN</a> 上查到 Blob 对象在 2010 年就被主流浏览器支持了（Chrome 5、Firefox 4、Opera 11.1），但，如今大部分手机浏览器却仍不支持 Blob 文件下载协议。</p><p>所以只好提供一个预览按钮来供不支持 Blob 文件下载协议的浏览器长按进行保存。</p><h3 id="服务器问题"><a href="#服务器问题" class="headerlink" title="服务器问题"></a>服务器问题</h3><p>由于我的服务器是在国外，而且还套了一层 Cloudflare，故而在某些情况下，加载动图会非常慢，尤其是在晚上（大约花费 1min，而且居然还没断，我真是很佩服 Cloudflare 的稳定性）。</p><p>当然图片的加载问题还不算大，可以放在<a href="https://sm.ms" target="_blank" rel="noopener">支持跨域的图床</a>上，由 <code>fetch</code> 调用，问题最大的是 Web Worker（合成 GIF 的时候需要使用），但这个 Web Worker 的地址在 Chrome 下<strong>只允许</strong>同域名下的脚本，即使是公共 CDN 上允许跨域都不行。</p><p>这里采用还是借助 Blob 对象，巧妙的规避这一限制：</p><pre><code class="javascript">let tmpWorker = await fetch(url),    workerSrcBlob = new Blob([await tmpWorker.text()], { type: &#39;text/javascript&#39; }),    workerBlobURL = window.URL.createObjectURL(workerSrcBlob);</code></pre><h3 id="React-Router-404-错误"><a href="#React-Router-404-错误" class="headerlink" title="React Router 404 错误"></a>React Router 404 错误</h3><p>在将代码生成「production build」时，遇到了一个 Bug，有时访问二级路由会出现 404，多次复现后，终于确定了：</p><p>在访问二级路由时，如果是正常从一级页面点击跳转的，则会正常访问；</p><p>但如果是直接访问二级路由或者是在二级路由刷新页面，则会出现 404；</p><p>但是这个 Bug 在「development build」中是没有的，原因在于当你点击路由时，并不是直接向服务器发起请求，而是由 react-router 路由库给出路由网址，故而刷新二级路由页面或者直接访问二级路由页面服务器是无法正确响应的。</p><p>以下是解决办法，在 Nginx 中添加 <code>try_files</code> 语句：</p><pre><code class="nginx">server {    location / {        try_files $uri /index.html    }}</code></pre><h3 id="GIF-渲染"><a href="#GIF-渲染" class="headerlink" title="GIF 渲染"></a>GIF 渲染</h3><p>当我解决了以上问题的时候，我发给室友首先试用，看到了「戳我预览」这个按钮，他就以「单身十八年」的手速猛戳了四五下，随后标志着渲染进度条就「鬼畜」了起来。因为他猛戳的那几下相当于在后台启动了好几个渲染程序，不仅会让进度条「鬼畜」起来，如果你以更快的手速戳的话（单身八十年？）还会让 CPU 负担加重，甚至会卡死，当然我是没有试过。其实这 Bug 算是无伤大雅的，本不太需要修复，<del>因为不像其它生成器拿服务器做后端，可能会造成服务器宕机，我的纯前端写的</del>。但我本着人道主义情怀、不让我的 Bug 陪我过夜的心理，以及最重要的强迫症，还是决定修复这个 Bug。</p><p>其实很简单，设置一个全局变量 <code>finished</code>，在渲染的过程中，该变量为 <code>false</code>，渲染完毕后设置成 <code>true</code>，再将渲染过程放置在 <code>if(finished)</code> 内就解决了。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>见<a href="https://github.com/WincerChan/Meme-generator/wiki" target="_blank" rel="noopener">本项目的 Wiki</a>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本工具还有很多需要改进的地方，比如 React 的写法不够规范、没有完全实现静态动态资源分离、用户自定义添加模板等等，这些我在空闲时间里都会一点点的改进。</p><p>目前在实用的角度来说，该工具已经可以投入使用了，剩下的细节就需要慢慢雕琢了。:)</p><p>参考：</p><ul><li><a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">xtyxtyx/sorry</a></li><li><a href="https://blog.csdn.net/xfgryujk/article/details/79889942" target="_blank" rel="noopener">纯 JS 实现在前端制作 GIF 表情包的网站</a></li><li><a href="https://react-guide.github.io/react-router-cn/docs/guides/basics/Histories.html" target="_blank" rel="noopener">Histories</a></li></ul>]]></content>
    
    <summary type="html">
    
      前一段时间「这个仇我先记下了」的表情包突然火了，我也萌生了自己写一个表情包生成工具的想法，而网上目前有的生成器大都是后端版，我就决定用 JavaScript 写一个。
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="表情包" scheme="https://blog.itswincer.com/tags/%E8%A1%A8%E6%83%85%E5%8C%85/"/>
    
      <category term="JavaScript" scheme="https://blog.itswincer.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Python 字典的原理及高级用法</title>
    <link href="https://blog.itswincer.com/posts/4f2b4bfb/"/>
    <id>https://blog.itswincer.com/posts/4f2b4bfb/</id>
    <published>2018-05-12T09:23:02.000Z</published>
    <updated>2018-05-12T12:36:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>算算时间有段时间没写技术类的文章了，部分原因是最近过得确实比较忙。当然，也并没有忙到完全抽不出时间写博客，根本原因还是没有找到啥好的写作素材，随随便便糊弄一篇我又有点不好意思发上来，于是乎，就一直搁置到现在。<a id="more"></a></p><p>对于字典这一基础的数据结构来说，其对 Python 的程序重要性是无可替代的，在《代码之美》一书中，作者是这么描述的：</p><blockquote><p>字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到它。——A.M.Kuchling</p></blockquote><p>在 Python 程序里，无论是模块、函数、还是对象，均有自己的「命名空间」，而这命名空间即为一个字典（dict），key 就是变量名，value 就是变量值，除去「命名空间外」，对象的函数（方法）关键字也是存放在字典中，此时的 key 就是函数（方法）名，value 就是该函数（方法）的引用。可以采用 __builtins__.__dict__ 来查看这些函数（方法）。</p><h2 id="字典的原理"><a href="#字典的原理" class="headerlink" title="字典的原理"></a>字典的原理</h2><p>Python 的字典是依据<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">散列表</a>（也叫哈希表）来实现的，首先简单介绍一下散列表的原理。</p><p>散列表中的每一个单元称为表元。在 dict 的实现里，每个 key-value 均占用一个表元，其中 key 为<strong>键的引用</strong>（这里是键的引用，而不是键本身，因为 key 可以为任意可散列对象），value 为值的引用。因为是引用：表元大小均一致，所以可通过偏移量来读取某个表元。</p><p>在 Python 中，散列函数由 hash() 方法出任，当我们查询 my_dict[search_key] 时，Python 会调用 hash(search_key) 来计算 search_key 的散列值，并将这个值的低几位数字当作偏移量，在散列表中查找表元，具体是几位，需要根据散列表的大小来决定。若表元为空，则说明 search_key 不存在，抛出 KeyError 异常。若非空，则表元会有一对 found_key:found_value，这时若 search_key == found_key 为真，那么就返回 found_value。</p><p>如果 search_key 和 found_key 不相等，这种情况成为散列冲突，发生这种情况是因为散列表只把该元素映射到了只有几位数字上。为了解决散列冲突，算法会在散列值中另外取几位，用新得到的数字做偏移量再次寻找。</p><h2 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h2><p>创建一个字典有许多方式：</p><pre><code class="python">a = dict(one=1, two=2, three=3)b = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}c = dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3]))d = dict([(&#39;two&#39;, 2), (&#39;one&#39;, 1), (&#39;three&#39;, 3)])e = dict({&#39;three&#39;: 3, &#39;one&#39;: 1, &#39;two&#39;: 2})&gt;&gt;&gt; a == b == c == d == eTrue</code></pre><p>在刚刚的原理中说到，由于字典的索引是根据 hash() 函数来获得的，所以 dict 其实是无序的，这也解释了为什么上面代码中的等式会成立。</p><h2 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h2><p>没错，在 Python3+ 里，推导式不再是列表的特性了。</p><pre><code class="python">numbers = range(5)numbers_square = {number: number ** 2 for number in numbers}</code></pre><h2 id="键查询"><a href="#键查询" class="headerlink" title="键查询"></a>键查询</h2><p>最简单的方法是采用下标方式来查询。即：my_dict[key]，这也是推荐的方法，但这是 key 存在的情况，而现实中，一定会遇到 key 不存在的时候，这时就会 raise 一个 KeyError。以下有几种解决办法：</p><h3 id="用-get-来获取"><a href="#用-get-来获取" class="headerlink" title="用 get 来获取"></a>用 get 来获取</h3><pre><code class="python">my_id = {&#39;name&#39;: &#39;wincer&#39;}&gt;&gt;&gt; my_id.get(&#39;name&#39;)&#39;wincer&#39;&gt;&gt;&gt; my_id.get(&#39;age&#39;, &#39;default&#39;)&#39;default&#39;</code></pre><p>若 key 存在，则返回对应的 value，若 key 不存在，且传入第二个参数，那么返回该参数，若无第二个参数，则返回 None。</p><h3 id="用-defaultdict-预先设置缺省（推荐）"><a href="#用-defaultdict-预先设置缺省（推荐）" class="headerlink" title="用 defaultdict 预先设置缺省（推荐）"></a>用 defaultdict 预先设置缺省（推荐）</h3><pre><code class="python">from collections import defaultdictmy_id = defaultdict(list)my_id.update({&#39;name&#39;: &#39;wincer&#39;})&gt;&gt;&gt; mydict[&#39;name&#39;]&#39;wincer&#39;&gt;&gt;&gt; mydict[&#39;age&#39;][]</code></pre><p>defaultdict 需要指定一个 factory，当查询 key 不存在时，会创建一个空的 factory 返回。推荐使用这种方式来处理 key 不存在的情况，因为该方法不仅可用于读取 value 值，还可随时用 append 来更新 value。同时需注意：<strong>defaultdict 中的参数只会在 __getitem__ 中被调用。如 dd 是一个 defaultdict，k 是一个不存在的键，dd[k] 用 factory 来创造一个默认值，但 dd.get(k) 却仍会返回 None。</strong></p><h3 id="使用-missing-方法"><a href="#使用-missing-方法" class="headerlink" title="使用 __missing__ 方法"></a>使用 __missing__ 方法</h3><p>当我们调用 my_dict[key] 时，<strong>如果 key 是一个字符串</strong>，我们会需要用 my_dict[‘name’] 来获取，如果你觉得比较麻烦，想直接用 my_dict[name] 的话，可以采用如下方法：</p><pre><code class="python">from collections import UserDictclass StrKeyDict(UserDict):    def __missing__(self, key):        if isinstance(key, str):            raise KeyError(key)        return self[str(key)]    def __contains__(self, key):        return str(key) in self.data    def __setitem__(self, key, item):        self.data[str(key)] = itemd = StrKetDict([(&#39;name&#39;, &#39;wincer&#39;), (&#39;age&#39;, &#39;20&#39;)])&gt;&gt;&gt; d[2]&#39;two&#39;</code></pre><h3 id="使用-getattr-方法（不推荐）"><a href="#使用-getattr-方法（不推荐）" class="headerlink" title="使用 __getattr__ 方法（不推荐）"></a>使用 __getattr__ 方法（不推荐）</h3><p>有时我们可能更懒，想要用类属性类似的 my_dict.name 方法来获取 value，这时，可以使用 __getattr__ 方法：</p><pre><code class="python">from collections import UserDictclass AttrDict(UserDict):    def __getattr__(self, attr):        return self[attr]d = AttrDict([(&#39;name&#39;, &#39;wincer&#39;), (&#39;age&#39;, &#39;20&#39;)])&gt;&gt;&gt; d.name&#39;wincer&#39;</code></pre><p>并不推荐这样做，因为在 dict 实现中，并没有要求 key 一定为合法标识符，只需要是可散列对象即可，而上面的写法一旦 key 不为合法标识符，会 raise 一个 SyntaxError：</p><pre><code class="python">d.update({(0): &#39;zero&#39;})&gt;&gt;&gt; d[(0)]&#39;zero&#39;&gt;&gt;&gt; d.0SyntaxError: invalid syntax</code></pre><p>如果非常想使用 . 来获取 value 的话，建议使用 namedtuple</p><p>当然这也就意味着必须使用合法标识符了：</p><pre><code class="python">from collections import namedtupleID = namedtuple(&#39;ID&#39;, &#39;name age&#39;)me = ID(&#39;wincer&#39;, 20)&gt;&gt;&gt; me.name&#39;wincer&#39;ID = namedtuple(&#39;ID&#39;, &#39;(1, 0) age&#39;)ValueError: Type names and field names must be valid identifiers: &#39;(1&#39;</code></pre><h3 id="实现-switch-…-case-结构"><a href="#实现-switch-…-case-结构" class="headerlink" title="实现 switch … case 结构"></a>实现 switch … case 结构</h3><p>同样借助键查询，可以实现 Python 中没有的 switch … case 结构：</p><pre><code class="python">def foo(x):    data = {        0: &#39;zero&#39;,        1: &#39;one&#39;,        2: &#39;two&#39;,    }    return data.get(x, None)</code></pre><p>所以说 Python 不设计 switch … case 语句是有原因的，看上面的实现，比 switch … case 不知道高到哪里去了。</p><h2 id="dict-和它的小伙伴们"><a href="#dict-和它的小伙伴们" class="headerlink" title="dict 和它的小伙伴们"></a>dict 和它的小伙伴们</h2><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>在添加键的时候会按顺序添加，同时 .popitem 是会删除并返回字典的最后一个元素而不是像 dict 里面一样可能会删除任意元素。</p><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>这个映射会给键一个计数器，每次更新键时都会增加这个计时器，所以这个类型可以用以给可迭代类型计数：</p><pre><code class="python">from collections import Counterct = Counter(&#39;hfkjahfkakhf&#39;)&gt;&gt;&gt; ctCounter({&#39;a&#39;: 2, &#39;f&#39;: 3, &#39;h&#39;: 3, &#39;j&#39;: 1, &#39;k&#39;: 3})ct.update(&#39;fdjlahkla&#39;)&gt;&gt;&gt; ctCounter({&#39;a&#39;: 4, &#39;d&#39;: 1, &#39;f&#39;: 4, &#39;h&#39;: 4, &#39;j&#39;: 2, &#39;k&#39;: 4, &#39;l&#39;: 2})&gt;&gt;&gt; ct.most_common(2)[(&#39;h&#39;, 4), (&#39;f&#39;, 4)]</code></pre><h3 id="UserDict"><a href="#UserDict" class="headerlink" title="UserDict"></a>UserDict</h3><p>用法见键查询。</p><h3 id="不可变映射"><a href="#不可变映射" class="headerlink" title="不可变映射"></a>不可变映射</h3><p>在 Python 3.3 后的版本，types 模块引入一个名为 MappingProxyType 的类。如果给这个类一个映射，它会返回一个只读的映射视图。但它是动态的，如果原映射改动，那么它也会相应改动。</p><pre><code class="python">&gt;&gt;&gt; int.__dict__mappingproxy({&#39;__abs__&#39;: &lt;slot wrapper &#39;__abs__&#39; of &#39;int&#39; objects&gt;,              &#39;__add__&#39;: &lt;slot wrapper &#39;__add__&#39; of &#39;int&#39; objects&gt;,              ...})from types import MappingProxyTyped = {1: &#39;A&#39;}d_proxy = MappingProxyType(d)&gt;&gt;&gt; d_proxy[2] = &#39;x&#39;TypeError: &#39;mappingproxy&#39; object does not support item assignmentd[2] = &#39;B&#39;&gt;&gt;&gt; d_proxy[2]&#39;B&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      对于字典这一基础的数据结构来说，其对 Python 程序的重要性是无可替代的，在《代码之美》一书中，作者是这么描述的：字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到它。——A.M.Kuchling
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="Python" scheme="https://blog.itswincer.com/tags/Python/"/>
    
      <category term="字典" scheme="https://blog.itswincer.com/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>《代码整洁之道》读书笔记</title>
    <link href="https://blog.itswincer.com/posts/65e48179/"/>
    <id>https://blog.itswincer.com/posts/65e48179/</id>
    <published>2018-04-19T18:11:12.000Z</published>
    <updated>2018-04-19T20:34:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>相对于任何宏伟愿景，对细节的关注甚至是更为关键的专业性基础。首先，开发者通过小型实践获得可用于大型实践的技能和信用度。其次，宏大建筑中最细小的部分，比如关不紧的门、有点儿没铺平的地板，甚至是凌乱的桌面，都会将整个大局的魅力毁灭殆尽。这就是整洁代码之所系。</p></blockquote><p><a id="more"></a>本书「序」中的这段话完美的诠释了作者写本书的意义。（简评在最后）</p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ol><li>神在细节之中。</li><li>5S 哲学包括以下概念：<ul><li>整理（Seiri）</li><li>整顿（Seiton）</li><li>清楚（Seiso）</li><li>清洁（Seiketsu）</li><li>身美（Shitsuke）</li></ul></li></ol><h2 id="整洁代码"><a href="#整洁代码" class="headerlink" title="整洁代码"></a>整洁代码</h2><ol><li>有人也许以为，关于代码的书有点落后于时代——代码不再是问题：我们应当关注模型和需求。……扯淡！我们永远抛不掉代码，因为代码呈现了需求的细节。在某些层面上，这些细节无法被忽略或抽象，必须明确之。将需求明确到机器可以执行的细节程度，就是编程要做的事。而这种规约正是<strong>代码</strong>。</li><li>勒布朗（LeBlanc）法则：<strong>稍后等于永不</strong>（Later equals never）。</li><li>多数人都知道一幅画是好还是坏。但能分辨优劣并不表示懂得绘画。能分辨整洁代码和肮脏代码，也不意味着会写整洁代码！</li><li><strong>Bjarne Stroustrup（C++ 语言发明者）</strong>：我喜欢优雅和高效的代码。代码逻辑应当直截了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没规矩的优化，高处一堆混乱来，整洁的代码只做好一件事。</li><li><strong>Grady Booch（《面向对象分析与设计》作者）</strong>：整洁的代码简单直接。整洁的代码如同优美的散文。整洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直截了当的控制语句。</li><li><strong>Ron Jeffries（《极限编程实施》作者）</strong>：简单代码，依其重要顺序：<ul><li>能通过所有测试；</li><li>没有重复代码；</li><li>体现系统中的全部设计理念；</li><li>包括尽量少的实体，比如类、方法、函数等。</li></ul></li><li><strong>Ward Cunningham（Wiki 发明者）</strong>：如果每个例程都让你感到深合己意，那就是整洁代码。如果代码让编程语言看起来像是专为解决那个问题而存在，就可以称之为漂亮的代码。</li><li>光把代码写好可不够。必须时时保持代码整洁。</li></ol><h2 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h2><ol><li><p><strong>名副其实</strong>：变量、函数或类的名称应该已经答复了所有的大问题。它该告诉你，它为什么会存在，它做什么事，应该怎么用。</p></li><li><p><strong>避免误导</strong>：应当避免使用与本意相悖的词。别用 accountList 来指称一组账号，除非它真的是 List 类型。用 accountGroup 或 bunchOfAccounts，甚至 accounts 都会好一些。</p></li><li><p><strong>做有意义的区分</strong>：以数字系列命名（a1、a2，……aN）是依义命名的对立面。这样的名称纯属误导——完全没有提供正确信息；没有提供导向作者意图的线索。</p><pre><code class="java">public static void copyChars(char a1[], char a2[]) {    for (int i = 0; i &lt; a1.length; i++) {        a2[i] = a1[i];    }}</code></pre><p>如果参数名改为 source 和 destination，这个函数就会像样许多。</p></li><li><p><strong>使用读得出来的名称</strong>：</p><pre><code class="java">private Date genymdhms; // 生成日期，年、月、日、时、分、秒private Date generationTimestamp;</code></pre></li><li><p><strong>使用可搜索的名称</strong>：窃以为单字母名称<strong>仅</strong>用于短方法中的本地变量。名称长短应于其作用域大小相对应。</p></li><li><p><strong>避免思维映射</strong>：不应当让读者在脑中把你的名称翻译为他们熟知的名称。</p></li><li><p><strong>类名</strong>：类名和对象名应该是名词或名词短语，如 Customer、WikiPage。避免使用 Manager、Data 这样的类名。</p></li><li><p><strong>方法名</strong>：方法名应当是动词或动词短语，如 postPayment、deletePage 或 save。</p></li><li><p><strong>每个概念对应一个词</strong>：给每个抽象概念选一个词，并且一以贯之。</p></li><li><p><strong>别用双关语</strong>：避免将同一单词用于不同目的。</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li>函数的第一规则是要短小。第二条规则是还要更短小。</li><li>函数应该做一件事。做好这件事。只做这一件事。</li><li>别害怕长名称。长而具有描述性的名称，要比短而令人费解的名称好。长而具有描述性的名称，要比描述性的长注释好。</li><li>最理想的参数数量是零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应尽量避免三（三参数函数）。如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。</li><li>函数要么做什么事，要么回答什么事，但二者不可兼得。函数应该修改某对象的状态，或是返回该对象的有关信息。</li><li>重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。</li><li>我写函数时，一开始都冗长而复杂。有太多缩进和嵌套循环。然后我打磨这些代码，分解函数、修改名称、消除重复。我缩短和重新安置方法。有时我还拆散类。</li><li>大师级程序员把系统当作故事来讲，而不是当作程序来写。他们使用选定编程语言提供的工具构建一种更为丰富且更具表达力的语言，用来讲那个故事。</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li><strong>Brian W. Kernighan 与 P. J. Plaugher</strong>：别给糟糕的代码加注释——重新写吧。</li><li>注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。注意，我用了「失败」一词。我是说真的。注释总是一种失败。我为什么要极力遍地注释？因为注释会撒谎。</li><li><strong>好注释</strong>：<ol><li>法律信息</li><li>提供信息的注释</li><li>对意图的解释</li><li>阐释</li><li>警示</li><li>TODO</li></ol></li></ol><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ol><li>你今天编写的功能，极有可能在下一版本中被修改，但代码的可读性却会对以后可能发生的修改行为产生深远影响。</li><li><strong>垂直格式</strong>：<ol><li>关系密切的概念应该相互靠近。</li><li>变量声明应尽可能靠近其使用位置。</li><li>实体变量应该在类的顶部声明。</li><li>若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽肯能放在被调用者上面。</li></ol></li><li><strong>横向格式</strong>：<ol><li>应该尽量保持代码行短小。死守 80 个字符上限有点僵化，至多在 100 或 120 个字符。</li><li>赋值操作符周围加上空格字符，以此加上强调目的。</li><li>不在函数名和左圆括号之间加空格。</li><li>源文件是一种继承结构，而不是一种大纲结构。类中的方法相对该类缩进一个层级。方法的实现相对方法声明缩进一个层级。</li></ol></li></ol><h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><ol><li><p>过程式代码便于在不该动既有数据结构的前提下添加新函数。面向对象代码便于在不改动既有函数的前提下添加新类。</p></li><li><p>得墨忒耳率认为，类 C 的方法 f 只应该调用以下对象的方法：</p><ul><li>C</li><li>由 f 创建的对象；</li><li>作为参数传递给 f 的对象；</li><li>由 C 的实体变量持有的对象。</li></ul><p>方法不应调用由任何函数返回的对象的方法。换言之，只跟朋友谈话，不与陌生人谈话。</p></li><li><p>对象曝露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。数据结构曝露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。</p></li></ol><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol><li>错误处理很重要，<strong>但如果它搞乱了代码逻辑，就是错误的做法</strong>。</li><li>在某种意义上，try 代码块就像是事务。catch 代码块将程序维持在一种状态，无论 try 代码块中发生了什么均如此，所以，在编写可能抛出异常的代码时，最好先写出 try-catch-finally 语句。</li><li>你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。</li><li>对异常可以依据其来源分类：是来自组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？不过，当我们在应用程序中定义异常类时，最重要的考虑应该是<strong>它们如何被捕获</strong>。</li><li>返回 null 值，基本上是在给自己增加工作量，也是在给调用者添乱。只要有一处没检查 null 值，应用程序就会失控。在方法中返回 null 值是糟糕的做法，但将 null 值传递给其他方法就更糟糕了。</li></ol><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><ol><li><strong>学习性测试</strong>（learning tests）：不要在生产代码中试验新东西，而是编写测试来遍览和理解第三方代码</li><li>使用尚不存在的代码，将尚未开发完毕的 API 从中隔离出来。自己通过使用符合应用程序的接口，一旦 API 被定义出来，再将二者对接。</li><li>通过代码中少数几处引用第三方边界接口的位置来管理第三方边界。</li></ol><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol><li>TDD 三定律：<ol><li>在编写不能通过的单元测试前，不可编写生产代码。</li><li>只可编写刚好无法通过的单元测试，不能编译也不算通过。</li><li>只可编写刚好足以通过当前失败测试的生产代码。</li></ol></li><li>脏测试等同于——如果不是坏于的话——没测试。</li><li>测试代码和生产代码一样重要。它可不是二等公民。它需要被思考、被设计和被照料。它该像生产代码一般保持整洁。</li><li>整洁的测试有什么要素？有三个要素：可读性、可读性和可读性。</li><li>整洁的测试遵循以下 5 条规则：<ol><li><strong>快速（Fast）</strong>：测试应该够快。</li><li><strong>独立（Independent）</strong>：测试应该相互独立。</li><li><strong>可重复（Repeatable）</strong>：测试应当可在任何环境中重复通过。</li><li><strong>自足验证（Self-Validating）</strong>：测试应该有布尔值输出。</li><li><strong>及时（Timely）</strong>：测试应及时编写。</li></ol></li></ol><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol><li>类的第一条规则是类应该短小。第二条规则是还要更短小。</li><li>单一权责原则（SRP）认为，类或模块应有且只有一条加以修改的理由。</li><li>系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。</li><li>通常而言，方法操作的变量越多，就越黏聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。</li><li>开放-闭合原则（OCP）：类应当对扩展开放，对修改封闭。</li><li>依赖倒置原则（DIP）：类应当依赖于抽象而不是依赖于具体细节。</li></ol><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><ol><li>软件系统应将启始过程和启始过程之后的运行时逻辑分离开，在启始过程中构建应用对象，也会存在相互缠结的以来关系。</li><li>可以使用抽象工厂模式让应用自行控制何时创建对象，但构造的细节却隔离于应用程序代码之外。</li><li>依赖注入（Dependency Injection）：对象不应负责实体化对自身的依赖。反之，它应当将这份权移交给其他「有权力」的机制，从而实现控制的反转。</li><li>我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事。这就是迭代和增量敏捷的精髓所在。</li><li>面向方面编程（aspect-oriented）:被称为方面的模块构造指明了系统中哪些点的行为会以某种一致的方式被修改，从而支持某种特定的场景。</li></ol><h2 id="迭进"><a href="#迭进" class="headerlink" title="迭进"></a>迭进</h2><ol><li>简单设计规则 1：运行所有测试：遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近 OO 低耦合度、高内聚度的目标。</li><li>简单设计规则 2：重构：在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称等。</li><li>不可重复：「小规模复用」可大量降低系统复杂性。</li><li>表达力：做到有表达力的最重要方式却是尝试。</li><li>尽可能少的类和方法。</li></ol><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><table><thead><tr><th>名词</th><th>基础定义</th></tr></thead><tbody><tr><td>限定资源</td><td>并发环境中有着固定尺寸或数量的资源。例如数据库连接和固定尺寸读/写缓存等</td></tr><tr><td>互斥</td><td>每一时刻仅有一个线程能访问共享数据或共享资源</td></tr><tr><td>线程饥饿</td><td>一个或一组线程互相等待执行结束。</td></tr><tr><td>死锁</td><td>两个或多个线程互相等待执行结束。</td></tr><tr><td>活锁</td><td>执行次序一致的线程，每个都想要起步，但发现其他线程已经「在路上」。</td></tr></tbody></table><ol><li><p>对象是过程的抽象。线程是调度的抽象。</p></li><li><p>并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。</p></li><li><p>并发软件的中肯说法：</p><ul><li>并发会在性能和编写额外代码上增加一些开销；</li><li>正确的并发是复杂的，即便对于简单的问题也是如此；</li><li>并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待；</li><li>并发常常需要对设计策略的根本性修改。</li></ul></li><li><p>生产者-消费者模型：一个或多个生产者线程创建某些工作，并置于缓存或者队列中。一个或者多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。</p></li><li><p>读者-作者模型：当存在一个主要为读者线程提供信息源，但只是偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。协调读者线程不去读取正在更新的信息，而作者线程倾向于长期锁定读者线程。</p></li><li><p>宴席哲学家：许多企业级应用中会存在进程竞争资源的情形，如果没有用心设计，这种竞争会遭遇死锁，活锁，吞吐量和效率低等问题。</p></li></ol><p>本书后几章主要侧重于讲解 Java 代码的一些例子，对其它语言帮助不大，在这里就不做整理了。</p><hr><p>正如我在<a href="../a6c2a51d/">上一篇读书笔记</a>中所说的：每一本中都会充斥着许多作者的自己的观点、看法，而唯有价值观相符合或相接近的人才会觉得本书写得很不错，上一本《黑客与画家》是，这本《代码整洁之道》也是，你可能很难认为变量的命名需要有那么考究，函数的长短有那么重要，心里想着程序能运行就没事，甚至连 WARNING 都忽视掉，这类人想必并不是本书的目标群体。而本书的目标群体在开头已经注明了：你想成为一个更好的程序员。其实我觉得目标群体还可以加上一小撮人：有强迫症的程序员——比如我。</p><p>我曾经看自己四个月前的代码能羞愧得钻进地里，心想着怎么能写出这么烂的<a href="https://gist.github.com/WincerChan/362331456a6e0417c5aa1cf3ff7be2b7/revisions" target="_blank" rel="noopener">代码</a>。这四个月固然有我对该门语言较高层级的数据结构更加熟悉，能更熟练的操作它们，但更多的是编程观念的改变：需要用心来写代码，不要简单敷衍了事，不要认为程序只要能运行就算成功。程序毕竟还是写给人看的，就算不是为了别人，看着意义明确的变量，缩进优美的段落，结构分明的函数，想必自己心里也会很舒畅的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;相对于任何宏伟愿景，对细节的关注甚至是更为关键的专业性基础。首先，开发者通过小型实践获得可用于大型实践的技能和信用度。其次，宏大建筑中最细小的部分，比如关不紧的门、有点儿没铺平的地板，甚至是凌乱的桌面，都会将整个大局的魅力毁灭殆尽。这就是整洁代码之所系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="文字阁" scheme="https://blog.itswincer.com/categories/%E6%96%87%E5%AD%97%E9%98%81/"/>
    
    
      <category term="笔记" scheme="https://blog.itswincer.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码" scheme="https://blog.itswincer.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Nextcloud 搭建私人云服务教程</title>
    <link href="https://blog.itswincer.com/posts/bf0413ac/"/>
    <id>https://blog.itswincer.com/posts/bf0413ac/</id>
    <published>2018-03-31T15:03:31.000Z</published>
    <updated>2018-04-01T19:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>我一直很不相信国内的那些云服务提供商（尤其是在李彦宏发表的讲话「中国用户对隐私问题没那么敏感，在个人隐私方面更加开放，一定程度上愿用隐私换方便和效率」后），因为怕隐私得不到保障，故而我的一些隐私数据都是存放在国外的云盘（如 Dropbox、Drive 等）上。<a id="more"></a></p><p>可这俩在国内都被墙了，而手机翻墙总是显得有些不够方便，与是我就琢磨着自己搭建一个云服务，随后就发现了 Nextcloud 这一开源云服务。而网上的教程都太过复杂了，对新手太过不友好，于是乎——一篇近乎傻瓜式的 Nextcloud 教程诞生了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里采用 Docker 容器方式来安装 Nextcloud，这样就不用担心各种环境依赖了（Nextcloud 的依赖简直多得吓人，而 Dockerfile 会帮你把依赖都配置好）</p><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><blockquote><p>注：Docker 仅支持 64-bit 的系统</p></blockquote><p>Docker 现已被各大发行版的仓库收入，采用正常安装命令即可：</p><pre><code class="bash">yum -y install docker</code></pre><p>随后，启动 Docker 守护进程：</p><pre><code class="bash"># systemctlsystemctl start docker# Serviceservice docker start</code></pre><h3 id="安装-NextCloud"><a href="#安装-NextCloud" class="headerlink" title="安装 NextCloud"></a>安装 NextCloud</h3><h4 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h4><p>有了 Docker 后，就可以几行代码安装 Nextcloud 了：</p><pre><code class="bash"># clone nextcloud 的 docker 容器git clone https://github.com/nextcloud/docker.git# 耐心等待安装docker run -d -p 8080:80 nextcloud </code></pre><p>安装完成后先别忙着启动，<code>docker ps -a -q</code> 查看一下容器的 id，是一串 12 位的字符串，为了便于记忆，重命名一下：</p><pre><code class="bash">docker rename ××× nextcloud     # ××× 即为容器 id</code></pre><p>随后就可以采用如下命令启动了：</p><pre><code class="bash">docker start nextcloud# 测试curl http://localhost:8080</code></pre><p>这样，就完成了 Nextcloud 的安装工作。</p><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>方法一只能安装最新版的 Nextcloud，而最新版缺少部分功能，如：无法添加 Drive 和 Dropbox 的外置存储。如果你对外置存储不是很 care 的话，那就按照方法一安装就可以了。</p><pre><code class="bash">git clone https://github.com/nextcloud/docker.gitcd docker/12.0/apache</code></pre><p>这里采用官方编写的 Dockerfile 手动构建，所以时间会花得比较久。</p><pre><code class="bash">docker build -t nextcloud .</code></pre><p>这时候用 <code>docker images</code> 应该可以看到刚刚创建的镜像了，随后创建容器：</p><pre><code class="bash">docker create -v /var/www/html/apps/:/var/www/html/apps -v /var/www/html/config/:/var/www/html/config -v /var/www/html/data/:/var/www/html/data -p 127.0.0.1:8080:80/tcp --name nextcloud nextcloud</code></pre><p>稍稍解释一下参数：</p><ul><li>-v 后面是地址，前半部分是 VPS 的地址，后半部分是容器内的地址</li><li>-p 后面是端口号</li><li>–name 后面是容器名称</li><li>最后的 nextcloud 是镜像名称</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h3><p>由于 NextCloud 已经占用了 8080 端口，这里采用 Nginx 做反向代理，将域名直接解析至 8080 端口。</p><pre><code class="nginx">server {  listen 80;  server_name cloud.example.com;  location / {    proxy_pass http://localhost:8080;  }}</code></pre><p>重启 Nginx 服务后，就可以通过 cloud.example.com 来访问云服务了。</p><h3 id="NextCloud-配置"><a href="#NextCloud-配置" class="headerlink" title="NextCloud 配置"></a>NextCloud 配置</h3><pre><code class="bash"># 进入容器内的 bashdocker exec -i -t nextcloud bash</code></pre><h4 id="重定向-overwritehost"><a href="#重定向-overwritehost" class="headerlink" title="重定向 overwritehost"></a>重定向 overwritehost</h4><p>有时候 NextCloud 会自己定向至本地的 8080 端口，所以需要手动重写正确的地址：如果提示不能定位软件包，先执行 <code>apt-get update</code>。</p><pre><code class="bash">vim config/config.php# 加上下面这行&#39;overwritehost&#39; =&gt; &#39;cloud.example.com&#39;,</code></pre><p>重启，让配置生效：</p><pre><code class="bash">docker restart nextcloud</code></pre><h3 id="MySQL-配置"><a href="#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h3><p><del>由于我 VPS 的内存比较小，所以并没有启用 MySQL/MariaDB 数据库（怕爆内存），而是采用了 SQLite，反正也是我一个人用，问题不大。</del></p><p>开启了 MySQL 后发现内存也就多了 20M（但性能的提升可不是一点半点），遂还是改成 MySQL 了：</p><ol><li><p>安装 MySQL（这里采用 MariaDB 分支）</p><pre><code class="bash">yum -y install mariadb-server mariadb-client# 设置一下 root 密码等mysql_secure_installation</code></pre></li><li><p>开启 daemon 服务</p><pre><code class="bash">systemctl start mariadbsystemctl enable mariadb</code></pre></li><li><p><code>mysql -uroot -p</code> 登录 MySQL</p><pre><code class="mysql"># 创建 nextcloud 数据库CREATE DATABASE nextcloud CHARACTER SET = utf8 COLLATE = utf8_general_ci;# 创建 nextcloud 的用户CREATE USER nextcloud IDENTIFIED BY &#39;admin123&#39;;# 赋予对数据库所有的权限GRANT ALL ON nextcloud.* TO nextcloud;</code></pre></li></ol><h3 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h3><ol><li><p>打开 <a href="https://cloud.example.com" target="_blank" rel="noopener">https://cloud.example.com</a></p></li><li><p>创建管理员帐号和密码</p></li><li><p>数据库就选择 MySQL/MariaDB，其它参考下表：</p></li></ol><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">用户名</td><td style="text-align:center">nextcloud</td></tr><tr><td style="text-align:center">密码</td><td style="text-align:center">admin123</td></tr><tr><td style="text-align:center">数据库名</td><td style="text-align:center">nextcloud</td></tr><tr><td style="text-align:center">地址</td><td style="text-align:center">172.17.0.1</td></tr></tbody></table><p><strong>注意：这里的地址千万不要填写成了 localhost 或者 172.0.0.1，因为这里的地址需要容器内与外部通信。</strong></p><p>点击完成后，等待几秒就可以使用了。</p><h2 id="挂载外部云盘"><a href="#挂载外部云盘" class="headerlink" title="挂载外部云盘"></a>挂载外部云盘</h2><p>由于我 VPS 的容量只有 10g，故而放不了过多的视频，就考虑采用外部存储的方法，将 Drive、Dropbox 挂载至 Nextcloud 外部存储或者 VPS。</p><blockquote><p>注：Nextcloud 13 已经取消对 Drive、Dropbox 外部存储的支持（这时候你也可以选择把 Drive 直接挂载至 VPS 本地目录，再通过外部存储链接至挂载目录来完成）。</p></blockquote><h3 id="启用外部存储插件"><a href="#启用外部存储插件" class="headerlink" title="启用外部存储插件"></a>启用外部存储插件</h3><p>在应用页面，启用 <code>External storage support</code> 插件：如果提示：「没有安装 “smbclient”无法挂载 “SMB / CIFS”, “SMB / CIFS 使用 OC 登录信息”. 请联系您的系统管理员安装」</p><p>解决办法：</p><h3 id="安装-smbclient"><a href="#安装-smbclient" class="headerlink" title="安装 smbclient"></a>安装 smbclient</h3><pre><code class="bash"># 进入容器的内的 consoledocker exec -i -t nextcloud bashapt-get install libsmbclient-dev</code></pre><p>这里简单说一下，不管你的 VPS 原本的系统是 CentOS、RedHat、Debian，统一都用 apt-get 安装，因为现在处于的是 docker 容器内的系统，与 VPS 的系统是分离的。</p><p>接着再安装 smbclient：</p><pre><code class="bash">pecl install smbclient</code></pre><p>同时会提示：「You should add “extension=smbclient.so” to php.ini」，这里又被小坑一把，网上大部分教程所说的 <code>/etc/php.d/php.ini</code> 并不存在，在 docker 容器内部该文件是在：</p><pre><code class="bash">vim /usr/local/etc/php/conf.d/docker-php-ext-intl.ini# 加上下面这行extension=smbclient.so</code></pre><p>随后重启 Nextcloud 服务就应该就 OK 了。</p><p>随后如果你安装的 Nextcloud 是 13 版本及以上的话，就只有考虑用 <a href="https://www.box.com/" target="_blank" rel="noopener">box</a> 提供的 <a href="https://community.box.com/t5/Upload-and-Download-Files-and/WebDav-with-Box/ta-p/310" target="_blank" rel="noopener">WebDAV</a> 来作为外置存储了，不过只有 10G 的容量，且最大文件限制是 250MB。如果是用的 12 版本及以下的话，就可以考虑采取 Drive 作为外置存储了：</p><h3 id="获取-API"><a href="#获取-API" class="headerlink" title="获取 API"></a>获取 API</h3><ol><li><p>访问 <a href="https://www.orgleaf.com/go.php?url=https://console.developers.google.com" target="_blank" rel="noopener">Google 开发者平台</a>：</p></li><li><p>点击「启用 API 和服务」</p></li><li><p>点击「Google Drive API」</p></li><li><p>点击「启用」</p></li><li><p>点击左侧的凭据 -&gt; OAuth 同意屏幕：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844300/blog/nextcloud_tutorial/oauth.png" alt="oauth 示例"></p><p>按照以上格式填写，点击保存</p></li><li><p>随后创建凭据：</p><p>应用类型选择<strong>网页应用</strong>，其它的参考以下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844366/blog/nextcloud_tutorial/url.png" alt="url 配置"></p><p>点击创建后，会弹出悬浮框告诉你 ID 和 Key。</p></li></ol><h3 id="配置-Nextcloud"><a href="#配置-Nextcloud" class="headerlink" title="配置 Nextcloud"></a>配置 Nextcloud</h3><p>登录 Nextcloud，转至管理页面，点击「外部存储」，选择 Google Drive，填入 API 和 Key，点击授权，若授权时出现 400 错误，那么是重定向的 URI 出问题了，再添加如下一条：</p><pre><code>https://cloud.example.com/index.php/settings/admin/externalstorages</code></pre><p>如果提示「此应用未经过验证」，点击高级 -&gt; 转至 example.com，忽略掉就行。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844407/blog/nextcloud_tutorial/external_storage.png" alt="外置存储"></p><p>当出现了绿色按钮，就表示配置成功了。</p><p>参考：</p><ul><li><a href="https://github.com/nextcloud/docker#how-to-use-this-image" target="_blank" rel="noopener">Docker image of Nextcloud</a></li><li><a href="https://oing9179.github.io/blog/2017/03/Setup-Nextcloud-using-Docker-and-Nginx/" target="_blank" rel="noopener">用 Docker 和 Nginx 搭建自己的云服务器（Nextcloud）</a></li><li><a href="https://www.orgleaf.com/903.html" target="_blank" rel="noopener">连接 Google Drive 教程</a></li><li><a href="https://www.brilliantcode.net/486/freenas-10-nextcloud-use-smb-as-external-storage/" target="_blank" rel="noopener">FreeNAS 10 NextCloud 開啟外部儲存媒體的 SMB 功能</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我一直很不相信国内的那些云服务提供商（尤其是在李彦宏发表的讲话「中国用户对隐私问题没那么敏感，在个人隐私方面更加开放，一定程度上愿用隐私换方便和效率」后），因为怕隐私得不到保障，故而我的一些隐私数据都是存放在国外的云盘（如 Dropbox、Drive 等）上。
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="云服务" scheme="https://blog.itswincer.com/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="NextCloud" scheme="https://blog.itswincer.com/tags/NextCloud/"/>
    
      <category term="VPS" scheme="https://blog.itswincer.com/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>没有希望的事儿，还有坚持的必要吗</title>
    <link href="https://blog.itswincer.com/posts/18b98ea6/"/>
    <id>https://blog.itswincer.com/posts/18b98ea6/</id>
    <published>2018-03-21T10:47:45.000Z</published>
    <updated>2018-03-21T18:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>「你说，没有希望的事，还有坚持的必要吗？」</p><p>确实是没想到，看国产青春剧也能看出了共鸣。<a id="more"></a></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858577/blog/still_insist/caption1.jpg" alt="拼接截图.jpg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858598/blog/still_insist/caption2.jpg" alt="拼接截图 (1).jpg"></p><p>忘记很早之前在哪看到过一句话：人会长大三次。第一次是在发现自己不是世界中心的时候；第二次是在发现即使再怎么努力，终究还是有些事令人无能为力的时候；第三次是在明知道有些事可能会无能为力，但还是会尽力争取的时候。</p><p>最初看这句话还没什么感觉，最近看了「最好的我们」后，突然就触动了。</p><p>那种触动，想来就是怎么也绕不开的「成长」了：自己做了想做的事，而生活却没有给自己想要的结果。于是乎，以后再遇见了想做的事，开始犹豫了，开始畏缩了，开始计较得失了，因为有了之前的经历，担心自己做了，却也得不到自己想要的结果。</p><p>你当然可以说是因为自己长大了，会计较得失了、不会像小时候一样：想干什么就去干什么。是啊，第二次成长的你知道了有些事情即使再怎么努力，也不会得到满意的结果，于是干脆就不去做了。</p><p>可目前处于不明成长阶段的我啊，又觉得凡事要是都仔细衡量得失后再去想做还是不做的话，那人生想必会少掉许多乐趣、会错过许多事情。</p><hr><p>我果然还是不适合看电视剧，花了一个月时间才把《最好的我们》看完（小时候那种看电视剧甚至广告时间都不愿意转台生怕错过衔接部分的劲儿都不知道哪去了，以后有时间还是多看看电影和书），听说还有几部青春剧也挺不错（《你好，旧时光》、《一起同过窗》等），就不看了，虽说确实能勾起高中时的那些或苦涩或美好的回忆，可那些回忆却再也不可得了。</p><p>也不想总是陷在回忆里，毕竟我，到底是已经长大了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「你说，没有希望的事，还有坚持的必要吗？」&lt;/p&gt;
&lt;p&gt;确实是没想到，看国产青春剧也能看出了共鸣。
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="成长" scheme="https://blog.itswincer.com/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="感想" scheme="https://blog.itswincer.com/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>QQ 音乐外链解析</title>
    <link href="https://blog.itswincer.com/posts/72171293/"/>
    <id>https://blog.itswincer.com/posts/72171293/</id>
    <published>2018-03-07T12:23:06.000Z</published>
    <updated>2018-03-08T17:39:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>大概在五天前，忽然发现一直在用的网易云解析不能用了，去作者的项目查看才知道原来是网易云更换了新的接口，旧接口的请求现在统一返回 403。于是乎，便萌生了自己写一个接口的想法。<a id="more"></a></p><p>其实网易云的外链获取目前还是有几种可用方案，比如：</p><ol><li><a href="https://m1.jixun.moe/" target="_blank" rel="noopener">云音乐直链生成器</a></li><li>手动替换：<code>https://music.163.com/song/media/outer/url?id=[].mp3</code>，将中括号改为歌曲 id，即为外链</li></ol><p>这两种方法其实大同小异，都会 302 至歌曲的缓存地址，但也存在一个身为强迫症的我无法忍受的缺点——缓存地址的协议是 <code>http</code>（从云音乐官网现在还有大量的 Mixed Content 就可以看出网易对这方面并不上心），而且自己将协议修改成 <code>https</code> 后访问部分歌曲又会有机率出现 403，这可真是逼死我了：于是决定暂时放弃掉网易云，换其他家的顶着。</p><h2 id="QQ-音乐"><a href="#QQ-音乐" class="headerlink" title="QQ 音乐"></a>QQ 音乐</h2><p>考虑了一圈，还是决定选 QQ 音乐。在网上也找到了 QQ 音乐所提供的接口：</p><ul><li>请求地址：<code>https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg</code></li><li>参数，有三个：<ol><li>songmid：歌曲页 Url 的 <code>https://y.qq.com/n/yqq/song/{}.html</code> 括号部分</li><li>filename：歌曲名 <code>&#39;C00&#39; + songmid + &#39;.m4a&#39;</code></li><li>guid：随机生成的数字串 <code>int(random() * 2147483647) * int(time() * 1000) % 10000000000</code></li></ol></li></ul><p>综上，歌曲的请求地址为：<code>https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?format=json&amp;cid=205361747&amp;uin=0&amp;songmid={smid}&amp;filename={filename}&amp;guid={guid}</code></p><p>向这个地址请求后，会得到一个 JSON 格式的数据文件，包含了我们需要的信息：vkey</p><pre><code class="bash">curl &#39;https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?format=json&amp;cid=205361747&amp;uin=0&amp;songmid={smid}&amp;filename={filename}&amp;guid={guid}&#39;{&quot;code&quot;:0,&quot;cid&quot;:205361747,&quot;userip&quot;:&quot;××.××.××.××&quot;,&quot;data&quot;:{&quot;expiration&quot;:80400,&quot;items&quot;:[{&quot;subcode&quot;:104001,&quot;songmid&quot;:&quot;000uhMwj387EBp&quot;,&quot;filename&quot;:&quot;C00000uhMwj387EBp.m4a&quot;,&quot;vkey&quot;:&quot;B6BB8F604606DFDC82FD81CE33BC9C0277365D4B8B1BC8BCC909E408EAC9822315B2B9D021F42B495FA14AADCB598B21BCDB867931B7A953&quot;}]}}</code></pre><p>得到了最重要的 <code>vkey</code> 字段后，就可以解析出歌曲的「真实链接」了：</p><p><code>https://dl.stream.qqmusic.qq.com/{filename}?vkey={vkey}&amp;guid={guid}&amp;uin=0&amp;fromtag=66</code></p><p>你可能注意到返回的信息中还包含了 <code>expiration</code> 字段。是的，<code>vkey</code> 只有在该时间段内才有效，当然这个问题很好解决，可以把该程序部署至服务器，而从服务器发起请求获取链接后 302 至歌曲链接。</p><p>而当我满心欢喜的把这个脚本向服务端部署的时候，却失败了：原因是接口的请求地址只支持国内的（想来是因为 QQ 音乐只拿到了在大陆地区的版权），而我的服务器在美国，这个问题就有些难解决了（我没有国内的服务器）。</p><p>于是我想另辟蹊径。</p><h2 id="纯-JS-解析"><a href="#纯-JS-解析" class="headerlink" title="纯 JS 解析"></a>纯 JS 解析</h2><p>既然服务端无法解析，那就用 JS 在用户端解析。</p><p>但又带来了另一个问题——跨域。</p><p>目前跨域请求比较好的解决方案有两种：CORS 和 JSONP，其中 CORS 需要服务器端设置 <code>Access-Control-Allow-Origin</code>，所以也就只有使用 JSONP 了。</p><blockquote><p>注意：跨域请求失败原因浏览器端阻止显示，并非服务器端无法返回数据</p></blockquote><p>使用 JSONP 时要求服务端返回的是满足 <a href="https://zh.wikipedia.org/wiki/JSONP#%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">JSONP 模式</a>的文件，不能是纯 JSON 文件，举个例子：</p><pre><code class="javascript">var url1 = &quot;https://lab.itswincer.com/jsonp/without-callback.js&quot;;var url2 = &quot;https://lab.itswincer.com/jsonp/with-callback.js&quot;;function foo(data) {    alert(`Hi, I am ${data.name}`);}var script = document.createElement(&#39;script&#39;);script.setAttribute(&#39;src&#39;, url1);document.body.appendChild(script);script.setAttribute(&#39;src&#39;, url2);document.body.appendChild(script);</code></pre><p>其中 <code>without-callback.js</code> 返回的是纯 JS 文件，<code>with-callback.js</code> 返回的是满足模式的 JS 文件。可以运行上面代码看看结果。</p><p>本想直接用现成的 <code>ajax</code>，考虑到并非所有的网站都引入了 jQuery，而为 <code>ajax</code> 就引入一个那么庞大的库又有些没必要。</p><p>于是就自己封装了一个 <code>getJSONP()</code> 接口来搭配 <code>getMusic()</code> 使用。</p><p>项目已开源，具体的代码见<a href="https://github.com/WincerChan/QQMusic-Parse" target="_blank" rel="noopener">这里</a>，有很详细的注释。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>为了使接口更干净，没有使用 callback 函数，而是使用了 ES7 的新特性 async、await。尝试过使用 Babel 等工具转换成兼容更好的 ES5 代码，但是并没有成功，故而浏览器的兼容可能存在问题。</p><p>引入<a href="https://cdn.jsdelivr.net/gh/wincerchan/QQMusic-Parse@0.3/parse.min.js" target="_blank" rel="noopener">这个 JS 文件</a>：</p><p>接口：<code>await getMusic()</code>，如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844981/blog/qqmusic_parse/sample.png" alt="示例"></p><blockquote><p>注意：在调用 getMusic() 的时候一定要加上 await 关键字，否则返回的就是一个 Promise 对象了</p></blockquote><h3 id="配合-Aplayer"><a href="#配合-Aplayer" class="headerlink" title="配合 Aplayer"></a>配合 Aplayer</h3><p>由于使用了 ES7 的新特性：async 和 await，故而 Aplayer 的配置文件也需要稍加改动：需要将原配置信息放至包含 <code>async</code> 关键字的函数内，随后调用这个函数，如下：</p><pre><code class="javascript">async function syncHand() {    new Aplayer(...);}syncHand();</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>越来越认同保罗 · 格雷厄姆那句「黑客就像画家，工作起来是有心理周期的有时候，你有了一个令人兴奋的新项目，你会愿意为它一天工作 16 个小时。等过了这一阵，你又会觉得百无聊赖，对所有事情都提不起兴趣。」话了，简直就是我的写照：这四天大约花费了 30 小时（当然有很大一部分缘由是之前没怎么学过 JavaScript，修改一下别人的代码还行，自己写就有点「捉襟见肘」了），而估计后几天又会陷入「空窗期」了。</p><p>而 JavaScript 又是一门有很多<del>坑爹</del>特性的语言，也让我把初学者的坑基本上都踩完了（还是写 Python 爽）。同时也感觉学习新东西的最好、最快的方法就是实战，换句话说，抱着解决问题的目的去学习所学到的知识远比你抱着单纯学习目的所学的知识要更快、更牢靠。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;大概在五天前，忽然发现一直在用的网易云解析不能用了，去作者的项目查看才知道原来是网易云更换了新的接口，旧接口的请求现在统一返回 403。于是乎，便萌生了自己写一个接口的想法。
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="音乐解析" scheme="https://blog.itswincer.com/tags/%E9%9F%B3%E4%B9%90%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Javascript" scheme="https://blog.itswincer.com/tags/Javascript/"/>
    
      <category term="网易云" scheme="https://blog.itswincer.com/tags/%E7%BD%91%E6%98%93%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>一台 VPS 的正确打开方式</title>
    <link href="https://blog.itswincer.com/posts/b3085a7/"/>
    <id>https://blog.itswincer.com/posts/b3085a7/</id>
    <published>2018-02-22T19:38:04.000Z</published>
    <updated>2018-04-02T14:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实像 Hexo 这样的静态博客框架本不需要服务器的，GitHub Pages 就提供免费的托管服务、且不限流量，但内心那点不安分因素总是撩拨着我：比如可以自定防护规则、可以搭建私有 Git 服务、可以搭建自己的 API（这个比较重点）、还能自己搭建 SS 服务，于是乎就买了一台 VPS。<a id="more"></a></p><p>由于我的博客使用了 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare</a> 作为 CDN 服务商，而国内的电信和联通用户是默认解析到 Cloudflare 的美西结点，只有移动用户是解析到香港节点，所以为了 API 的快取速度（即：本机 -&gt; Cloudflare -&gt; VPS -&gt; Cloudflare -&gt; 本机），将服务器选在了洛杉矶，每年 20$、1T 流量、10G 固态、512M 内存，搭建一个静态博客和几个 API 足够了。</p><h2 id="简化-SSH-登录"><a href="#简化-SSH-登录" class="headerlink" title="简化 SSH 登录"></a>简化 SSH 登录</h2><p>SSH 的安全验证有两种级别：</p><ol><li>基于密码：知道帐号和密码，就可以登录到远程主机，这种方式无法避免「中间人」攻击</li><li>基于密钥：创建一对密钥，并把公钥放至服务器，每次通信都会检验密钥，从而可以避免「中间人」攻击</li></ol><p>这里介绍第二种方法。</p><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>如果在使用 GitHub 的时候已经生成过，那么这一步可以略过</p><pre><code class="bash">ssh-keygen                        # 默认生成长度为 2048 位的 RSA 密钥ssh-keygen -b 4096                # 可以通过添加参数 -b 设定长度</code></pre><p>随后就会生成一对密钥，默认为：id_rsa（私钥）、id_rsa.pub（公钥）</p><h3 id="上传至服务器"><a href="#上传至服务器" class="headerlink" title="上传至服务器"></a>上传至服务器</h3><p>使用 ssh-copy-id 命令</p><pre><code class="bash">ssh-copy-id username@server-addr</code></pre><p>需要输入远程服务器的登录密码，随后 id_rsa.pub（公钥）会自动上传至服务器的 <code>~/.ssh/authorized_keys</code> 文件中</p><p>随后再进行 SSH 连接时，就不需要再输入密码了</p><h3 id="简化-IP"><a href="#简化-IP" class="headerlink" title="简化 IP"></a>简化 IP</h3><p>虽不用输入密码，但仍需要输入服务器登录名和 IP 地址，所以需要将配置写入 <code>~/.ssh/config</code> 中：</p><pre><code class="yaml">Host wincer                # 这里填写简化名称  HostName ××.××.××.××    # 服务器 IP  Port 22                # 端口号  User root                # 远程登录用户名</code></pre><p>随后再进行 SSH 连接时，输入 <code>ssh wincer</code> 就可以登录了</p><p><code>scp</code> 命令也可以简化成以下：</p><pre><code class="bash">scp FILENAME wincer:PATH </code></pre><h2 id="作为-GitHub-Pages"><a href="#作为-GitHub-Pages" class="headerlink" title="作为 GitHub Pages"></a>作为 GitHub Pages</h2><p>目前我的博客仍然在<a href="https://github.com/WincerChan/MyBlog" target="_blank" rel="noopener">该仓库</a>的 master 分支上保留有静态文件，仅作备份。</p><h3 id="添加-DNS-记录"><a href="#添加-DNS-记录" class="headerlink" title="添加 DNS 记录"></a>添加 DNS 记录</h3><p>首先为 DNS 解析添加一条 「A 记录」，记录值为 VPS 所分配的 IP</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530857776/blog/vps_open_mode/a_record.png" alt="A 记录"></p><h3 id="更改-Nginx-配置"><a href="#更改-Nginx-配置" class="headerlink" title="更改 Nginx 配置"></a>更改 Nginx 配置</h3><p>SSH 登录后，编辑 Nginx 的配置文件 <code>vim /etc/nginx/nginx.conf</code>：</p><pre><code class="nginx">server {  listen        80;  server_name    blog.itswincer.com;  index         index.html;  root             /data/www/hexo;}</code></pre><p>可部署多个子域名，只需将 <code>server_name</code> 和 <code>root</code> 替换成相应的子域名和文件夹就可以了</p><p>可以先创建一个 <code>index.html</code>  测试一下，访问 <code>blog.itswincer.com</code>  看看是否成功</p><h3 id="加密-CI-配置"><a href="#加密-CI-配置" class="headerlink" title="加密 CI 配置"></a>加密 CI 配置</h3><p>这一步可选，你也可以手动用 <code>scp</code> 命令将每次 <code>hexo g</code> 生成的静态文件上传至服务器，只不过略微麻烦。</p><p>Travis CI 的终端并不能支持用户输入密码，而 GitHub 的 Token 又无法在自己的服务器使用，故而只能采取<a href="#简化 SSH 登录">简化 SSH 登录</a>这步中类似的方法，即用私钥（即 id_rsa）去确认登录的身份，而将私钥公开至 GitHub 又是很危险的，所以我们需要将私钥加密：</p><pre><code class="bash">gem install travis        # 需要安装 gem，自备梯子travis login            # 输入 GitHub 的账户密码travis encrypt-file ~/.ssh/id_rsa --add        # 加密私钥，同时解密命令会添加至 travis.yml</code></pre><p>Travis CI 上的 known_hosts 只添加了 GitHub 下的三个域名，在使用 SSH 登录时，会提示是否添加该主机，同样因为终端无法输入，所以需现将服务器的 IP 与端口号添加至 known_hosts：</p><pre><code class="yaml">addons:  ssh_known_hosts: ××.××.××.××</code></pre><blockquote><p>这里忍不住吐槽一下 Travis CI 的加密：居然无法同时加密两个文件，而官方提供的方法是先把需要加密的文件压缩后加密，再解压。</p></blockquote><h2 id="搭建-API"><a href="#搭建-API" class="headerlink" title="搭建 API"></a>搭建 API</h2><p>Hexo 这类静态博客所需的内存其实是挺少的，只需在后台运行一个 Nginx 进程就可以了，只运行一个 Nginx 进程时用「搬瓦工」的管理面板查看发现一共内存才使用了 40M，才用了不到 10%，所以就想着可以将之前写的「一言」API 放到我的服务器上，毕竟 Heroku 在国内访问还是挺不稳定的。</p><p>之前是用 Python3 写的，后来发现 VPS 自带的 Python 版本居然是 2.7，深知其中坑的我就没打算再用 Python 了，于是就是用 Node.JS 写了一个，本地调试了一下，就扔到服务器上了。第二天早上起来一看，发现内存占用居然到了 110M，一查看原来都是 Node 的占用，其中每一个 API 请求，平均就会多占用 2M 的内存，而且这个请求所占用的内存并不会释放，这样下去怕是没两天服务器就要爆内存了。</p><p>后来我也想过解决办法，比如用 PM2 这个工具来限制运行的内存，超过就重启 Node 环境，也想过定时重启服务器，再转念一想，我是大爷诶，凭啥要我去迁就辣鸡 Node.JS 的内存管理，你不行那我换一个具有垃圾回收的语言不就好了，那就 Java？好像也不太行，毕竟服务器就那么点硬盘，JDK 和 JRE 不知道要占用我多少空间，再者说来毕竟我可是 「Java 黑」。</p><p>那么就归纳一下我的需求：「占用内存小、部署方便、有垃圾回收（不会爆内存）、<del>不要 Java</del>」，然后考虑到编译型程序比解释型程序占用的内存更小，所以也就没考虑 Ruby &amp; Python，满足这些要求的好像也只有 Golang 了。</p><p>写了那么久的动态类型语言，突然要我写静态类型语言还真是有点不适应。在网上找了个例子，自己捣鼓了一个下午，就写出来了，算是一个勉强遵循「RESTful」风格的 API，开始还有日志功能，后来想想没必要，Nginx 也可以监控端口的访问日志，就删去了。</p><p>然后在 Nginx 配置端口</p><pre><code class="nginx">server {  listen        80;  server_name    api.itswincer.com;  location / {    add_header Content-Type &#39;application/javascript&#39;;    proxy_pass http://localhost:520;  }}</code></pre><p>而且 Golang 的部署也是很方便，将 *.go 拷贝就行了。跑了几天，内存占用稳定在 10M 上下。</p><p><a href="https://github.com/WincerChan/hitokoto" target="_blank" rel="noopener">该项目</a>已托管至 GitHub。</p><h2 id="搭建-SS"><a href="#搭建-SS" class="headerlink" title="搭建 SS"></a>搭建 SS</h2><p>搬瓦工的 SS/SSR 搭建可以说是非常的方便了：</p><ol><li>先进入 KiwiVM 面板</li><li>在左侧点击 <code>Shadowsocks Server</code> 按钮</li><li>再点击 <code>install Shadowsocks Server</code> 按钮</li></ol><p>大约半分钟后，会提示已经安装完成：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530857869/blog/vps_open_mode/ss_install.png" alt="安装"></p><p>再点击 <code>Go back</code> 按钮，回到以下界面，再点击 <code>Start</code>：<img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530857945/blog/vps_open_mode/ss_sample.png" alt="配置"></p><p>SS 服务配置完成了，将以上信息填入 SS 客户端即可使用。</p><p>不过由于服务器是在美西，所以无论怎么优化（BBR），延迟都会在 160ms 以上，当然这对浏览网页看视频来说也没有什么影响。</p><blockquote><p>注意：<strong>当你使用 VPS 翻墙时，会同时计算上行、下行流量，也就是说如果翻墙使用 1G 流量，其实等于使用了 VPS 的 2G 流量</strong>。</p></blockquote><h2 id="搭建私有云笔记"><a href="#搭建私有云笔记" class="headerlink" title="搭建私有云笔记"></a>搭建私有云笔记</h2><p>我最近有在思考私有云笔记的必要性，毕竟有了博客，那云笔记的作用可能就鸡肋了一点。但我还是选择了搭建。我的想法是：博客用于存放、发布一些较正式的文章，而笔记可以休闲一点（类似作文和日记的区别）。</p><p>回到正题，目前来说，体验好的云笔记要么需要会员、要么存在诸多功能限制，而我又不想多浪费钱，那么选择一个支持多设备（其实主要是解决手机设备）的同步方案并借助私有的服务器架设自然也就是最好的解决办法了。我选择了 <a href="../bf0413ac/">Nextcloud 作为解决方案</a>，并借助他的 WebDAV 功能作为多端同步工具。</p><p>手机端笔记软件选择的是<a href="https://www.coolapk.com/apk/me.tshine.easymark" target="_blank" rel="noopener">易码</a>，支持 Markdown 语法和 WebDAV 同步，电脑端可以选择直接用浏览器访问 Nextcloud，可以在线 Markdown 编辑和预览，当然也可以选择用 Nextcloud 同步至本地文件夹，并用其它编辑器打开就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实像 Hexo 这样的静态博客框架本不需要服务器的，GitHub Pages 就提供免费的托管服务、且不限流量，但内心那点不安分因素总是撩拨着我：比如可以自定防护规则、可以搭建私有 Git 服务、可以搭建自己的 API（这个比较重点）、还能自己搭建 SS 服务，于是乎就买了一台 VPS。
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="API" scheme="https://blog.itswincer.com/tags/API/"/>
    
      <category term="VPS" scheme="https://blog.itswincer.com/tags/VPS/"/>
    
      <category term="Nginx" scheme="https://blog.itswincer.com/tags/Nginx/"/>
    
      <category term="SSH" scheme="https://blog.itswincer.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>《黑客与画家》读书笔记</title>
    <link href="https://blog.itswincer.com/posts/a6c2a51d/"/>
    <id>https://blog.itswincer.com/posts/a6c2a51d/</id>
    <published>2018-01-26T17:11:29.000Z</published>
    <updated>2017-01-31T20:02:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年年底那会，花了大概一周多时间，阅读完了《黑客与画家》这本书，收获颇丰。可惜当时确实没多少时间整理出读书笔记，期末考试结束后，回到家中，本想着有时间能好好补一下博客，结果回家之后也没有想象中的空闲，看着「搬瓦工」把每年 20$ 的套餐补货了，于是就购置了一台服务器，将博客源码从 GitHub 上转移到了自己的服务器上，还拿 Golang 重写了一下「一言」的 API（扯远了，服务器的事等以后再开一篇博客说说），还补了一部早已加入想看列表却一直没看的番——「反叛的鲁路修」（嘻嘻 😌）。</p><p>直到今天，才终于有时间能把这篇读书笔记给整理出来了，笔记是直接在 Kindle 上标注的，然后用「<a href="https://www.clippings.io/" target="_blank" rel="noopener">Clippings.io</a>」这个工具导出（为什么 Kindle 不能开发一个好用一点的笔记管理系统呢！？）。</p><p>好在 azw3 版本在 Kindle 上的体验还不错，即使有代码段排版也没有垮掉，所以决定原谅你。</p><p>（👇以下为文摘）</p><hr><ol><li><p>在一个人产生良知之前，折磨就是一种娱乐。</p></li><li><p>程序写出来是给人看的，附带能在机器上运行。（这句话的出处是在《SICP》这本书的卷首语，作者引用了）</p></li><li><p>如果有必要的话，大多数物理学家有能力拿到法国文学的博士学位，但是反过来就不行，很少存在法国文学的教授有能力拿到物理学的博士学位。</p></li><li><p>人们喜欢讨论的许多问题实际上都是很复杂的，马上说出你的想法对你并没有什么好处。</p></li><li><p>小时候，每个人都会鼓励你不断成长，变成一个心智成熟、不再耍小孩子脾气的人。但是，很少有人鼓励你继续成长，变成一个怀疑和抵制社会错误潮流的人。<br>如果自己就是潮水的一部分，怎么能看见潮流的方向呢？你只能永远保持质疑。</p></li><li><p>不服从管教，其实是黑客之所以成为优秀程序员的原因之一。</p></li><li><p>公民自由并不仅仅是社会制度的装饰品，或者一种很古老的传统。公民自由使得国家富强。</p></li><li><p>经济学里有一条拉弗曲线（Laffer curve），认为随着税率的上升，税收收入会先增加后减少。我认为政府的力量也是如此，随着对公民自由的限制不断上升，政府的力量会先增加后减小。</p></li><li><p>极权主义制度只要形成了，就很难废除。（咳咳）</p></li><li><p>一定数量的盗版对软件公司是有好处的。不管你的软件定价多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并没有任何损失。事实上，你反而赚到了，因为你的软件现在多了一个用户，市场影响力就更大了一些，而这个用户可能毕业以后就会出钱购买你的软件。</p></li><li><p>首先，管理企业其实很简单，只要记住两点就可以了：做出用户喜欢的产品，保证开支小于收入。</p></li><li><p>一个大学毕业生总是想「我需要一份工作」，别人也是这么对他说的，好像变成某个组织的成员是一件多么重要的事情。更直接的表达方式应该是「你需要去做一些人们需要的东西」。即使不加入公司，你也能做到。公司不过是一群人在一起工作，共同做出某种人们需要的东西。真正重要的是做出人们需要的东西，而不是加入某个公司。</p></li><li><p>要鼓励大家去创业。只要懂得藏富于民，国家就会变得强大。让书呆子保住他们的血汗钱，你就会无敌于天下。</p></li><li><p>财富是用工作成果衡量的，而不是用它花费的成本衡量的。如果我用牙刷油漆房屋，屋主也不会付给我额外工资的。</p></li><li><p>好设计是艰苦的设计。如果观察那些做出伟大作品的人，你会发现他们的共同点就是工作得非常艰苦。如果你工作得不艰苦，你可能正在浪费时间。</p></li><li><p>并非所有的痛苦都是有益的。世界上有有益的痛苦，也有无益的痛苦。你需要的是咬牙向前沖刺的痛苦，而不是脚被钉子扎破的痛苦。解决难题的痛苦对设计师有好处，但是对付挑剔的客户的痛苦或者对付质量低劣的建材的痛苦就是另外一回事了。</p></li><li><p>等到你逐渐对一件事产生热情的时候，就不会满足于模仿了。</p></li><li><p>「你用什么语言并不重要，重要的是你对问题是否有正确的理解。代码以外的东西才是关键。」这当然是一派胡言。各种语言简直是天差地别。</p></li><li><p>语言设计者之间的最大分歧也许就在于，有些人认为编程语言应该防止程序员干蠢事，另一些人则认为程序员应该可以用编程语言干一切他们想干的事。</p></li><li><p>允许你做某事的语言肯定不差于强迫你做某事的语言。</p></li><li><p>它们（指某些语言）的内核设计得并非很好，但是却有着无数强大的函数库，可以用来解决特定的问题。（你可以想象一辆本身性能很差的小汽车，车顶却绑着一个飞机发动机。）有一些很琐碎、很普遍的问题，程序员本来要花大量时间来解决，但是有了这些函数库以后，解决起来就变得很容易，所以这些库本身可能比核心的语言还要重要。所以，这些奇特组合的语言还是蛮有用的，一时间变得相当流行。车顶上绑着飞机发动机的小车也许真能开，只要你不尝试拐弯，可能就不会出问题。（内心 OS：我可没有针对 C++ 😏）</p></li><li><p>当我说 Java 不会成功时，我的意思是它和 Cobol 一样，进化之路已经走到了尽头。</p></li><li><p>如果摩尔定律依然成立，一百年后计算机的运行速度将是现在的 74 乘以 10 的 18 次方倍（准确地说是 73 786 976 294 838 206 464 倍）。</p></li><li><p>即使最后只是略微快了 100 万倍，也将实质性地改变编程的基本规则。如果其他条件不变，现在被认为运行速度慢的语言（即运行的效率不高）将来会有更大的发展空间。</p></li><li><p>效率低下的软件并不等于很烂的软件。一种让程序员做无用功的语言才真正称得上很烂。</p></li><li><p>自下而上的编程方法意味着要把软件分成好几层，每一层都可以充当它上面那一层的开发语言。这种方法往往会产生更小、更灵活的程序。它也是通往软件圣杯——可重用性（reusability）——的最佳路线。</p></li><li><p>罗伯特·莫里斯和我都很了解 Lisp 语言，我们相信自己的直觉，找不出任何不使用它的理由。我们知道其他人都用 C++ 或 Perl 开发软件，但是我们不觉得这说明了什么问题。如果别人用什么技术，你也用什么技术，那么你大概只能使用 Windows 了（日常黑 Windows）。</p></li><li><p>编程语言的特点之一就是它会使得大多数使用它的人满足于现状，不想改用其他语言。</p></li><li><p>如果从图灵等价（Turing-equivalent）的角度来看，所有语言都是一样强大的，但是这对程序员没有意义。</p></li><li><p>最不用担心的竞争对手就是那些要求应聘者具有 Oracle 数据库经验的公司，你永远不必担心他们。如果是招聘 C++ 或 Java 程序员的公司，对你也不会构成威胁。如果他们招聘 Perl 或 Python 程序员，就稍微有点威胁了。至少这听起来像一家技术公司，并且由黑客控制。如果我有幸见到一家招聘 Lisp 黑客的公司，就会真的感到如临大敌。</p></li><li><p>你的经理其实不关心公司是否真的能获得成功，他真正关心的是不承担决策失败的责任。</p></li><li><p>黑客欣赏的一个特点就是简洁。黑客都是懒人，他们同数学家和现代主义建筑师一样，痛恨任何冗余的东西或事情。</p></li><li><p>简洁性是静态类型语言的力所不及之处。只要计算机可以自己推断出来的事情，都应该让计算机自己去推断。举例来说，hello-world 本应该是一个很简单的程序，但是在 Java 语言中却要写上一大堆东西，这本身就差不多可以说明 Java 语言设计得有问题了。</p><pre><code class="java">public class Hello {  public static void main(String[] args) {    System.out.println(&quot;Hello, world!&quot;);  }}</code></pre><p>如果你从来没没有接触过编程，看到上面的代码可能会很奇怪，让计算机显示一句话为什么要搞得这么复杂？有意思的是，资深程序员的反应与你一样。</p></li><li><p>语言设计者应该假定他们的目标用户是一个天才，会做出各种他们无法预知的举动，而不是假定目标用户是一个笨手笨脚的傻瓜，需要别人的保护才不会伤到自己。如果用户真的是傻瓜，不管你怎么保护他，他还是会搬起石头砸自己的脚。</p></li><li><p>对黑客来说，选择编程语言的时候，还有一个因素比简洁更重要，那就是这种语言必须能够帮助自己做到想做的事。</p></li></ol><p>（👇以下为简评）</p><hr><p>这本书算是我从去年 7 月以来看完的第一本书了（《计算机程序的构造和解释》这本书太难了，看了前两章就没时间看，到还书的日期了），主要也在于作者 Paul Graham 的行文十分流畅，阮一峰的翻译也很到位，没有什么阅读障碍，还有「读至好几处都有一拍大腿，哎呀妈呀我也是这么想的啊」的想法，读完之后，思想也似乎豁然开朗了些。</p><p>关于第六章——「如何创造财富」，财富的获得是看你最终的结果，不是看你的付出（过程）。你做出了别人需要的产品，没人在乎你是做了三天还是三十天，他并不会因为你只做了三天就完成而少付给你报酬，更不会因为你是三十天完成而多给你报酬。还有关于「财富并不是固定不变的」这个理论，他给出了一个例子：你拥有一辆老爷车，你可以不去管它，也可以自己动手把它修葺一新这样的话，你就创造了财富：世界上因此多了一辆新的车，财富就变得多了一点，如果你把车卖掉，你得到的卖车款就会比以前更多，与此同时，你并没有使任何人变得更贫穷。正因为这个理由，他也建议我们多多创业，但也给我们泼了一盆「凉水」：创业的付出与回报总体上是成比例的，但是在个体上是不成比例的，不要把创业过于神话，但创业的确给了我们更多的可能。</p><p>还有就是关于编程语言的争论，作者似乎和我一样很喜欢黑 Java，认为 Java 是「进化之路已经走到了尽头」，因为编程语言并不应该限制程序员去做某些事情，即使这些事情是有害的。同时也抛出了另一个很新颖的说法：关于一百年以后，我们该使用什么样的编程语言？按照摩尔定律：预计 18 个月会将芯片的性能提高一倍，那时候电脑的运行速度将是现在的 73 786 976 294 838 206 464 倍，所以他认为现在某些因为运行速度略慢但编程起来更舒服的语言在未来反而是主流，即有更大的发展空间，同时作者似乎很推崇动态类型语言，因为写起来比静态类型语言方便、看起来也比较简洁。作者也不止一次的推崇了 Lisp，甚至不惜黑 Oracle 数据库、C++、Java（见上面第 30 条）。</p><p>最后，这本书算是 Paul Graham 的一本随笔文集，其中自然充斥着许多作者的价值观，如果这些价值观与你的价值观符合，那么你就会像「捡到宝」一样的对待这本书，反之，你会认为这本书的观点完全是和「邪教信条」一般，很庆幸，我是前者。</p><hr><p>处于马上步入社会的我啊，在迷茫的时候，不妨也多阅读几本好书。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年年底那会，花了大概一周多时间，阅读完了《黑客与画家》这本书，收获颇丰。可惜当时确实没多少时间整理出读书笔记，期末考试结束后，回到家中，本想着有时间能好好补一下博客，结果回家之后也没有想象中的空闲，看着「搬瓦工」把每年 20$ 的套餐补货了，于是就购置了一台服务器，将博客
      
    
    </summary>
    
      <category term="文字阁" scheme="https://blog.itswincer.com/categories/%E6%96%87%E5%AD%97%E9%98%81/"/>
    
    
      <category term="笔记" scheme="https://blog.itswincer.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="黑客与画家" scheme="https://blog.itswincer.com/tags/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/"/>
    
  </entry>
  
  <entry>
    <title>豆瓣电影 Top 250 数据分析</title>
    <link href="https://blog.itswincer.com/posts/7a8186a0/"/>
    <id>https://blog.itswincer.com/posts/7a8186a0/</id>
    <published>2018-01-21T10:24:29.000Z</published>
    <updated>2017-12-24T20:27:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间忙于备考，博客有段时间没更新了。其实早就有写这篇博客的想法了，原因嘛——我是比较喜欢看电影的，而且近来也对数据分析颇感兴趣，于是花了一天时间，先是爬取数据，再分析整理，数据可视化。<br><a id="more"></a></p><p>其实豆瓣对爬虫的防范算是比较高级了，即使伪造了 Cookie，还是会封禁 IP（还好我的代理 IP 多😏），甚至还会把你的帐号暂时冻结，其实要不是有一些电影词条必须登录才可见，也不用伪造 Cookie 这么麻烦。</p><h2 id="爬取"><a href="#爬取" class="headerlink" title="爬取"></a>爬取</h2><p>之前爬取都是用的正则匹配，这次首次接触了「<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">Beautiful Soup</a>」这个库，相见恨晚啊，不多说，先上代码：</p><pre><code class="python">def get_info(url):    movie = {}    proxies = {&#39;https&#39;: &quot;socks5://127.0.0.1:1080&quot;}    info = get(url, cookies=read_cookie(), proxies=proxies).text    soup = BeautifulSoup(info)    try:        # get movie name        name = soup.find(property=&#39;v:itemreviewed&#39;).get_text()        movie[&#39;name&#39;] = name.split(&#39; &#39;)[0]        # get movie year        year = soup.find(class_=&#39;year&#39;).get_text()        movie[&#39;year&#39;] = year[1:-1]        # get movie info        info = soup.find(id=&#39;info&#39;).get_text().replace(&#39; &#39;, &#39;&#39;).split(&#39;\n&#39;)        info = [x for x in info if x is not &#39;&#39;]        for item in info:            if &#39;导演:&#39; in item:                movie[&#39;director&#39;] = item[3:].split(&#39;/&#39;)            if &#39;主演:&#39; in item:                movie[&#39;actors&#39;] = item[3:].split(&#39;/&#39;)            if &#39;类型:&#39; in item:                movie[&#39;type&#39;] = item[3:].split(&#39;/&#39;)            if &#39;国家/地区:&#39; in item:                movie[&#39;region&#39;] = item[8:].split(&#39;/&#39;)            if &#39;语言:&#39; in item:                movie[&#39;language&#39;] = item[3:].split(&#39;/&#39;)            if &#39;片长:&#39; in item:                time = [                    search(r&#39;[\d]*&#39;, x).group() for x in item[3:].split(&#39;/&#39;)                ]                movie[&#39;time&#39;] = sorted(time, reverse=True)[0]        # get top250 info        movie[&#39;rank&#39;] = soup.find(class_=&#39;top250-no&#39;).get_text()        movie[&#39;number&#39;] = soup.find(property=&#39;v:votes&#39;).get_text()    except Exception as e:        print(e)    return movie</code></pre><p>其中片长取得是无删减版的片长，即不同版本中最长的。</p><p>地区、导演、语言等由于会出现多项内容，采取列表存放。</p><p><strong>以下统计数据截止至 2018/01/20</strong></p><h2 id="导演"><a href="#导演" class="headerlink" title="导演"></a>导演</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858719/blog/douban_movie_analytics/director.png" alt="电影导演统计"></p><p>其中由「宫崎骏」和「克里斯托弗·诺兰」贡献最多，均为 7 部，具体为：</p><p>宫崎骏（日本）：</p><ul><li>《千与千寻》，上映年份为「2001」，排名为 No.6</li><li>《龙猫》，上映年份为「1988」，排名为 No.17</li><li>《天空之城》，上映年份为「1986」，排名为 No.33</li><li>《哈尔的移动城堡》，上映年份为「2004」，排名为 No.45</li><li>《幽灵公主》，上映年份为「1997」，排名为 No.80</li><li>《风之谷》，上映年份为「1984」，排名为 No.106</li><li>《魔女宅急便》，上映年份为「1989」，排名为 No.189</li></ul><p>克里斯托弗·诺兰（英国）：</p><ul><li>《盗梦空间》，上映年份为「2010」，排名为 No.9</li><li>《星际穿越》，上映年份为「2014」，排名为 No.25</li><li>《蝙蝠侠：黑暗骑士》，上映年份为「2008」，排名为 No.32</li><li>《致命魔术》，上映年份为「2006」，排名为 No.61</li><li>《记忆碎片》，上映年份为「2000」，排名为 No.132</li><li>《蝙蝠侠：黑暗骑士崛起》，上映年份为「2012」，排名为 No.168</li><li>《追随》，上映年份为「1998」，排名为 No.170</li></ul><h2 id="演员"><a href="#演员" class="headerlink" title="演员"></a>演员</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858744/blog/douban_movie_analytics/actor.png" alt="电影演员统计"></p><p>其中由「张国荣」贡献最多（前三居然都是香港地区的演员），有 8 部，分别是：</p><ul><li>《霸王别姬》，导演为「陈凯歌」，上映年份为「1993」，排名为 No.2</li><li>《春光乍泄》，导演为「王家卫」，上映年份为「1997」，排名为 No.77</li><li>《射雕英雄传之东成西就》，导演为「刘镇伟」，上映年份为「1993」，排名为 No.88</li><li>《倩女幽魂》，导演为「程小东」，上映年份为「1987」，排名为 No.113</li><li>《东邪西毒》，导演为「王家卫」，上映年份为「1994」，排名为 No.131</li><li>《英雄本色》，导演为「吴宇森」，上映年份为「1986」，排名为 No.140</li><li>《纵横四海》，导演为「吴宇森」，上映年份为「1991」，排名为 No.149</li><li>《阿飞正传》，导演为「王家卫」，上映年份为「1990」，排名为 No.183</li></ul><h2 id="地区"><a href="#地区" class="headerlink" title="地区"></a>地区</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858784/blog/douban_movie_analytics/region.png" alt="电影地区统计"></p><p>其中「美国」地区一枝独秀，超过半数以上电影的制片地区均为「美国」，且远超第二名「英国」。</p><ul><li>美国：140 部</li><li>英国：34 部</li><li>日本：32 部</li><li>香港：26 部</li><li>法国：26 部</li><li>德国：20 部</li><li>中国大陆：16 部</li></ul><h2 id="片长"><a href="#片长" class="headerlink" title="片长"></a>片长</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858819/blog/douban_movie_analytics/length.png" alt="电影片长"></p><table><thead><tr><th>统计名称</th><th>数值</th></tr></thead><tbody><tr><td>中位数</td><td>118.0</td></tr><tr><td>均值</td><td>124.0</td></tr><tr><td>众数</td><td>98.0（10 次）</td></tr><tr><td>标准差</td><td>34.1</td></tr><tr><td>极差</td><td>218.0</td></tr></tbody></table><p>其中片长最长的电影为《指环王3：王者无敌》，导演是「彼得·杰克逊」，片长为 263 mins，排名是 No.30。</p><p>其中片长最短的电影为《萤火之森》，导演是「大森贵弘」，片长为 45 mins，排名是 No.150。</p><h2 id="年份"><a href="#年份" class="headerlink" title="年份"></a>年份</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858844/blog/douban_movie_analytics/years.png" alt="电影年份"></p><table><thead><tr><th>统计名称</th><th>数值</th></tr></thead><tbody><tr><td>中位数</td><td>2002.0</td></tr><tr><td>均值</td><td>1998.6</td></tr><tr><td>众数</td><td>2004（13 次）</td></tr><tr><td>标准差</td><td>15.6</td></tr><tr><td>极差</td><td>85</td></tr></tbody></table><p>其中距今最久远的电影是《城市之光》，导演是「查理·卓别林」，年份为 1931 年，排名是 No.210。</p><p>其中距今最接近的电影有 5 部，均为 2016 年上映：</p><ul><li>《疯狂动物城》，导演是「拜伦·霍华德」等，制片国家为「美国」，排名为 No.43</li><li>《看不见的客人》，导演是「奥里奥尔·保罗」，制片国家为「西班牙」，排名为 No.83</li><li>《摔跤吧！爸爸》，导演是「涅提·蒂瓦里」，制片国家为「印度」，排名为 No.104</li><li>《海边的曼彻斯特》，导演是「肯尼思·洛纳根」，制片国家为「美国」，排名为 No.151</li><li>《你的名字。》，导演是「新海诚」，制片国家为「日本」，排名为 No.245</li></ul><p>嘿嘿，没想到吧，贡献电影最多的年份并不是「Top 250」前四名中有三部的 1994 年，而是 2004 年。</p><h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858864/blog/douban_movie_analytics/grade.png" alt="电影评分统计"></p><table><thead><tr><th>统计名称</th><th>数值</th></tr></thead><tbody><tr><td>中位数</td><td>8.70</td></tr><tr><td>均值</td><td>8.78</td></tr><tr><td>众数</td><td>8.7（44 次）</td></tr><tr><td>标准差</td><td>0.27</td></tr><tr><td>极差</td><td>1.40</td></tr></tbody></table><p>其中最高分为 9.6 分，为两部电影所获得：</p><ul><li>《肖申克的救赎》，导演为「弗兰克·德拉邦特」，评分人数为 952814 人，排名为 No.1</li><li>《控方证人》，导演为「比利·怀尔德」，评分人数为 99908 人，排名为 No.41</li></ul><p>其中评分最低的电影为《疯狂的石头》，分数是 8.2 分，导演为「宁浩」，评分人数为 312083 人，排名为 No.230</p><p>可以看出豆瓣在进行「Top 250」排名时，并不是仅看评分，其中评分人数也占了很大的一部分比重，且似乎还有一些其它的因素，比如《血战钢锯岭》这部电影，评分 8.7，评分人数为 310624 人，却并没有上榜，同为评分 8.7，评分人数为 314940 的电影《看不见的客人》排名却早已进前百（No.83）。</p><p>最后，本人并非专业电影人士，无法针对以上数据提出建设性的建议，所做统计也仅仅是出于爱好，也愿自己能在闲暇时间里，多看几部电影。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间忙于备考，博客有段时间没更新了。其实早就有写这篇博客的想法了，原因嘛——我是比较喜欢看电影的，而且近来也对数据分析颇感兴趣，于是花了一天时间，先是爬取数据，再分析整理，数据可视化。&lt;br&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="豆瓣" scheme="https://blog.itswincer.com/tags/%E8%B1%86%E7%93%A3/"/>
    
      <category term="电影" scheme="https://blog.itswincer.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="数据" scheme="https://blog.itswincer.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>再见，2017</title>
    <link href="https://blog.itswincer.com/posts/5873b0c0/"/>
    <id>https://blog.itswincer.com/posts/5873b0c0/</id>
    <published>2017-12-29T10:46:06.000Z</published>
    <updated>2018-01-21T11:34:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><div id="aplayer1" class="aplayer" title="u4" author="Capo Productions" url="001RjIc40vapmG" pic="https://p1.music.126.net/f2VOlJsKhocM3DPba4SLXA==/6625657069970131.jpg?param=130y130" lrc="../../about/lrc/pure.lrc"></div><br>关于 2017 年，其实还真的有挺多想说的，也早就有想写一篇博客的想法了，差不多到今天才抽得出时间写。</p><p>前几天和朋友聊天时谈到关于今年最有成就感的一件事，我想了一会，应该是搭建了这样一个博客。<a id="more"></a><br>当初搭建博客的初衷其实很单纯：就是为了好玩，谁知从此就沉迷于此了。在之后的写博客的过程中甚至产生了一种当一个作家也还不错的想法（当然前提是我的文章还有人看😋），现在想想，与高中时期相比，我的想法是发生了一些转变（在高中时期的我是绝不可能产生这种想法的）。正如开始所说的，现在遇到点什么事就想写下来，在往年，我一直没有写年末总结的习惯。这种「创作欲」，类似作家：将自己内心的想法写成作品，实则是把自己的内心剖析给别人看。也渐渐有些明白卡尔·雅斯贝尔斯的那句「文学和科学相比，的确没什么用处，但文学最大的用处，也许就是它没有用处」的意思了。</p><hr><p>买了 kpw3 后，我很乐意培养自己的阅读习惯。大学时间其实还是比较宽松的，但我反而不能每天抽出一小时阅读时间。有时候看书没看两分钟，随便手机一个通知消息就能让我转移注意力——这也是我的缺点：当自己没有全神贯注的时候，很容易被其它的事情所吸引注意力（这也算我很迫切想改掉的一个坏习惯），也导致看了近两周才把《黑客与画家》这本书看完（书推过两天会补上）。</p><p>是太浮躁了，也太焦虑了，或许是因为到了大三，面临找工作的压力，这压力不仅体现在看书上，有时我就莫名想快些完成正在做的事情，后来多次发现快速完成的事情必然是敷衍的，而事后一旦想起这件「敷衍」的事情，会更加浮躁。其实这样并不好，道理古人都说给我们听了：「欲速则不达」，以后我会尽量放慢自己做事情的速度，投入自己的内心，问问自己真正想要的是什么。</p><hr><p>今年有过一段恋情，对我产生了一些影响，有好，也有坏，让我成长了许多，也意识到了自己的不足。是的，一段感情之后一定会让你成长的。我在这个过程中有开心、难过、有挂念一个人，甚至有些「病态」的想法——不论好坏，这些特殊的情感都是之前没有体会过的。</p><p>恋爱的时候，双方的关系一定需要去协商、磨合，这也会让你学会更好的与人沟通，同时你会发现有些问题如果脱离恋爱范围的话根本就不是问题。在一段恋情过后，我们获得的不仅仅是恋情，还有更好的、获得了成长的自己。你会更了解自己，也更了解你需要找一个什么样的人。</p><p>要有自己的生活，要坚持做自己。要学会去爱，但要先学会爱自己。</p><hr><p>接下来说说工作。</p><p>其实我很反感工作——即学校安排给你作为学生所必须学习的课程，所以这学期的课我基本没怎么去，因为去了我也不会听：我无法强迫自己去听那些完全没有兴趣的课程，那有点像是别人强迫要你去做的事情，我天生是一个「猫型人格」（即：你让我向左转，我会不由自主的向右转，同时心里还有一点歉疚），所以有些不由自主地抗拒。</p><p>在<a href="../11ab0263/">之前写的那篇文章</a>中就说到，我想更加追随自己内心的意愿去活着。具体到工作的说法就是：我想开始「不以找到工作为目的的学习」，学习自然指的是编程。</p><blockquote><p>编程这么有趣的事，竟然还有钱赚      ——by c++ 之父</p></blockquote><p>我喜欢编程，我愿意将自己的时间花费在上面做一些有趣的小程序，即使这在旁人看来对以后的工作没有什么帮助，我不想抱着太强的目的性、太多的功利心去学习，因为这样，会让学习变味。同时我也乐于看着指尖下的一串串字符到显示器上显示出成果，会有一种小小的满足感。</p><hr><p>最后，小小说一下对 2018 年的展望（这绝对不是 FLAG！）</p><ul><li>希望继续读书的习惯</li><li>希望做事情的时候更专注</li><li>希望能多吃水果、生活作息规律</li><li>希望学会使用 To-Do list（如果能有效治愈我的拖延症的话）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div id=&quot;aplayer1&quot; class=&quot;aplayer&quot; title=&quot;u4&quot; author=&quot;Capo Productions&quot; url=&quot;001RjIc40vapmG&quot; pic=&quot;https://p1.music.126.net/f2VOlJsKhocM3DPba4SLXA==/6625657069970131.jpg?param=130y130&quot; lrc=&quot;../../about/lrc/pure.lrc&quot;&gt;&lt;/div&gt;&lt;br&gt;关于 2017 年，其实还真的有挺多想说的，也早就有想写一篇博客的想法了，差不多到今天才抽得出时间写。&lt;/p&gt;
&lt;p&gt;前几天和朋友聊天时谈到关于今年最有成就感的一件事，我想了一会，应该是搭建了这样一个博客。
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="随笔" scheme="https://blog.itswincer.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="2017" scheme="https://blog.itswincer.com/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>从 GnuPG 的使用谈谈密码学</title>
    <link href="https://blog.itswincer.com/posts/4aa5d46d/"/>
    <id>https://blog.itswincer.com/posts/4aa5d46d/</id>
    <published>2017-12-11T09:26:16.000Z</published>
    <updated>2017-12-24T19:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我是一个很注重隐私的人，所以对密码学也就很感兴趣，这学期本着想进一步了解密码学的念头选了一门应用密码学的选修课（其实是为了混学分），虽说也没去过几次，但总想着这门课都快结束了总不能像没上过一样。这次借着 GnuPG（以下简称 GPG） 软件的使用也聊聊目前现代密码学中以密钥性质进行区分的两大加密方式。</p><a id="more"></a><h2 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h2><p>大概半年前，写过一个暴力破解加密压缩文件的程序，说白了就是跑字典，不断的试密码，这只能破解常用密码，一旦用户采用随机生成的密码就无从下手。我们平时所用到的压缩加密大多都是对称性加密，即我们用同一字符串对文件进行加密，又用同一字符串进行解密（此时为了保证安全，密码需越复杂越好）。</p><blockquote><p>明文 &lt;–> 密钥 &lt;–> 密文</p></blockquote><p>对称加密很方便也很快速，但是也带来了一个很大的缺点，由于加密和解密用的都是同一密钥，在传输的过程中，要求双方取得相同的密钥，这会大大降低加密的安全性（注意：这里所说的不安全不是说对称加密算法不安全，而是从密钥的获取程度来说的，即密钥知道的人越少越安全）。</p><p>在如今的互联网时代，通信双方分隔异地且素为谋面，则对称加密要求事先交换共同密钥的安全性也无法得到保障。</p><h2 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h2><p>那么为了解决对称加密的安全隐患，非对称加密诞生了。<br>与对称加密不同的是，非对称加密的加密和解密所需要的密钥是不同的，而且知道了其中一方，想推导出另一方（需要解决一个数学难题），在量子计算机时代来临之前，基本是不可能完成的。<br>因此公开其中一个密钥，并不会对密钥对的安全性有影响。<br>我们常说，公钥可以公开，私钥需要保密，但其实公钥和私钥在生成过程上，并无什么不同。并不是因为公钥公开后，解密出私钥困难，如果公开的是私钥，解密出公钥也同样困难。也就是说我们将一对密钥公开的那部分叫公钥，另一部分叫做私钥。并不是因为公钥，才能公开，私钥，就必须保密。</p><blockquote><p>明文 &lt;–> 公钥 &lt;–> 密文 &lt;–> 私钥 &lt;–> 明文</p></blockquote><p>前一段时间很火的勒索病毒就是采用的非对称加密中的 RSA-4096 加密算法。<br>想具体了解 RSA 加密原理的话，<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">点击这里</a>。<br>由于公钥加密在计算上相当复杂，导致其加密速度相对于对称加密来说慢。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>其中对称加密还有一个用处：数字签名。<br>对称加密的公钥和私钥在使用顺序上并没有什么要求，你可以用公钥加密，私钥解密，这就是非对称加密算法，同样可以用私钥加密，公钥解密，而这就成为数字签名。<br>由于私钥是发送者保存的，发送者用私钥加密后的信息，任何拥有该发送者的公钥的人都可以解密该信息。如果接收用发送者公开的公钥解开了，那么说明这个信息是确实是发送者发送的（没有被篡改，也不是伪造的）。公众也可以信赖这条信息确实来自与该用户，用户无法否认。</p><p>一般来说，不直接对消息进行签名，而是对消息的哈希值进行签名，并将签名附赠在消息一起发送。</p><p>总结一下二者的优点与缺点：</p><ul><li>对称密钥加密（使用最广泛的 AES）：加解密速度很快，强度也足够，但问题在于寻找一个安全通道让通信双方交换密钥很困难</li><li>公开密钥加密（使用最广泛的 RSA）：加解密速度很慢，但可以解决通信双方安全通道的问题</li></ul><p>故现在多将二者结合使用：需要加密的主体内容使用对称加密，对称加密的密钥使用非对称加密。</p><h2 id="GPG-教程"><a href="#GPG-教程" class="headerlink" title="GPG 教程"></a>GPG 教程</h2><p>下面说说如何使用 GPG 软件加密文件。</p><p>GPG 支持的算法有很多：</p><blockquote><p>公钥：RSA, ELG, DSA, ECDH, ECDSA, EDDSA</p><p>对称加密：IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256,</p><p>​     TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256</p><p>散列：SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224</p><p>压缩：不压缩，ZIP，ZLIB，BZIP2</p></blockquote><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>使用对称加密很简单，只需要一行就可以：</p><pre><code class="bash">gpg --cipher-algo [对称加密算法名称] -c FILENAME</code></pre><p>随后会让你输入两次密码，就会生成一个 FILENAME.gpg 的文件在同目录下。</p><p>解密：</p><pre><code class="bash">gpg -o FILENAME -d FILENAME.gpg</code></pre><p>更多参数请输入 <code>gpg -h</code> 自行查阅。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>（这里如果输入的是 <code>--gen-key</code> 的话，会省去一些步骤：自动设置密钥尺寸为 2048 位、有效期限为 2 年、注释留空）：</p><pre><code class="bash">gpg --full-generate-key</code></pre><p>回车后，出现以下文字：</p><pre><code class="bash">gpg (GnuPG) 2.2.3; Copyright (C) 2017 Free Software Foundation, Inc.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.请选择您要使用的密钥种类：   (1) RSA and RSA (default)   (2) DSA and Elgamal   (3) DSA (仅用于签名)   (4) RSA (仅用于签名)您的选择？ </code></pre><p>选择 1：</p><pre><code class="bash">RSA 密钥长度应在 1024 位与 4096 位之间。您想要用多大的密钥尺寸？(2048)</code></pre><p>选择 4096：</p><pre><code class="bash">请设定这把密钥的有效期限。         0 = 密钥永不过期      &lt;n&gt;  = 密钥在 n 天后过期      &lt;n&gt;w = 密钥在 n 周后过期      &lt;n&gt;m = 密钥在 n 月后过期      &lt;n&gt;y = 密钥在 n 年后过期密钥的有效期限是？(0) </code></pre><p>如果想设置 5 年过期，输入 5y，我这里是自己私人用，选择 0，随后会让你确认以上信息正确与否，输入 y，系统会要求你提供一下个人信息：</p><pre><code class="bash">You need a user ID to identify your key; the software constructs the user IDfrom the Real Name, Comment and Email Address in this form:    &quot;Heinrich Heine (Der Dichter) &lt;heinrichh#duesseldorf.de&gt;&quot;真实姓名：电子邮件地址：注释：</code></pre><p>注释这一栏可以留空。</p><p>随后：</p><pre><code class="bash">您选定了这个用户标识：    &quot;×××××× &lt;××@×××.com&gt;&quot;更改姓名(N)、注释(C)、电子邮件地址(E)或确定(O)/退出(Q)？</code></pre><p>输入 o，会弹框提示设置一个密码，用于保护私钥。</p><p>与此同时，系统也会提示：</p><pre><code class="bash">我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。</code></pre><p>几秒后，系统就会提示密钥已经生成。</p><h4 id="导出密钥"><a href="#导出密钥" class="headerlink" title="导出密钥"></a>导出密钥</h4><p>显示系统的私钥：</p><pre><code class="bash">gpg -K</code></pre><p>显示系统的公钥：</p><pre><code class="bash">gpg -k</code></pre><p>删除密钥：</p><pre><code class="bash">gpg --delete-keys [uid]gpg --delete-secret-keys [uid]</code></pre><p>其中 uid 可以使用邮箱代替，下同。</p><p>导出公钥：</p><pre><code class="bash">gpg -o public.key --export [uid]</code></pre><p>导出私钥：</p><pre><code class="bash">gpg -o private.key --export-secret-keys</code></pre><p>这样导出的 key 文件是二进制，不可读，加上 –armor 参数可以保存为 ASCII 码形式。</p><p>导入密钥：</p><pre><code class="bash">gpg --import [key 文件]</code></pre><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><pre><code class="bash">gpg -r [uid] -o FILENAME.gpg -e FILENAME</code></pre><p>-r 指定用户的公钥，如自己使用改为自己邮箱即可，-o 指定加密后输出文件名称。</p><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><pre><code class="bash">gpg -o FILENAME -d FILENAME.gpg</code></pre><p>会让你输入密码，即用于保护私钥的密码。</p><p>参考：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">公开密钥加密</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">GPG 入门教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我是一个很注重隐私的人，所以对密码学也就很感兴趣，这学期本着想进一步了解密码学的念头选了一门应用密码学的选修课（其实是为了混学分），虽说也没去过几次，但总想着这门课都快结束了总不能像没上过一样。这次借着 GnuPG（以下简称 GPG） 软件的使用也聊聊目前现代密码学中以密钥性质进行区分的两大加密方式。&lt;/p&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="安全" scheme="https://blog.itswincer.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="GPG" scheme="https://blog.itswincer.com/tags/GPG/"/>
    
      <category term="密码学" scheme="https://blog.itswincer.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Web 性能优化（一）——使用 localStorage</title>
    <link href="https://blog.itswincer.com/posts/a9d193c6/"/>
    <id>https://blog.itswincer.com/posts/a9d193c6/</id>
    <published>2017-11-30T15:09:34.000Z</published>
    <updated>2017-11-24T19:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="localStorage-的意义"><a href="#localStorage-的意义" class="headerlink" title="localStorage 的意义"></a>localStorage 的意义</h2><p>为了针对我的网站提供更好的浏览体验（或者说更接近原生 App 的用户体验），在之前我就已经<a href="https://itswincer.com/posts/a0df572f/" target="_blank" rel="noopener">开启了 Server Worker 技术</a>，针对离线或者网速慢的情况下改善用户体验。但只有少数几个浏览器支持 （Chrome、Firefox、Opera），对目前手机端用户数最多的 QQ 浏览器、UC 浏览器却没有支持，也就是说该方法针对 QQ 浏览器和 UC 浏览器并没有什么实际优化。</p><a id="more"></a><p>而且对于 Server Worker，它并不能减少你的 HTTP 连接数量，只是拦截你的请求，减少 Stalled、Request sent 和 TTFB 的时间，见下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530845454/blog/web_optimization1/contrast.png" alt="左边从 SW 加载，右边正常加载" title="左边从 SW 加载，右边正常加载"></p><p>针对以上两个问题，本博客采用另一种 HTML5 新技术 —— local Storage。</p><h2 id="localStorage-简介"><a href="#localStorage-简介" class="headerlink" title="localStorage 简介"></a>localStorage 简介</h2><p>localStorage 是在 HTML5 中新引进的一项存储技术，（如果不被清除）存储没有时间限制，但是有大小限制，一般对于每个域名是 5MB，对于存储一些纯字符串脚本，足够了。且目前所有主流浏览器均支持此项技术。</p><p>但是需要注意，SW 是可以将所有的 HTTP 请求全部拦截，无论服务器的 Response Headers 中的 Content-Type 是什么类型都可以拦截从本地加载。而 localStorage 仅能存储静态资源（JS/CSS）。</p><p>而存储在 localStorage 的中的静态资源所带来的优点就在于再次加载时不需要发起 HTTP 请求（Queueing、Stalled、Request sent、TTFB、Content Download 这些都不需要），这可以大大改善不支持 SW 技术的浏览器在访问我网站时的浏览体验。</p><h2 id="本博客的实践"><a href="#本博客的实践" class="headerlink" title="本博客的实践"></a>本博客的实践</h2><p>本博客采用的是 <a href="https://github.com/addyosmani/basket.js/" target="_blank" rel="noopener">basket.js</a> 方案，将 js 和 css 存储在 localStorage 中，利用 localStorage 的特性，减少 HTTP 连接的次数，以达到改善页面加载体验的目的。</p><p>为了避免每次刷新页面 main.css 加载先后页面出现抖动的问题，默认不将 main.css 放入 localStorage 中存储。</p><p>另一个问题是 NexT 在设计之初就很依赖于 js（会加载大量的 js 文件），而这些 js 文件的加载顺序是有要求的，jquery 必须优先被加载，否则就会出现奇怪的 bug，好在 basket.js 提供了控制加载先后顺序的方案。</p><h2 id="危险性"><a href="#危险性" class="headerlink" title="危险性"></a>危险性</h2><p>在<a href="https://www.zhihu.com/question/28467444" target="_blank" rel="noopener">这篇知乎回答</a>中，很详细的列出了 localStorage 的优点和缺点。</p><p>其中最危险的是网站出现 xss 漏洞，就会被人利用将恶意代码注入到 localStorage 中，导致即便修复了 xss 漏洞存储的代码依然是被篡改的。</p><p>好在 basket.js 可以提供将 localStorage 中的代码重新从网络加载的问题。具体见<a href="https://addyosmani.com/basket.js/" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;localStorage-的意义&quot;&gt;&lt;a href=&quot;#localStorage-的意义&quot; class=&quot;headerlink&quot; title=&quot;localStorage 的意义&quot;&gt;&lt;/a&gt;localStorage 的意义&lt;/h2&gt;&lt;p&gt;为了针对我的网站提供更好的浏览体验（或者说更接近原生 App 的用户体验），在之前我就已经&lt;a href=&quot;https://itswincer.com/posts/a0df572f/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启了 Server Worker 技术&lt;/a&gt;，针对离线或者网速慢的情况下改善用户体验。但只有少数几个浏览器支持 （Chrome、Firefox、Opera），对目前手机端用户数最多的 QQ 浏览器、UC 浏览器却没有支持，也就是说该方法针对 QQ 浏览器和 UC 浏览器并没有什么实际优化。&lt;/p&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="优化" scheme="https://blog.itswincer.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="localStorage" scheme="https://blog.itswincer.com/tags/localStorage/"/>
    
      <category term="Web" scheme="https://blog.itswincer.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>这盛世可如你所愿？</title>
    <link href="https://blog.itswincer.com/posts/d67271d8/"/>
    <id>https://blog.itswincer.com/posts/d67271d8/</id>
    <published>2017-11-24T14:10:04.000Z</published>
    <updated>2018-07-06T15:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt(pwd, onError) {console.log("in doDecrypt");var txt = document.getElementById("enc_content").innerHTML;var plantext;try {  var bytes = CryptoJS.AES.decrypt(txt, pwd);plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById("enc_content").innerHTML = plaintext;document.getElementById("enc_content").style.display = "block";   document.getElementById("enc_passwd").style.display = "none";}</script><div id="enc_content" style="display:none">U2FsdGVkX19dieyDqNGXG6XH7fF1eRDKa0WUkCf5yf2g3uauQFLysFpqOx44CYErgy0JFdnN87C973MyUYj+LctBdyIWkR+pciyoUmnpcw/EYYArAEq3JhVeI1MONfF/aaF9ikvV0m7eMd5GhLTIUwvq6Ulk01HqtLdprpDKZXBw8f5kjmbCria2CX5i1wRe+N5mHpzeKnqbfrXSS4Xu5dULGZKRe0zsWMODzLgKLj0Byf58JJQqQRmdC3B5zjvpR+kSO1s0Cw6myLPz5ATeuB91W3cBa8zzXcxMUT0XuFyO+vTlCxMQd6zfJBUFrezbEZlBqMqS6R2CCvl/fS/Fg/mSPawIKQSCTf2WsxYiLtKvPlqbz2lpqRHuqJyvMt967lvZMvVcXeu/5xGBQ/Ex/+JZfuSnSfu0IRkztEMjI3QDTJcMtUbKqc6rk3O/SLzic89Gnjl+VrhI/86cVefCQtgcDLjK+KOKp3NqXSCrn6ilTyRcfsE8hD35WYtRamJZNiCL2arZfKf/AoLRQvLu6iA3qmFDysgt2YXmye6Cde92QADY5ei5ByDhkUsxgLAQHHp7XGcK2m6k0Vnyu6+4ya6Nj1NotqxqS/5+p1K01aVqq2mUbp9oklZhHgl9YAu6M2EfFx7YJtk94ETywk00sdPAMjQcptFZGP/M5vjOJ3nBy4myRrOhiZvKxKPnKXRUF9v2zPKhva8WctI+HFXOf+4Nd8L7ghL/1Eq958d8nh1HF1asWMbHM6nZoSuwzLnglELyTgDsm/zJRmoXTVPylsbUdvAlmgJ3j3PsXlFmgf727qnx1IIOOnCYiNy8RjRfuk5u7p/0nFQYgNhXIEoWWh+B1dTEo1My+IhGCerNKrYaKv2+yBSaR2jOGnoUyTTyApTUH0meeAhCVI50urYUqKRxv2jLthwvzdxrhsaKnPZvT/ctvVGQGQoPgSQ5e25E62uMhVOubhY80SgNjMqGJkJCft25sksz/zkVORsgArG22atgkKo4v0fhvvQ5CT3vsS8OTLyCivvw/hyOAe4ttIYbPJLhrkTfRw+/91EM7wRK7Yysxu9G7kHZDw5mpXlmE+RqBf4BH7YQqOCZi0BqEPPy42FMdP08/paExctmbIFxbnJkxAERUxdTNWHqrEWJ2mGcZmq/TbozDkLYRNG3nDh8OrTrfbDw7/6gmPDOPOTUQOLxaJICWchG1lgoABzdqkguwwOVP1vac9n0qAOW0dDJeK7QIuCtHIcjfJKZT4Io7L6IRKaMusTMLKIEsXZIa3CHJr3CEqo+Zf8MyFv5xKpzokHMdbiZB43mE3vJat02TCLwGXmZnfm6i9tySIx0bl2IBAZLPhAMj3oDi0oInEJpk02BjVUyPtuNWMHYJEGkx2eVoF+921uNxdqQNJ9JjaREJ3pEgmHGI0xFBQptSJCDV5+uny+YNCbqWIiijJnLD/jwImZ0YxYk7Cy4veX/qF3FHCq5K1KvKbxIa1wCb2Xws0+/N7Dydq52wyg0gznE7yVdPfrescLH1KouzZTYzrhgfNGTGdlP9MRZXbwLio76N6AJZCRnxSdGlsVu/OCcWzuAlqYRZ1dbT8d8CdMYIa3H3c/7mjT05Ni5VgyMc4F9g+QUmxIqdSqa1FUd47+fnOazl94Ybv2+llqH1wtbCPMmbYxHv2tnO4hiv1bofMLPY5EZtUfCrvL6iGM37pAJt0Vi9G/hoAgjdGy76kgq36KDhRZAqsuQAPawMwh6vc94R8onZmRqY11AJwPoSeV4GR49txtJGIhNXpnU+sdRo7EfSPW12BHHmUFtxsFfcZ/Caf/nk7i1yWuKHIVhBwPsOejROaHhGtmtk0Bk+gXHWRwN5tNqliQm76MRrj+FtbcvCYfLqKW/1z9BZYmR6BhuZ7kYbLwdg9F/Vqg4jKjmudaMbqTVih2aJ63uty/Py31loDA4kCId0VbWVc7Sa18NT+Jje6c7tF4kVK4FjQRJxZbzU2tkVPmz/c10W3sY2TC9VFzXPtiP9zBstj8Xb0a2IM/VEBKWHqXeKqqsjuy6BK4OwSnwwSut6wd2xHoB/JuImfZFZqBKV/leDBh6ASLpPY+UYSmze8wWHwlbVW9jLOIn5RbpgANZNOuaojuwhDi1t5p4DvKG0/k9eO21dPg6f2WAkqVMpxer1FGAw48l8ajCN9M65rpkwQ9SjQrz08J8uwpBKkN5BSYs9Uf2DKt5uUab8LnIkQrObXZshZ5gNkCHVz9tHnRnr6voxEvE+oT2ikqdyR8oZmXq4NFA/VOXXERAjRpl2J7UTdujlIaH7V5wDpIMV7x22WW9a7ER4arSsAFRJ24QRt1gMqoDijveJbhb/bcM9NyMN1VP1Z0yKnyDZehTlEeyXHVqDEe8OGj/d/fN01+c05O4C4FxexilxgYJD4E5hF/UB7aCJ9qf6eZ8ymeObdS05TO8RhXlJeEDwH9RT4Mz1Yu8tDls6IaXJ/+DjIdqLGeSH5p16o1kkoEJ8BkulTfqSvHTxtqBo3jk7uHaviRV0cVgROb4tjJs1M7FTM1EFJw0L4xlY6iZAh6ucD6Rfpr1EGZU6Lox3Z2nOSQJa90GgHMgv47/HhrSK3Pt1tKifpI3yNHmoO53u8qs9n9FVSkyXMH8uDSbDD5eHv6gTPCJy2vm+RAW2mSDTARHh5JdDOf8ZN2D42rxDnaFtaVNHjqwbZikPg0c726lb7GeNgBCI4WFaPecP8Ka8iJyF8TPeE35IHK6qGk9SCSbe6JvEO8HbYOg83hb31SOTagHFsiZuU4UCizKPs691ZbdK/n9iHIUN2/f2VRlDbnS+bARdIPsGIjsBSAKHqJUzlVJzt1Y+PDrvaFv3US+EbfYbjJcspz2LDl6vmvOoOTEioFnRVMvH1h+d3F2z9sv/7//lNhfltmqa4mdCM/Wt2dPmgRBBYbO0IX2Nv0tAOp6KZaVa0bY89SXZJXthF3jm2yoVal3cf9OYhBlFC7WMGd8fTWZMmBehPX3nkOO4mKx0+TbJIb4KOhNb/2wJFs1L1p+lSQdq+fU35BG50moLnrNcXRvhUaxdCwkHNu89qoPePG1tapcFsfl0Q3SCWJfNR0mtd14Xnf5KII6RofuCErNc77+MBv23wAbSOweiR9WY7h9rx+GmaqO3RCQO8d/L+zMOnMqYAhNI0Ii3ofEK/uZA+WFg7o+8ehfDhMiHI4hQ3vHt3+Mwiug3aweuu5syp+u1p+2F93ww7+zH6qCm+bl5OLanjyTxIjGyi80DEmX1zldS1+j64fDKwtxtbF1zBL3rUlqFtV4sV92SP+oRfYzFRQB6V1HNUw2lp8U0kX2wu8fHvEa2ilVhJsqIUH7VTHk2TiOlMJSbdx1QTjAjRR0mex2GZRjYOAhovW/qQaj3bBfJciPTYI06C9NayCoY7sxW6ZJOcM+FkuED1NeF3uO7PzXiIAjacLWVGwhLj1UlFrotCDBqH8wlc34h8bxjauX4MghIWiKK1OU1CLU93cJYMPGsWgmY97RVJ4DrUYJi9eW/l/17r/ndHDwt4HQpyopnVA8gRMAYdQP4vw6ySEbUs9WVJpyh8OxObUm+cqo3bpl0xFpyOI8FHn+GFu0whiUp9DU7/e+/M/DTzNT+I9ZkexW9HmXr9aeb1EMCQhKitnZusq6i7rbX7eXc8ZJn+AqUPERZg3QxXvfyHbZgHa7pqamv4g6oKZ0FcF/EEfLmBmTnf1r8hJmuARQ8E/8h/7a7TamsdKuXA8NTrbc9az2t2eWXWzWwdBHLL9UvvsPnSKqoHmthj5YrSIxQvsWLQ2n+pp4MGv/WI1DDbarlfE16bXC4razXyA1WMCGR5UljOinB29chTaOh1uUbvNpVxw3Oh87ssS3zzmQyu+acgOhzfZat5cflHk3fqhFUxuLouv/RxgeccJGWbcS3sqUck1JECt4kFMLDiu7w3Ifhg1XdvAVTPATqnTVa5THLd7MFozXXnJDAMaWnGmBHzarh0mgEErv6FFe6jL30mAtqJuU3M5KCbSSpiZoLnBy53AC8TgMvTs/MKtH0XBYMpA6yaoZh+d5hMIrDucnYy3UAnY/sdJlkyhJY8YPqSL7HqDl4GfayVz1tyS1p4CR0LGNw2gwcz7aFUZ3XvRsVXaS+aBbYkjbfOEfmiSO1EPaCFGd1okVuRbdDvMXu23lEzHdheI3aqupY2oQKsUjWtviTRTujo6qxbSsGWxZ1L64V1gcmiiq0/9XE9ZOjaaZW0qZmkIIQ1tN9G0x7Nx6Bfj+UZ0VIlcrsxdt6bUAgwnp1e/xRvgL0vdc/YVOyf0SpOb/SLVEMWsxNwZ/TWfOpRdN4QaTZho9DqwCDPdH576iGca+BXScnfFT8ioIUO+775dlgEuICGOJZAXYPyAVEZsYA4Y456wPcvkmpuCuvYKMSEwecXbLxfsIlKZ9HdvlCRaW43St5jdET5HmhpvgxyYHnqI6/Sqxov1P7kbUTK7gjOIBUaxiVamc1eI5CCRTlQT0kRy4t7pdwVqWgSvYtoIFtQEykf27yzh3ab/xgSalFbxIMhOr0PY58BMBwzLBjQImxRzpSF1vh0S2JeG5pHr6xZsQAXDnriCrt8pZIReVxPS6GgLFCdUkO4IU6TstTA133s8828K/qC1ZXZUDzTNxLmOv9CPsUvYiVO5DYjEzC9fcAXUybhnwy0fGa6atx58E1HknVr7tbRL7rKPRQI4=</div><div id="enc_passwd"> <div class="encrypt"> <script> var onError = function(error) { $("#enc_error")[0].innerHTML = "密码错误！"; }; function decrypt() { var passwd = $("#enc_passwd input")[0].value; console.log(passwd); doDecrypt(passwd, onError); } function EnterPress(e){ var e = window.event || e; if (e.keyCode == 13){ decrypt(); } } </script> <input type="text" onkeydown="EnterPress" onkeypress="EnterPress(event)" style="/* border-radius: 10px; */border-style: groove;/* border: 0px; */border-bottom: 2px solid #0097a7; /* 下划线效果 */border-top:0px;border-left:0px;border-right:0px;height: 30px;width: 61.8%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;background: #61616;padding-left: 5px" placeholder="输入密码后请按回车"> <div id="enc_error" style=" display: inline-block; color: #d84527; font: large; "> </div> </div> </div>]]></content>
    
    <summary type="html">
    
      我曾听说住在罗生门的恶鬼，因为害怕人性的残忍而逃走。——《罗生门》 ——谨以此文献给十九大之后的「太平盛世」。
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="政治" scheme="https://blog.itswincer.com/tags/%E6%94%BF%E6%B2%BB/"/>
    
      <category term="国情" scheme="https://blog.itswincer.com/tags/%E5%9B%BD%E6%83%85/"/>
    
      <category term="严肃向" scheme="https://blog.itswincer.com/tags/%E4%B8%A5%E8%82%83%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Poker 机械键盘开箱与简评</title>
    <link href="https://blog.itswincer.com/posts/72474942/"/>
    <id>https://blog.itswincer.com/posts/72474942/</id>
    <published>2017-11-02T13:56:40.000Z</published>
    <updated>2017-11-23T19:38:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一入外设深似海，从此钱财是路人。</p></blockquote><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>第一次知道外设这个概念，是在高中的时候，在网上偶然逛到机械键盘贴吧，只是当时忙于准备高考，而外设又价格不菲，于是念头便搁置了。</p><p>后来上了大学，买了笔记本，敲着笔记本自带的键盘「 shit 」一般的手感，才想到我应该买一把机械键盘了。于是就在网上找，看到一个段子说：</p><p>年轻人千万别碰哪些东西？</p><ol><li>毒品</li><li>游戏显卡</li><li>Hi-Fi 耳机</li><li>固态硬盘</li><li>机械键盘</li><li>Steam Origin Uplay</li><li>. . .</li></ol><a id="more"></a><p>当时大一，看到这个段子就笑了一笑，面对从一百多到一千多价位不等的机械键盘，还是比较理智的，听人说凯华轴的手感也是最接近 Cherry 轴的，于是就买了贼鸥 87，用了快两年，这期间：鼠标换了两个，耳机也买了两个，键盘却一直在用这一个，最近有几个键不灵了，正好趁着双十一，想着干脆换一把新的。心中对 Poker 那独特的键位种草已久，可惜京东没有 Poker II 的红轴版本，于是便入手了一代。</p><h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><p>不愧是「二手东」，这饱经沧桑的包装盒：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844580/blog/poker_unpacking/packaging.jpg" alt="Poker 外包装" title="Poker 外包装"></p><p>关于包装盒，去拿快递的时候还发生了一个小插曲：当时京东的人问我手机尾号，我告诉了她，然后又问我是什么东西，我说是一把键盘，然后他就去找，找了半天，没找到，然后就问另一个人，说：“尾号是 6 的快件都在这里了吧，怎么没有键盘啊？”，然后转头问我：“键盘应该是挺大的吧？”，我说：“不，不大，挺短的”，然后她又去找小一点的包裹，结果一找就找到了。</p><p>回到寝室，迫不及待的拆开了包装：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844624/blog/poker_unpacking/package_contents.jpg" alt="Poker 包装内容" title="Poker 包装内容"></p><p>这便是全家福了，包含：键盘本体、USB 连接线、RGB 的大键键帽、说明书、拔键器。</p><p>其中连接线带有屏蔽磁环，做工也算精良。</p><h2 id="60"><a href="#60" class="headerlink" title="60%"></a>60%</h2><p>Poker 这一系列，最大的特点应当就是 60% 尺寸的设计了，准确来说是 61 键。相对于普通 87 键的键盘，尺寸更加玲珑小巧，省去了方向键和功能键，改为用 <code>FN</code> 的组合键来实现相应功能。方向键是用 <code>Fn</code> + WASD 来实现，不过，对于用 Spacemacs 的我来说，没啥影响，哈哈。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844657/blog/poker_unpacking/ontology.jpg" alt="键盘本体" title="键盘本体"></p><p>真正拆开的时候才发现 60% 尺寸带来的冲击有多么大。</p><p>说到组合键，<code>Fn</code> 与组合键的功能在侧刻上都已标注：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844715/blog/poker_unpacking/side_engraved.jpg" alt="Poker 的侧刻" title="Poker 的侧刻"></p><p><code>Fn</code> 与数字键组合就是 F1~F12。<code>Fn</code> + N、M、&lt; 分别是音量 -、+、静音等。</p><h2 id="轴和键帽"><a href="#轴和键帽" class="headerlink" title="轴和键帽"></a>轴和键帽</h2><p>说道机械键盘的核心，应当就是轴体和键帽了。</p><h3 id="轴体"><a href="#轴体" class="headerlink" title="轴体"></a>轴体</h3><p>轴体方面，采用的是 Cherry 原厂轴体，大键也是卫星轴设计。手感嘛，自然是没话说了。我这里购买的是红轴的版本，毕竟用了两年，还是红轴最为顺手。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844769/blog/poker_unpacking/cherry_axis.jpg" alt="Cherry 红轴" title="Cherry 红轴"></p><h3 id="键帽"><a href="#键帽" class="headerlink" title="键帽"></a>键帽</h3><p>键帽采用的是 PBT 材质，对于 ABS 来说，PBT 的好处就是绝不会打油。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844798/blog/poker_unpacking/hand_rest.jpg" alt="键盘 + 手托" title="键盘 + 手托"></p><p>而且这款 PBT 键帽比我之前在网上购入的 PBT 键帽手感要更胜一筹，对着光看起来还闪着微弱的光，挺有意思。</p><p>在上图键 F、G、H 的侧面，可以看到有三个数字，分别是 15ms、0.1s、0.5s，这是允许用户调整按下键帽时的响应速度。这一点也是比较新奇。</p><h2 id="背部"><a href="#背部" class="headerlink" title="背部"></a>背部</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844838/blog/poker_unpacking/front.jpg" alt="正面&#39;遗照&#39;" title="正面&#39;遗照&#39;"></p><p>相对与小巧玲珑的正面来说，背部就没有那么精致了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844860/blog/poker_unpacking/back.jpg" alt="键盘背部" title="键盘背部"></p><p>四周是四个黑色的防滑垫，没有撑脚，可能是为了缩减体积来作出的取舍（当然键盘也设计成了前高后低的人体工学形状），防滑垫对我来说用处不大，因为我是把键盘放在鼠标垫上使用的。</p><p>中间那块金属铭牌上刻着一句英文：「<strong>The keyboard to cheer you up</strong>」（用这把键盘让你高兴起来！）</p><p>可能会注意到在底部的右侧有四个很小的指拨开关，作用分别是：</p><ul><li>开关 1：CAP = 左 WIN；CAP 灯 = 左 WIN 灯</li><li>开关 2：右 CTRL = `~</li><li>开关 3：左 WIN = 左 FN</li><li>开关 4：写保护键盘</li></ul><h2 id="编程功能"><a href="#编程功能" class="headerlink" title="编程功能"></a>编程功能</h2><p>这一功能也算是 Poker 的特色了，目前还不是很了解，先放一放，过几天等了解了再补上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>换上附赠的 RGB 键帽后，白色素雅的 Poker 顿时骚了起来，哈哈。</p><p>由于是 mini 键盘，我的手托也就不那么合适（长了一截，无关紧要）。</p><p>一把 60% 键盘，精简了多余的按键和尺寸，为便携带来了许多好处（要是再赠送一个保护套就更完美了）。做工上乘，手感尚佳，不过大键的手感稍肉，Cherry 原厂轴加上 PBT 键帽，算的是 IKBC 的良心之作，值得入手。（怎么感觉写成了软文 23333</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一入外设深似海，从此钱财是路人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;初识&quot;&gt;&lt;a href=&quot;#初识&quot; class=&quot;headerlink&quot; title=&quot;初识&quot;&gt;&lt;/a&gt;初识&lt;/h2&gt;&lt;p&gt;第一次知道外设这个概念，是在高中的时候，在网上偶然逛到机械键盘贴吧，只是当时忙于准备高考，而外设又价格不菲，于是念头便搁置了。&lt;/p&gt;
&lt;p&gt;后来上了大学，买了笔记本，敲着笔记本自带的键盘「 shit 」一般的手感，才想到我应该买一把机械键盘了。于是就在网上找，看到一个段子说：&lt;/p&gt;
&lt;p&gt;年轻人千万别碰哪些东西？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;毒品&lt;/li&gt;
&lt;li&gt;游戏显卡&lt;/li&gt;
&lt;li&gt;Hi-Fi 耳机&lt;/li&gt;
&lt;li&gt;固态硬盘&lt;/li&gt;
&lt;li&gt;机械键盘&lt;/li&gt;
&lt;li&gt;Steam Origin Uplay&lt;/li&gt;
&lt;li&gt;. . .&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="开箱" scheme="https://blog.itswincer.com/tags/%E5%BC%80%E7%AE%B1/"/>
    
      <category term="键盘" scheme="https://blog.itswincer.com/tags/%E9%94%AE%E7%9B%98/"/>
    
      <category term="评测" scheme="https://blog.itswincer.com/tags/%E8%AF%84%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>构建一言 API 踩坑记录</title>
    <link href="https://blog.itswincer.com/posts/f6e1eb2a/"/>
    <id>https://blog.itswincer.com/posts/f6e1eb2a/</id>
    <published>2017-10-30T10:44:41.000Z</published>
    <updated>2017-12-24T20:06:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最初是在手机上一个叫「一言」的 App 接触到 Hitokoto，一见倾心啊。之前我看书时遇到写的不错的句子就喜欢摘录下来，在有自己的博客之后，本想是单独写一篇博文来存放，后来分析了 NexT 的布局后，就想到在侧栏底部可以加上一个单独的模块。</p><p>最开始，是使用别人的 API，后来觉得不太好，有诸多限制，而我又没有主机，于是就自己用 Javascript 写了一个本地的脚本。后来发现这样也不太好，因为本地的脚本每次加载势必要加载存放 Hitokoto 的 JSON 文件一次，当记录越来越多时，会消耗不必要的资源。毕竟每次只需要加载一条。<br><a id="more"></a></p><h2 id="获取一言"><a href="#获取一言" class="headerlink" title="获取一言"></a>获取一言</h2><p>最开始准备构建的时候，就遇到了一个问题：一言的数据库去哪里找。我翻便了 Google，基本都是提供 API 的，并不会将完整的数据库给你。这想想也正常，都把数据库给你了，那谁还用你的 API 呢。</p><p>我就花了一下午，写了一个爬虫，对准了几个提供 API 的网站，开始爬去数据。但是由于 API 产生的数据是随机的，难免会有重复。所以爬取之后又要查重，着实花费了我不少时间。</p><p>整个过程大概花了一天多，做成了一个 JSON 格式的文件，然后用 JS 导入成为数组，再随机访问数组的某一项，这便是最初“本地版”的「一言」了。</p><h2 id="转化数据库"><a href="#转化数据库" class="headerlink" title="转化数据库"></a>转化数据库</h2><p>先前已经说过，一旦数据多了起来。那么数组的访问和加载都是问题，而访问慢的问题可以用数据库来解决。而这学期正好在学数据库这门课，于是便花了点时间将 JSON 格式的数据转化成 sqlite 数据库。JSON 格式的数据有需要的只有 3 项，分别是 ID（用以标识每个 Hitokoto）、HITOKOTO（每个 Hitokoto 的内容）、SOURCE（每个 Hitokoto 的出处）。知道了这些，转化的代码就呼之欲出了：</p><pre><code class="python">import jsonimport sqlite3JSON_FILE = &quot;hitodb.json&quot;DB_FILE = &quot;HITODB.db&quot;conn = sqlite3.connect(DB_FILE)with open(JSON_FILE, &#39;r&#39;) as load_f:    data = json.load(load_f)    for line in data:        print(int(line[&quot;id&quot;]), line[&quot;hitokoto&quot;], line[&quot;from&quot;])        conn.execute(            &#39;INSERT INTO HITOKOTO (ID, HITO, SOURCE) VALUES ({a}, \&#39;{b}\&#39;, \&#39;{c}\&#39;)&#39;.            format(a=line[&#39;id&#39;], b=line[&#39;hitokoto&#39;], c=line[&#39;from&#39;]))        conn.commit()print(&#39;Successfully&#39;)conn.close()</code></pre><p>截至至本文发布，该「一言」数据库共收录了 880 条记录，以后我还会陆续添加。</p><h2 id="生成-API"><a href="#生成-API" class="headerlink" title="生成 API"></a>生成 API</h2><p>有了数据库，自然要构建一个 API，这里选用的是 Flask 框架提供的接口。</p><p>首先你需要安装 Flask，而 Python 是自带 sqlite3 模块的。直接上代码：</p><pre><code class="python">import sqlite3from flask import Flask, jsonifyapp = Flask(__name__)@app.route(&#39;/&#39;)def index():    return &#39;Hello World!&#39;@app.route(&#39;/api/&#39;)def get_hito():    conn = sqlite3.connect(&#39;HITODB.db&#39;)    hito = conn.execute(        &#39;select * from hitokoto order by random() limit 1&#39;).fetchone()    hitokoto = &quot;{} ——「{}」&quot;.format(hito[1], hito[2])    return &#39;function hitokoto() { &#39; + &#39;document.write(\&#39;{}\&#39;);&#39;.format(        hitokoto) + &#39;}&#39;@app.route(&#39;/api/json/&#39;)def get_json():    conn = sqlite3.connect(&#39;HITODB.db&#39;)    hito = conn.execute(        &#39;select * from hitokoto order by random() limit 1&#39;).fetchone()    hitokoto = {}    hitokoto[&#39;id&#39;] = hito[0]    hitokoto[&#39;hito&#39;] = hito[1]    hitokoto[&#39;source&#39;] = hito[2]    return jsonify(hitokoto)if __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;, debug=True)</code></pre><p>保存为 <code>run.py</code>。然后运行，打开 <code>http://0.0.0.0/api/</code> 如果没有意外的话，应当是成功了。接下来就是部署了。</p><h2 id="部署至-Heroku"><a href="#部署至-Heroku" class="headerlink" title="部署至 Heroku"></a>部署至 Heroku</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>一开始担心是没有主机，后来才知道有「<a href="https://dashboard.heroku.com/" target="_blank" rel="noopener">Heroku</a>」这个造福大众的云平台服务。</p><p>首先你需要安装 <a href="https://toolbelt.heroku.com/" target="_blank" rel="noopener">Heroku 客户端工具</a>，安装完成后，输入以下命令来验证安装是否成功：</p><pre><code class="bash">$ heroku --version</code></pre><p>安装成功后，在本地命令行登录 Heroku：</p><pre><code class="bash">$ heroku login</code></pre><p>然后输入你的帐号和密码即可</p><h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>可以在<a href="https://dashboard.heroku.com/apps" target="_blank" rel="noopener">网页端创建</a>，也可以在命令行创建：</p><pre><code class="bash">$ heroku create wincer-hito</code></pre><p>这里或许会提示你名字已经被使用了，换一个就好。接下来要初始化本地和远程代码库。</p><pre><code class="bash">$ mkdir hitokoto                    # 创建本地代码仓库$ cd hitokoto                        # 切换至本地仓库目录$ git init                            # 初始化本地仓库$ heroku git:remote -a wincer-hito    # 链接到远程仓库</code></pre><h3 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><p>除了代码和数据库外，两个必要的文件：<code>requirements.txt</code> 部署应用时，远程环境会自动安装 <code>requirements.txt</code> 文件中列出的依赖。我们 <code>requirements.txt</code> 文件内容如下：</p><pre><code class="python">Flask==0.12.2gunicorn==19.4.5</code></pre><p>接下来，我们如何告诉服务器如何运行这个文件呢？就要通过 <code>Procfile</code> 文件了。</p><pre><code>web: gunicorn run:app</code></pre><p>以上就是 <code>Procfile</code> 的内容。</p><p>另根据习惯，可自行添加对该项目的描述。</p><p>接下来就是激动人心的提交了：</p><pre><code class="bash">$ git add .$ git commit -m &quot;Init commit&quot;$ git push heroku master</code></pre><p>打开 <a href="https://wincer-hito.herokuapp.com/api/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/</a> 看看效果吧！</p><h3 id="升级应用"><a href="#升级应用" class="headerlink" title="升级应用"></a>升级应用</h3><p>升级程序的时候，在所有的改动提交后，建议按照如下步骤升级：</p><pre><code class="bash">$ heroku maintenance:on$ git push heroku master$ heroku run python run.py deploy        # run.py改成自己的文件名$ heroku restart$ heroku maintenance:off</code></pre><h2 id="使用-API"><a href="#使用-API" class="headerlink" title="使用 API"></a>使用 API</h2><p>数据获取：</p><ul><li>请求地址：<a href="https://wincer-hito.herokuapp.com/api/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/</a></li><li>请求方式：GET</li><li>返回函数名 hitokoto 的 js 脚本，本质为 document.write 函数的脚本</li><li>如果需要 json 格式的数据：<a href="https://wincer-hito.herokuapp.com/api/json/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/json/</a></li><li>如果仅需要 hitokoto 主体：<a href="https://wincer-hito.herokuapp.com/api/main/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/main/</a></li></ul><p>在你想使用「一言」的地方插入以下代码：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;https://wincer-hito.herokuapp.com/api/&quot;&gt;&lt;/script&gt;&lt;script&gt;hitokoto();&lt;/script&gt;</code></pre><p>演示效果看侧栏。</p><p>注：由于是 Heroku 的主机是在美国，所以该 API 延迟可能会有一点高。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最初是在手机上一个叫「一言」的 App 接触到 Hitokoto，一见倾心啊。之前我看书时遇到写的不错的句子就喜欢摘录下来，在有自己的博客之后，本想是单独写一篇博文来存放，后来分析了 NexT 的布局后，就想到在侧栏底部可以加上一个单独的模块。&lt;/p&gt;
&lt;p&gt;最开始，是使用别人的 API，后来觉得不太好，有诸多限制，而我又没有主机，于是就自己用 Javascript 写了一个本地的脚本。后来发现这样也不太好，因为本地的脚本每次加载势必要加载存放 Hitokoto 的 JSON 文件一次，当记录越来越多时，会消耗不必要的资源。毕竟每次只需要加载一条。&lt;br&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="API" scheme="https://blog.itswincer.com/tags/API/"/>
    
      <category term="Hitokoto" scheme="https://blog.itswincer.com/tags/Hitokoto/"/>
    
      <category term="Flask" scheme="https://blog.itswincer.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Linux 与 Windows 10 用 GRUB 引导教程</title>
    <link href="https://blog.itswincer.com/posts/ad42f575/"/>
    <id>https://blog.itswincer.com/posts/ad42f575/</id>
    <published>2017-10-17T11:35:19.000Z</published>
    <updated>2018-02-05T10:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年暑假的时候，写了一篇如何装 Linux 和 Windows 10 双系统的文章发在了简书上，我写这篇文章的原因是当初装双系统确实是折腾了许久，网上也找不到一篇详尽的教程。由于去年对于写教程还不是熟练，而这一年多的使用过程也遇到了一些问题，所以就准备「Refactoring」这篇文章。<br><a id="more"></a></p><h2 id="EFI-分区"><a href="#EFI-分区" class="headerlink" title="EFI 分区"></a>EFI 分区</h2><p>在教程正式开始之前，先花一点时间说明 EFI 分区的组成和作用。<br>首先，在你装了 Windows 之后，Windows 在装机过程中会将硬盘划分出一个约 100m 大小的分区，称为 EFI 分区这个分区就是起引导作用的。在资源管理器中是看不到的这个分区的，可以在磁盘管理中看到，管理则需要借助 <a href="http://www.diskgenius.cn/" target="_blank" rel="noopener">DG 工具</a>。便于说明，在装好了 Linux 之后，我将 EFI 挂载至 boot 分区截图：<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861605/blog/linux_guide/efi_folder.png" alt=""><br>可以看到，该分区包含 3 个文件夹（如果你没有装 Linux 的话，就只有两个），分别是 Boot、Microsoft 和 Manjaro，其中 Boot 文件夹就是 UEFI 引导所必需的文件。<br>我们继续打开 <code>Microsoft/Boot</code> 文件夹：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861647/blog/linux_guide/boot_folder.png" alt=""></p><p>这些文件就是启动 Windows 10 所必需的，包含了语言包、字体等，BCD 包含了 Windows 引导开始以后的信息。其中，<strong>bootmgfw.efi 是 Windows 默认引导文件</strong>。</p><ol><li>EFI/Boot/bootx64.efi</li><li>EFI/Microsoft/Boot/bootmgfw.efi</li></ol><p>以上是采用 UEFI 启动 Windows 10 的文件结构，也就是说，当你按下开机按钮的时候，首先 UEFI 找到 EFI 分区的 Boot 文件夹，然后加载 <code>bootx64.efi</code> 文件，读取文件信息，找到 <code>EFI/Microsoft/Boot/bootmgfw.efi</code>，按照 <code>bootmgfw.efi</code> 的要求，加载所需的启动信息，启动 Windows 10。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在正式装系统之前，我们还需要做一些准备工作：</p><h3 id="关闭-Windows-的快速启动"><a href="#关闭-Windows-的快速启动" class="headerlink" title="关闭 Windows 的快速启动"></a>关闭 Windows 的快速启动</h3><p>这个功能的作用是在于关机的时候不完全断电，类似将系统处于「休眠」状态，这样可以让开机更加迅速。但这也就导致了只能使用 Windows 系统。</p><h3 id="关闭-BIOS-的-Secure-Boot-的功能"><a href="#关闭-BIOS-的-Secure-Boot-的功能" class="headerlink" title="关闭 BIOS 的 Secure Boot 的功能"></a>关闭 BIOS 的 Secure Boot 的功能</h3><p>在默认情况下，UEFI 固件只会加载那些被签名的引导程序。在缺少 Secure Boot 功能的传统 PC 机上，恶意的后门程序可以加载自身，进而摇身一变伪装成一个引导程序。这样的话，BIOS 就会在启动的时候加载后门程序，这样它就可以躲过操作系统，把自己隐藏得很深。<br>但是不得不说，这对我们安装 Linux 造成了很大的困扰，也是直接导致我们重启到 Windows 10 后进不去 Linux 的原因。<br>首先我们要关闭这个功能：进入 BIOS 找到 Secure Boot，选择 disabled，这样就关闭了。当然，有些人进入 BIOS 会发现 Secure Boot 这个选项是灰色的（比如我的就是），这时你需要先给你的 BIOS 设一个密码，然后就能关 Secure Boot 了。</p><h2 id="安装-Linux"><a href="#安装-Linux" class="headerlink" title="安装 Linux"></a>安装 Linux</h2><p>所有的准备都已经完成，这时就可以准备刻录 U 盘了，不推荐 UltraISO，经亲测，软碟通仅刻录 Ubuntu 能成功，其它绝大多数发行版都会失败。推荐「<a href="https://rufus.akeo.ie/" target="_blank" rel="noopener">Rufus</a>」和「<a href="https://sourceforge.net/projects/usbwriter/" target="_blank" rel="noopener">USBWriter</a>」，这两个软件都可以。<br>刻录完成后，重启按 <code>f12</code>，选择从 USB 设备启动，对于绝大多数发行版来说一路回车就行了，只需要注意一点：<strong>在选择挂载 boot 位置的时候，一定要挂载在 efi 分区</strong>，别的都不行。<br>重启之后，不出意外的话，你会直接进入 Windows 10，不要担心，这时 Linux 已经安装成功了，我们只需要将引导文件替换一下。</p><h2 id="替换引导文件"><a href="#替换引导文件" class="headerlink" title="替换引导文件"></a>替换引导文件</h2><p>先用 DG 打开 EFI 分区，你会看到多了一个文件夹，名称取决于你安装的是哪一个发行版。我安装的是 Manjaro Linux，名称就是 Manjaro，打开之后会发现里面有一个名为 grubx64.efi 的文件，这就是启动 Linux 的引导文件。和 Windows 10 的 bootmgfw.efi 类似，我们想要用 grubx64.efi 引导代替掉 bootmgfw.efi，这样就可以用 GRUB 引导了。步骤：</p><ol><li>进入管理员命令行。方法：win + x，再按 a</li><li>输入 <code>bcdedit /set {bootmgr} path \EFI\Manjaro\grubx64.efi</code>。提示操作成功的话，就完成了。</li></ol><blockquote><p>注：经人提醒，如果输入以上命令提示「参数错误」的话，将 {bootmgr} 改为 ‘{bootmgr}’，原因是 PowerShell 和 CMD 语法的差别。</p></blockquote><p>至此，如果你安装的是除 Arch 之外绝大多数发行版，那么接下来就和你没有啥关系了，你已经成功了，好好享受吧！</p><p>开机之后会发现进入 GRUB 的引导了，通常会包含至少三个选项（以 Manjaro 举例）：Manjaro、Manjaro 高级选项和 Windows Manager。这就代表你已经完美的解决了 Windows 和 Linux 双系统引导的问题。</p><h2 id="修复-Windows-引导"><a href="#修复-Windows-引导" class="headerlink" title="修复 Windows 引导"></a>修复 Windows 引导</h2><p>这一点是我安装 Arch Llinux 的时候发现的，Arch Linux 安装过程是手动安装的，在编写 GRUB 的时候会扫描不到 Windows Manager 所在的分区（当然可能不是所有人都会遇到），所以在 GRUB 界面可能会看不到 Windows Manager 选项，导致进不去 Windows 10，这里就需要手动编辑 GRUB 信息，我们打开 <code>/boot/grub/grub.cfg</code> 文件，发现里面确实没有 Windows 10 的启动信息，在后面加上：</p><pre><code class="bash">menuentry &quot;Microsoft Windows 10&quot; {  insmod part_get  insmod fat  insmod search_fs_uuid  insmod chain  search --fs-uuid --set=root $hints_string $fs_uuid  chainloader /EFI/Microsoft/Boot/bootmgfw.efi}</code></pre><p><strong>注意</strong>：</p><p>这里的 <code>$hints_string</code>，代表的是终端执行命令：</p><pre><code class="bash">sudo grub-probe --target=hints_string /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi</code></pre><p>后的输出；</p><p>而 <code>$fs_uuid</code> 代表的是：</p><pre><code class="bash">sudo grub-probe --target=fs_uuid /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi</code></pre><p>的输出。</p><p>然后保存。在终端执行命令：<code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code>，就 OK 了。</p><p>到此，Arch Linux 和 Windows 10 双系统也配置完毕了。</p><h2 id="附加问题"><a href="#附加问题" class="headerlink" title="附加问题"></a>附加问题</h2><p>在使用这一年多的时间，遇到了以下的几个问题：</p><ol><li>在 Windows 10 进行了一个大更新后，会发现 GRUB 引导界面没有了，还是直接进入了 Windows 10，这时只需要按照 <code>替换引导文件</code> 的方法重新输入一遍命令就行。</li><li>使用 Linux 某个发行版一段时间之后，难免会想尝试一下另一个发行版。这时请务必将之前的发型版的引导文件删除，否则可能会出现无论怎么设置都无法进入 GRUB 的情况。例如：我之前用的是 Ubuntu，我现在换成了 Manjaro，我就需要用 DG 删除 EFI 分区的 Ubuntu 文件夹。</li><li>在我使用 Manjaro 更新了一次 Linux 的内核后，进不去 Windows 10 了，这个时候千万不要直接修复 Windows 10 引导，这会格式化 EFI 分区，只需要按上面 <a href="https://itswincer.com/posts/ad42f575/#%E4%BF%AE%E5%A4%8D-Windows-%E5%BC%95%E5%AF%BC" target="_blank" rel="noopener">修复 Windows 引导</a> 的方法编辑一下 GRUB 就可以了。</li></ol><p>最后：祝使用愉快。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;去年暑假的时候，写了一篇如何装 Linux 和 Windows 10 双系统的文章发在了简书上，我写这篇文章的原因是当初装双系统确实是折腾了许久，网上也找不到一篇详尽的教程。由于去年对于写教程还不是熟练，而这一年多的使用过程也遇到了一些问题，所以就准备「Refactoring」这篇文章。&lt;br&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="Linux" scheme="https://blog.itswincer.com/tags/Linux/"/>
    
      <category term="Windows" scheme="https://blog.itswincer.com/tags/Windows/"/>
    
      <category term="双系统" scheme="https://blog.itswincer.com/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Kindle Papwerwhite 开箱 &amp; 简评</title>
    <link href="https://blog.itswincer.com/posts/6619f85a/"/>
    <id>https://blog.itswincer.com/posts/6619f85a/</id>
    <published>2017-10-05T12:33:46.000Z</published>
    <updated>2017-12-23T11:39:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>If you don’t let go old things, new ones wouldn’t come.                   —— Nicolas Wincer</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>时间是在 9 月 27 日晚，我用了一年零 8 个月的 Kindle 正式宣布坏掉，原因是充不进电，我的第一反应是想着去修，后来还是打消了这个念头。主要是这个 Kindle 实在算是家族里的「老古董」了，我对 kpw3 的 300 ppi 也是种草许久，正好本着“旧的不去，新的不来”的观念，就入了一部 kpw3，其实在我想着要买  kpw3 的时候，是有点纠结 Voyage 的，因为用了快两年的 Kindle3 我已经习惯了实体翻页键，奈何囊中羞涩，只是为了这一个功能就要多花 600 +，有些不值当，想着等工作了之后直接上 Oasis。</p><a id="more"></a><p>其实我最近是比较少看书了，现在看的这本《雪中悍刀行》看了半年多才看了一半，上本《将夜》看了一年，一方面是看的书越多，品味自然也高了起来，现在写的好的小说是越来越少，之前一直很喜欢的几个作者要么更新是越来越慢（比方说：烽火戏诸侯，愤怒的香蕉）、要么是书的质量不如之前（比方说：烟雨江南、猫腻），有点担心自己看完了就书荒了。</p><p>我买 Kindle 不是为了亚马逊庞大的图书资源（我看书只自己在网上找），而是因为那块 E-ink 屏幕，而且因为 Kindle 那可怜兮兮的娱乐功能，用 Kindle 时可以更专注于看书。而国庆前几天一直忙于跑亲戚，所以直到今天才有空闲时间开箱。</p><h2 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h2><p>这就是全部的配件（裸机 + 数据线）了：右边是卖家附赠的</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861449/blog/kindle_unpacking/pic1.jpg" alt=""></p><table><thead><tr><th>参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>阅读灯</td><td style="text-align:left">4 颗</td></tr><tr><td>解析度</td><td style="text-align:left">300 ppi</td></tr><tr><td>重量</td><td style="text-align:left">205 g</td></tr><tr><td>尺寸</td><td style="text-align:left">169 × 117 × 9.1 mm</td></tr><tr><td>屏幕</td><td style="text-align:left">6 吋</td></tr><tr><td>容量</td><td style="text-align:left">4 GB</td></tr><tr><td>连接</td><td style="text-align:left">Wi-Fi</td></tr><tr><td>运存</td><td style="text-align:left">512 mb</td></tr></tbody></table><h2 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h2><p>开完箱经过简单的设置之后，迫不及待的从电脑传了几本书（谁都阻止不了我想读书的心情！）。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861472/blog/kindle_unpacking/pic2.png" alt=""></p><p>吐槽一下，这里是无法像多看一样做成文件浏览的形式，也就是说，即使你把一些书放进新建的文件夹里（便于归类管理），它也是直接在首页显示。</p><p>这就是阅读界面的选项了，选项少的可怜，而且页边距太大！我这已经设置页边距最小了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861491/blog/kindle_unpacking/pic3.png" alt=""></p><p>得益于 Kindle 这块 4:3 的屏幕，看漫画可以说是比手机更具优势。清晰度是够了，要是屏幕再大一些就好了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861506/blog/kindle_unpacking/pic4.png" alt=""></p><p>如果想要购买正版书，就在上方的搜索按钮输入书名：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861524/blog/kindle_unpacking/pic5.png" alt=""></p><p>设置界面确实寒酸，不过想想要的只是纯粹的阅读体验，也就释然了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861537/blog/kindle_unpacking/pic6.png" alt=""></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861554/blog/kindle_unpacking/pic7.png" alt=""></p><p>使用了<del>半个多小时</del>两天多了，简单总结一下感受：</p><ol><li>300 ppi 看起书来真的是太 ™ 爽了</li><li>在翻页的速度上，相比前几代快了不少，当然和手机还是没法比</li><li>阅读灯对我来说没啥用，我晚上看书也会开台灯</li><li>页边距实在太大，我都已经调整成了最小边距了，可还是留白太多</li><li>系统功能相比多看来说还是少了一些，比如无法设置全刷页数</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>买 kpw3 之前其实还有一个顾虑，就是刷不了「多看」，我的电子书资源多是 「epub」格式的，而 Kindle 的原生系统是<strong>不支持</strong>「epub」格式的（我一直搞不懂为什么亚马逊不支持）现在我每一本书都要转成 「mobi」 才能在 Kindle 上看。</p><p>还有就是实体翻页键了，等我经济独立之后，一定要买 Oasis！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;If you don’t let go old things, new ones wouldn’t come.                   —— Nicolas Wincer&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;时间是在 9 月 27 日晚，我用了一年零 8 个月的 Kindle 正式宣布坏掉，原因是充不进电，我的第一反应是想着去修，后来还是打消了这个念头。主要是这个 Kindle 实在算是家族里的「老古董」了，我对 kpw3 的 300 ppi 也是种草许久，正好本着“旧的不去，新的不来”的观念，就入了一部 kpw3，其实在我想着要买  kpw3 的时候，是有点纠结 Voyage 的，因为用了快两年的 Kindle3 我已经习惯了实体翻页键，奈何囊中羞涩，只是为了这一个功能就要多花 600 +，有些不值当，想着等工作了之后直接上 Oasis。&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="开箱" scheme="https://blog.itswincer.com/tags/%E5%BC%80%E7%AE%B1/"/>
    
      <category term="Kindle" scheme="https://blog.itswincer.com/tags/Kindle/"/>
    
      <category term="简评" scheme="https://blog.itswincer.com/tags/%E7%AE%80%E8%AF%84/"/>
    
      <category term="电子书" scheme="https://blog.itswincer.com/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
</feed>
