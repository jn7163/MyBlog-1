<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hitokoto（一言）API 2.0 正式上线</title>
      <link href="/posts/a5c39267/"/>
      <url>/posts/a5c39267/</url>
      <content type="html"><![CDATA[<p>去年夏天的时候，用 Flask 开发了一个<a href="../f6e1eb2a/">简易版的一言</a>，算是最初的 beta 版，部署在了 Heroku 上面（那时我还没购买服务器），由于 Heroku 免费版是时间池的限制，在我购置了服务器后就重新用 Go 重写了一下<a href="../b3085a7/#搭建-API">部署在自己的服务器上</a>，算是 1.0 版，这两天又重新拾坑，开发出了 2.0 版本。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 1.0 版本使用了较长的时间后，基于以下考量，我还是重构了部分代码：</p><ol><li>收录一言数太少：我没事的时候就喜欢刷新玩，经常发现眼熟的，毕竟也就不到一千条；</li><li>性能：由于使用的是 SQLite，在每秒请求数在 1000 的时候就 GG 了；</li><li>查询参数：返回不超过查询长度参数的一言，但翻了一大堆 API，都并没有提供这个功能；</li></ol><p>于是乎，本着「生命不死，折腾不止」的态度，2.0 版本诞生了。</p><blockquote><p>本 API 的<a href="https://github.com/WincerChan/Hitokoto" target="_blank" rel="noopener">源码</a>已开源至 GitHub，如有需要的可自行搭建。</p></blockquote><p>以下是 2.0 版本的更新日志：</p><h2 id="数量问题"><a href="#数量问题" class="headerlink" title="数量问题"></a>数量问题</h2><p>爬取数据时采用了异步爬虫，解决了 1.0 版本爬取时效率低下的问题，同时选取了 xxhash 作为散列函数，将一言主体 hash 后，得到的 64bit 的无符号整数作为主键，这样如果爬取到了重复的一言也不会插入数据库中。</p><p>得益于异步爬虫的高效率，在很短的时间内，爬取到了足够的一言数。目前，数据库内共有 <code>15371</code> 条一言。以后数量还会不断地增加。<a href="https://github.com/WincerChan/Hitokoto-Spider" target="_blank" rel="noopener">爬虫程序</a>已托管至 GitHub。</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>数据库更换成了 MySQL，以承受高并发访问，以下为建表语句：</p><pre><code class="mysql">+----------+---------------------+------+-----+---------+-------+| Field    | Type                | Null | Key | Default | Extra |+----------+---------------------+------+-----+---------+-------+| id       | bigint(20) unsigned | NO   | PRI | NULL    |       || hitokoto | varchar(300)        | NO   |     | NULL    |       || source   | varchar(64)         | NO   |     | NULL    |       || origin   | varchar(12)         | NO   |     | NULL    |       |+----------+---------------------+------+-----+---------+-------+</code></pre><h2 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h2><p>2.0 版本共包含以下请求参数：</p><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>格式为 <code>encode=</code>，包含以下四个参数值：</p><ul><li>js：JavaScript 脚本，将一言插入 HTML 中第一次出现 <code>class = &#39;hitokoto&#39;</code> 的标签中</li><li>json：JSON 格式的字符串，包含主体（hitokoto），出处（source）</li><li>text：一言句子的主体</li><li>默认为：<code>×××××——「×××」</code>，即主体 + 出处</li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>格式为 <code>charset=</code>，包含以下两个参数值：</p><ul><li>utf-8：在 Header 中的 <code>content-type</code> 字段添加 <code>charset=utf-8</code></li><li>gbk：同上</li></ul><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>格式为 <code>length=</code>，会随机返回一条不超过这个查询长度的语句。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>格式为 <code>callback=</code>，会根据回调参数的值返回对应的函数调用，其中函数的参数为一个字典，key 分别为 <code>hitokoto</code> 和 <code>source</code>。</p><blockquote><p><strong>注意：callback 参数会覆盖掉 encode 参数</strong></p></blockquote><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>调用地址：<code>https://api.itswincer.com/hitokoto/v2/</code></p><p>例如，我想请求一个长度不超过 10 的一言，并以 JSON 格式返回：</p><pre><code class="bash">curl &#39;https://api.itswincer.com/hitokoto/v2/?encode=json&amp;length=10&#39;{&quot;hitokoto&quot;:&quot;(눈_눈)&quot;,&quot;source&quot;:&quot;进击的巨人&quot;}</code></pre><p>如果想在自己的网页使用的话，可以采取以下两种方法：</p><h3 id="JS-方法"><a href="#JS-方法" class="headerlink" title="JS 方法"></a>JS 方法</h3><p>只需要在想要展示的标签加上 <code>class=&#39;hitokoto&#39;</code> 属性，随后在任何地方加上：</p><pre><code class="html">&lt;script src=&quot;https://api.itswincer.com/hitokoto/v2/?encode=js&quot;&gt;&lt;/script&gt;</code></pre><p>插入页面的显示结果是：××××××× ——「×××」形式。</p><p>展示结果见：<a href="https://www.itswincer.com/" target="_blank" rel="noopener">我的主页</a>。</p><h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><p>如果对 <code>encode=js</code> 返回的格式不满意，可自行定义页面展示的格式：比如以下代码仅展示一言的主体部分：</p><p>定义标签和函数：</p><pre><code class="html">&lt;p class=&quot;hitokoto&quot;&gt;&lt;/p&gt;&lt;script&gt;    // 定义回调函数名 showHitokoto    function showHitokoto(data){        // 比如我只想展示一言主体部分        var hitokoto = data.hitokoto;        // 插入 class=hitokoto 的标签        var dom = document.querySelector(&#39;.hitokoto&#39;);        Array.isArray(dom)?dom[0].innerText=hitokoto:dom.innerText=hitokoto;    }&lt;/script&gt;</code></pre><p>随后将请求地址加上参数 <code>callback=showHitokoto</code>：</p><pre><code class="html">&lt;script src=&quot;https://api.itswincer.com/hitokoto/v2/?callback=showHitokoto&quot;&gt;&lt;/script&gt;</code></pre><p>以上示例将会在 HTML 标签首个包含 <code>class=&#39;hitokoto&#39;</code> 的标签内部插入仅包含一言主体的部分。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>你看到某句熟悉的一言从屏幕上显示的时候，勾起了之前第一次看到这句话时或感动、或开心、或难过的回忆，而某个陌生人也会因此和你一样陷入属于他的短暂回忆——想到这些不是很快乐吗？而我想那个陌生人一定也正想着同样的事情。我一直这样觉得。</p><p>而这，应当就是文字赋予一言的最大作用了。</p>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一言 </tag>
            
            <tag> API </tag>
            
            <tag> Hitokoto </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客访问统计报告（2017.6.20-2018.7.4）</title>
      <link href="/posts/790223d2/"/>
      <url>/posts/790223d2/</url>
      <content type="html"><![CDATA[<p>我的博客<a href="../4a17b156/">建站至今</a>也一年有余了，本想着在一周年（今年 5 月初）之际写一篇文章纪念一下，顺便公布一下本博客在这一年的访问情况，可当时发现统计记录还没有满一年（我是在 2017 年 6 月底才开始使用的 Google 分析），于是就想干脆等到 6 月底再写。而前段时间又忙于准备期末考试，直到昨天放假回家，似乎才有时间写这一篇文章。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先我并不确定 Google 分析的准确性有多高，因为当我查看 Cloudflare 自带的分析功能是，得到的数据与 Google 分析的有很大很大的差别。以近一周的数据做对比：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1531016567/blog/blog_reporter/ga_vs_cf.png" alt="左 Google，右 Cloudflare" title="左 Google，右 Cloudflare"></p><p>虽说 Cloudflare 统计了所有的 HTTP 请求，但<strong>我博客实则只有 html 页面才会走 Cloudflare 的线路</strong>，其它的静态资源我都放在 CDN 了。而 Cloudflare 对于近一周访问 html 页面给出的数据是占总请求数的 48%——约 3411 次，这应该是与 Google 的页面浏览量（540）作为对比（加上其余两个子网站的浏览量分别为 121、4），可以看到仍然有将近 7 倍的差距，用户数也有近 5 倍差距——我确实想不出一个合理的解释（根据 Cloudflare 给出的解释，可能是由于某些网络爬虫，故与基于 Javascript 的统计工具来说有较大出入）。</p><p>但 Cloudflare 无法给出像 Google 分析那样包括平均会话、每次会话浏览数、跳出率等等指标，故本篇博客还是选取 Google 分析的数据进行分析。</p><h2 id="受众群体"><a href="#受众群体" class="headerlink" title="受众群体"></a>受众群体</h2><p>在过去的一年零两周内，本博客的基本访问情况如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530761892/blog/blog_reporter/overview.png" alt="概览"></p><p>这期间，本博客一共迎来了 5,446 位用户，他们一共产生了 10,508 次会话以及 19,989 次浏览。平均每天 14 位用户、28 次会话、53 次浏览。</p><p>图表中有一个较为凸出的高峰（5 月 29 日），原因是我在 V2EX 发了帖介绍自己写的一个<a href="https://www.v2ex.com/t/458433#reply23" target="_blank" rel="noopener">表情包生成工具</a>，这个工具中算是间接性的把用户引导至本博客了。</p><h2 id="流量获取"><a href="#流量获取" class="headerlink" title="流量获取"></a>流量获取</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530763252/blog/blog_reporter/traffic_overview.png" alt="流量"></p><p>其中流量获取的来源主要是三部分：Referral（引荐）、Organic Search（搜索引擎）、Direct（直连）。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530766976/blog/blog_reporter/traffic_cmp.png" alt="对比"></p><p>其中 Google 的流量占了大多数：36.80%，其次是本博客自身的引荐；本博客并没有添加百度站长的信息，并且主动屏蔽了百度蜘蛛的爬取，故并没有来自百度的流量。</p><p>现在的 Google 分析为了保护用户隐私，已经无法显示用户查询的关键词了。</p><h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530766078/blog/blog_reporter/location.png" alt="地理"></p><p>毫无疑问，本博客的主要流量都来自于中国大陆，不过令我感到奇怪的是第二名是美国。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530766008/blog/blog_reporter/language.png" alt="语言"></p><p>在操作系统语言中：</p><p>简体中文（zh-CN + zh-cn）占了 72.27%，较地理为中国大陆的 68.93% 多出了 3.34 个百分点；</p><p>英语（en-US + en-us）占了 16.91%，较地理为美国的 11.06% 也多出了 5.85 个百分点；</p><p>也就是说，并非只有美国地区的人才会使用英文，也并非中国地区的人才会使用中文。</p><h2 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530768660/blog/blog_reporter/browser.png" alt="浏览器"></p><p>首先看看浏览器的占用，由于本博客的类型更偏技术一些，故 Chrome、Safari、Firefox 的使用占据前三甲，其中 IE 的份额不足 0.4%，这意味着我并不需要照顾 IE 的用户，可以尽情使用各种新技术。</p><p>第四的 Android Webview 应该是指 App（QQ、微信） 内置的浏览器。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530765885/blog/blog_reporter/system.png" alt="操作系统"></p><p>操作系统毫无疑问是以 Windows 独占鳌头，其次是 Linux，我一直使用 Manjaro Linux 作为日常开发，比 Windows 方便许多，也没有 Windows 那么多 Bug，由于娱乐方式的缺乏，在 Linux 下开发也会更加专注。</p><h2 id="浏览页面"><a href="#浏览页面" class="headerlink" title="浏览页面"></a>浏览页面</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530767677/blog/blog_reporter/page.png" alt="页面浏览"></p><p>在本站可访问页面中（仅统计文章页面），浏览量的前六名分别是：</p><ol><li><a href="../ad42f575/">Linux 与 Windows 10 用 GRUB 引导教程</a></li><li><a href="../cfd78fa9/">解除百度云下载限速</a></li><li><a href="../2aa541e6/">Spacemacs 生存指北</a></li><li><a href="../bf0413ac/">Nextcloud 搭建私人云服务教程</a></li><li><a href="../72171293/">QQ 音乐外链解析</a></li><li><a href="../8575e868/">Sorry，会写代码真的能为所欲为</a></li></ol><p>（唉，最满意的几篇文章浏览量反倒是挺低的，心情复杂.jpg。）</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>自本博客运营至今共发布了 53 篇文章，其中自 17 年 9 月以来，发文的频率明显降低：首 4 个月发了 33 篇文章，17 年 9 月至今却只发了 20 篇。一方面是刚建站的时候事比较多；另一方面是相较于博客数量来说，更开始注重博客质量了。</p><p>当我选择运营独立博客开始，并没有想从中得到什么实质性的好处。在快餐时代似乎坚持写独立文章的人越来越少了，这也无可厚非，毕竟短期内看不到结果的话，有些人就无法坚持了。周围的人似乎对此（我写博客这件事）表示不太理解，当然别人的看法并不重要，重要的是，自己想坚持做下去，而只要能长期的投入一件事中，最终一定能从中获取乐趣和满足感。</p><p>我就是如此。</p>]]></content>
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Google Analytics </tag>
            
            <tag> 访问统计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用持续集成（CI）开发项目</title>
      <link href="/posts/f011ea9c/"/>
      <url>/posts/f011ea9c/</url>
      <content type="html"><![CDATA[<p>我的博客在建站后不久就使用了 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 自动部署服务，即我只需要将修改的源码推送至 GitHub，Travis CI 会自动将我提交的代码拉取，在 Travis CI 端生成静态文件后，同步至我的服务器，这样可以减少一些麻烦的步骤：可以直接在 GitHub 端修改代码；不用等待生成静态文件、压缩静态文件的时间。<a id="more"></a></p><h2 id="Circle-CI"><a href="#Circle-CI" class="headerlink" title="Circle CI"></a>Circle CI</h2><p>虽然使用 Travis CI 是能简化部分开发流程，但这货和 GitHub 是一对一的，只支持在 GitHub 托管的项目，并不支持 Bitbucket 和 GitLab，而 GitHub 免费版在私人仓库这一方面是比不上 Bitbucket 和 GitLab 的（虽然我是学生，可以使用 GitHub 私人仓库，可我也不一直是学生呀），同时支持 Bitbucket 的和 GitHub 私人仓库的 CI 工具（自建的除外）好像真的也就 <a href="https://circleci.com/" target="_blank" rel="noopener">CircleCI</a> 了，这里之所以没有考虑 GitLab 是因为 GitLab 自带有 CI/CD，而且这家公司给我的印象实在不太好（包括之前的删库事件，以及莫名奇妙的 Bug）。</p><p>在了解 CircleCI 后发现比 Travis CI 真是强不少（CircleCI 是基于 Docker 和 Workflows 设定模式的），不过在网上并没有很完善的中文教程<del>（虽然官方英文文档已经很完善了）</del>。所以如果你懒得翻官方文档的话，继续往下看我这篇文章就好了🤓。</p><h2 id="选择仓库"><a href="#选择仓库" class="headerlink" title="选择仓库"></a>选择仓库</h2><p>CircleCI 支持 GitHub 和 Bitbucket 帐号的登录，授权登录完成后，就可以添加 Projects 了，支持 GitHub 和 Bitbucket 的公有及私有仓库。这里以我的 <a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 仓库为例。</p><p>选完仓库后，就可以开始配置 CircleCI 了。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="添加-SSH-密钥"><a href="#添加-SSH-密钥" class="headerlink" title="添加 SSH 密钥"></a>添加 SSH 密钥</h3><p><a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 仓库用到 SSH 密钥的地方有两处：</p><ol><li>从 GitHub 克隆仓库</li><li>将编译后的静态文件推送至我的服务器</li></ol><p>如果你是用来推送至 GitHub 的话，可以直接用 GitHub 提供为该仓库提供的 Token 密钥，第一点也可以使用 HTTPS 方式克隆，就可以省去添加 SSH 密钥这个步骤。</p><p>点击 CircleCI 个人主页的 JOBS 菜单项，随后点击仓库名称右边的齿轮按钮 -&gt; 点击 <code>SSH Permissions</code> -&gt; 点击蓝色的 <code>Add SSH Key</code> 按钮，将<strong>私钥</strong>（看清楚了，是私钥）粘贴进去（超级良心有木有啊，比 Travis CI 将私钥加密上传这种土办法不知道高到哪里去了）。</p><h3 id="添加-IP-至-known-hosts"><a href="#添加-IP-至-known-hosts" class="headerlink" title="添加 IP 至 known_hosts"></a>添加 IP 至 known_hosts</h3><p>添加 SSH 密钥后，还需要将服务器的 IP 添加至 known_hosts 列表，否则每次部署的时候都会让你确认以下消息：</p><pre><code class="bash">The authenticity of host &#39;××.×××.×××.×××&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:7hkfahfla8VeiuyF/TLHKfhakgcJ0sHjaLxDyIKlfhak9fuaofoa.Are you sure you want to continue connecting (yes/no)?</code></pre><p>同 Travis CI 类似，CircleCI 在运行的过程中也是不接受命令行输入的（当然运行完成后就更不行了），所以我们需要提前将 IP 写入 known_hosts（在 CircleCI 中如何做？继续往后看）：</p><pre><code class="bash">ssh-keyscan $SSH_IP &gt;&gt; ~/.ssh/known_hosts</code></pre><p>在该仓库的管理页面中的 <code>Environment Variables</code> 选项卡中添加 SSH_IP 的环境变量。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>由于我的配置文件太过长了，先以一个简化版为例：</p><pre><code class="yaml">version: 2jobs:  build:    docker:      - image: circleci/node:10.4.0    steps:      - checkout      - run:          name: Install Dependence          command: |            yarn install &amp;&amp; yarn build      - run:            name: Deploy            command: |              echo &quot;Denpendence installed.&quot;</code></pre><p>首先指明 CircleCI 的版本号——2.0（1.0 在 18 年 9 月之后就停止支持了）。</p><p>其次，为 Docker 指定 image（<a href="https://circleci.com/docs/2.0/circleci-images/" target="_blank" rel="noopener">这是</a>官方已经构建完成的镜像列表），可以指定多个 image。先前提到过，CircleCI 并不默认像 Travis CI 那样提供 Linux 虚拟机镜像，推荐使用的是 Docker（当然你也可以指定工作方式为 Machine），这是官方针对 Docker 和 Machine 的<a href="https://circleci.com/docs/2.0/executor-types/#overview" target="_blank" rel="noopener">对比报告</a>。</p><p>随后在 <code>steps</code> 里面是需要运行的指令：</p><ol><li><code>checkout</code> 是一个用于检查配置路径的源代码的特殊步骤，并可以通过 SSH 来 clone 远程仓库的代码（如果你已经添加了 SSH 私钥的话，不然就只好手动 clone 了），详解见<a href="https://circleci.com/docs/2.0/configuration-reference/#checkout" target="_blank" rel="noopener">官方文档</a></li><li><code>run:</code> 后面接的是 bash 命令，<code>name</code> 该任务的名称，<code>command</code> 为具体 bash 的指令</li></ol><h3 id="安装额外命令"><a href="#安装额外命令" class="headerlink" title="安装额外命令"></a>安装额外命令</h3><p>需要注意的是，如果你需要将生成的静态文件同步至服务器所用的 <code>rsync</code> 命令是没有被安装的，只有<a href="https://circleci.com/docs/2.0/circleci-images/#pre-installed-tools" target="_blank" rel="noopener">这些命令</a>是被安装在所有镜像中的。</p><p>docker 镜像预装的系统是 Ubuntu，可采取 <code>apt-get</code> 命令来安装需要的软件包：</p><pre><code class="yaml">run:   name: Update System  command: |    sudo apt-get update &amp;&amp; sudo apt-get install rsync</code></pre><h3 id="设置缓存"><a href="#设置缓存" class="headerlink" title="设置缓存"></a>设置缓存</h3><p>CircleCI 建议的 Workflows 中建议将整个工作流分割成不同的子作业，比如说以 Yarn 项目为例，可以分成 <code>build</code> 和 <code>deploy</code> 两个流程。其中 <code>build</code> 用以安装依赖和生成待部署的静态文件；<code>deploy</code> 用以将生成的静态文件部署至服务器。</p><p>可以看出，静态文件是横跨两个作业的，所以我们需要将包含静态文件的文件夹缓存下来（当然你也可以选择不使用 Workflows，这样就只需创建一个工作就好了），在 <code>build</code> 工作中缓存采取如下命令：</p><pre><code class="yaml">steps:  - restore_cache:    keys:      - build-v1-{{ checksum "package.json" }}    paths:      - &quot;build&quot;</code></pre><p>以上命令是将 <code>build</code> 文件夹以 <code>key-value</code> 形式缓存，其中 <code>key</code> 选择的是 <code>package.json</code> 的哈希值。这里的文件名最好选择仓库自带的文件。更多 <code>key</code> 的形式可以参考<a href="https://circleci.com/docs/2.0/caching/#using-keys-and-templates" target="_blank" rel="noopener">这里</a>。</p><p>在 <code>deploy</code> 工作中恢复缓存采取以下命令：</p><pre><code class="yaml">steps:  - checkout  - restore_cache:    keys:      - meme-v1-{{ checksum "package.json" }}</code></pre><p>注意在 <code>restore_cache</code> 之前一定要有 <code>checkout</code> 命令。</p><h3 id="完整的示例"><a href="#完整的示例" class="headerlink" title="完整的示例"></a>完整的示例</h3><p>直接贴 <a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 项目的配置代码了：</p><button class="load_gist" gist="04b5e1ee8a1fbc8bc2e078d2c354bd7b"></button><p>每次构建完成后，commits 列表的画风就变成这样了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858045/blog/ci_project/circleci_construction.png" alt="CircleCI 构建"></p><p>点击 Details 就会显示每次构建的详细过程。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>虽然本文名为「使用持续集成（CI）开发项目」，但实际却好像只介绍了 CircleCI，当然我的意思不是钦定 CircleCI 作为最好的持续集成系统，我没有说 CircleCI 是最好的持续集成系统，没有任何这个意思。但你一定要问我为什么选 CircleCI，它现在对 Bitbucket 和 GitHub 的私人仓库支持最完善，我怎么能不支持它呢？</p><p>参考：</p><ul><li><a href="https://circleci.com/docs/2.0/" target="_blank" rel="noopener">2.0 Docs</a></li></ul>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI </tag>
            
            <tag> 持续集成 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sorry，会写代码真的能为所欲为</title>
      <link href="/posts/8575e868/"/>
      <url>/posts/8575e868/</url>
      <content type="html"><![CDATA[<p>前一段时间「这个仇我先记下了」的表情包突然火了，导致我也萌生了自己写一个表情包生成工具的想法，毕竟我是重度表情包玩家😌。其实之前我就很喜欢做表情包，不过是用的 PS 等软件，有些麻烦，而且改 GIF 也不太方便。</p><p>于是乎，我决定也蹭一波热度，也写了一个，最初是只有「记仇」这个静态表情包的，现在加上了王境泽、为所欲为、打工是不可能打工的等等动图，模板后续还会添加，如果有好的素材可以私我。<a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>当然网上也有一些表情包生成器，比如「<a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">sorry</a>」，但界面我不太喜欢，而且我觉得这类较为简单的处理没必要借助服务器端渲染合成，直接在浏览器端渲染就好了，<del>毕竟 JavaScript 算是一门「万能的语言」</del>。</p><p>核心思路是采用 omggif 对 GIF 进行解码，再用 Canvas 将文字绘制在每一帧上，最后再用 gif.js 将每一帧合成，再渲染后输出成 Blob 文件对象（<a href="https://caniuse.com/#search=blob" target="_blank" rel="noopener">现在不支持 Blob 的浏览器应该没有了吧？</a>），传递给 IMG 标签进行显示。</p><p>这是解码过程：</p><pre><code class="javascript">// 解码let gifReader = new omggif.GifReader(buffer);    // 获取帧let frameZero = girReader.frameInfo(0)            // 获取帧的宽高，绘制 Canvas 的时候会用到let [width, height] = [frameZero.width, frameZero.height]    let imageBuffer = new Uint8ClampedArray(width * height * 4)gifReader.decodeAndBlitFrameRGBA(frameNum, imageBuffer);// 生成图像数据，供 Canvas 使用let imageData = new window.ImageData(imageBuffer, width, height)</code></pre><p>这是绘制过程：</p><pre><code class="javascript">ctx.putImageData(imageData, 0, 0)// 这是字幕的白边ctx.strokeText(caption, width / 2, height - 5, width);// 这是字幕的主体ctx.fillText(caption, width / 2, height - 5, width)</code></pre><p>这是编码（渲染）过程：</p><pre><code class="javascript">let gif = new GIF({    workers: 3,    quality: 10,    width: imageWidth,    height: imageHeight,})// Canvas 的数据加入帧gif.addFrame(ctx, {    copy: true,    delay: frameInfo.delay,    dispose: -1})// 开始渲染gif.render()// 渲染完成gif.on(&#39;finished&#39;, Blob =&gt; {    gifUrl = window.URL.createObjectURL(Blob);    img.src = gifUrl;})</code></pre><p>以上是动图的设计思路，静态图就显得简单多了，采用 dom-to-img 绘制就行了，但是在 Edge 上似乎是无法使用的，作者提到似乎是因为添加了 foreignObject 标签，导致 toDataUrl() 在 Edge 上无法工作，所以 Edge 用户只能使用动图部分了。</p><p>其实核心思路很简单， gif.js 和 omggif 提供的 API 也不复杂，但我还是花了将近一周的时间，因为这是我首次使用 React 开发应用，所以有大半时间都花在了学习 React 上，然而写出来的结果还是偏「Pure JavaScript」一些。</p><p><a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">本项目</a>采用 <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> 构建，CSS 框架采用了 <a href="https://github.com/jgthms/bulma" target="_blank" rel="noopener">bulma</a>，部分动图模板来自 <a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">sorry</a>。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>刚刚有提到，我在设计该工具的时候大部分时间都没有花在核心思路部分，而是花在了——我称为「薛定谔的 Bug」上，即：你在设计该工具的蓝图的时候，没有设想到会出现这些 Bug，而实际编程中，也不一定会遇到，只有你亲自编写了，才知道这 Bug 是否会出现。</p><p>我在这次编程中就遇到了四个「薛定谔的 Bug」：</p><h3 id="Blob-文件对象"><a href="#Blob-文件对象" class="headerlink" title="Blob 文件对象"></a>Blob 文件对象</h3><p>关于静态图部分，我设计了两个按钮：「戳我预览」和「戳我下载」，其实本应该只需要一个下载按钮就够了，因为我使用 contenteditable 属性以编辑 p 标签。和生成的预览图几乎没什么差别，那么为什么要设计两个呢？就是因为 Blob 对象（后续思考了一下，虽然可以先行判断浏览器是否支持 Blob 下载，但针对动态图还是需要预览修正的，故为了设计上的统一性，还是将预览按钮保留了）。</p><p>其实大部分人应该是没有听说过这个名词的（包括我），但它还真的不是一个新玩意，甚至都不是 HTML5 新增的 API，相比于 HTML5 在 2014 年才完成标准制定，在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">MDN</a> 上查到 Blob 对象在 2010 年就被主流浏览器支持了（Chrome 5、Firefox 4、Opera 11.1），但，如今大部分手机浏览器却仍不支持 Blob 文件下载协议。</p><p>所以只好提供一个预览按钮来供不支持 Blob 文件下载协议的浏览器长按进行保存。</p><h3 id="服务器问题"><a href="#服务器问题" class="headerlink" title="服务器问题"></a>服务器问题</h3><p>由于我的服务器是在国外，而且还套了一层 Cloudflare，故而在某些情况下，加载动图会非常慢，尤其是在晚上（大约花费 1min，而且居然还没断，我真是很佩服 Cloudflare 的稳定性）。</p><p>当然图片的加载问题还不算大，可以放在<a href="https://sm.ms" target="_blank" rel="noopener">支持跨域的图床</a>上，由 <code>fetch</code> 调用，问题最大的是 Web Worker（合成 GIF 的时候需要使用），但这个 Web Worker 的地址在 Chrome 下<strong>只允许</strong>同域名下的脚本，即使是公共 CDN 上允许跨域都不行。</p><p>这里采用还是借助 Blob 对象，巧妙的规避这一限制：</p><pre><code class="javascript">let tmpWorker = await fetch(url),    workerSrcBlob = new Blob([await tmpWorker.text()], { type: &#39;text/javascript&#39; }),    workerBlobURL = window.URL.createObjectURL(workerSrcBlob);</code></pre><h3 id="React-Router-404-错误"><a href="#React-Router-404-错误" class="headerlink" title="React Router 404 错误"></a>React Router 404 错误</h3><p>在将代码生成「production build」时，遇到了一个 Bug，有时访问二级路由会出现 404，多次复现后，终于确定了：</p><p>在访问二级路由时，如果是正常从一级页面点击跳转的，则会正常访问；</p><p>但如果是直接访问二级路由或者是在二级路由刷新页面，则会出现 404；</p><p>但是这个 Bug 在「development build」中是没有的，原因在于当你点击路由时，并不是直接向服务器发起请求，而是由 react-router 路由库给出路由网址，故而刷新二级路由页面或者直接访问二级路由页面服务器是无法正确响应的。</p><p>以下是解决办法，在 Nginx 中添加 <code>try_files</code> 语句：</p><pre><code class="nginx">server {    location / {        try_files $uri /index.html    }}</code></pre><h3 id="GIF-渲染"><a href="#GIF-渲染" class="headerlink" title="GIF 渲染"></a>GIF 渲染</h3><p>当我解决了以上问题的时候，我发给室友首先试用，看到了「戳我预览」这个按钮，他就以「单身十八年」的手速猛戳了四五下，随后标志着渲染进度条就「鬼畜」了起来。因为他猛戳的那几下相当于在后台启动了好几个渲染程序，不仅会让进度条「鬼畜」起来，如果你以更快的手速戳的话（单身八十年？）还会让 CPU 负担加重，甚至会卡死，当然我是没有试过。其实这 Bug 算是无伤大雅的，本不太需要修复，<del>因为不像其它生成器拿服务器做后端，可能会造成服务器宕机，我的纯前端写的</del>。但我本着人道主义情怀、不让我的 Bug 陪我过夜的心理，以及最重要的强迫症，还是决定修复这个 Bug。</p><p>其实很简单，设置一个全局变量 <code>finished</code>，在渲染的过程中，该变量为 <code>false</code>，渲染完毕后设置成 <code>true</code>，再将渲染过程放置在 <code>if(finished)</code> 内就解决了。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>见<a href="https://github.com/WincerChan/Meme-generator/wiki" target="_blank" rel="noopener">本项目的 Wiki</a>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本工具还有很多需要改进的地方，比如 React 的写法不够规范、没有完全实现静态动态资源分离、用户自定义添加模板等等，这些我在空闲时间里都会一点点的改进。</p><p>目前在实用的角度来说，该工具已经可以投入使用了，剩下的细节就需要慢慢雕琢了。:)</p><p>参考：</p><ul><li><a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">xtyxtyx/sorry</a></li><li><a href="https://blog.csdn.net/xfgryujk/article/details/79889942" target="_blank" rel="noopener">纯 JS 实现在前端制作 GIF 表情包的网站</a></li><li><a href="https://react-guide.github.io/react-router-cn/docs/guides/basics/Histories.html" target="_blank" rel="noopener">Histories</a></li></ul>]]></content>
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 表情包 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 字典的原理及高级用法</title>
      <link href="/posts/4f2b4bfb/"/>
      <url>/posts/4f2b4bfb/</url>
      <content type="html"><![CDATA[<p>算算时间有段时间没写技术类的文章了，部分原因是最近过得确实比较忙。当然，也并没有忙到完全抽不出时间写博客，根本原因还是没有找到啥好的写作素材，随随便便糊弄一篇我又有点不好意思发上来，于是乎，就一直搁置到现在。<a id="more"></a></p><p>对于字典这一基础的数据结构来说，其对 Python 的程序重要性是无可替代的，在《代码之美》一书中，作者是这么描述的：</p><blockquote><p>字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到它。——A.M.Kuchling</p></blockquote><p>在 Python 程序里，无论是模块、函数、还是对象，均有自己的「命名空间」，而这命名空间即为一个字典（dict），key 就是变量名，value 就是变量值，除去「命名空间外」，对象的函数（方法）关键字也是存放在字典中，此时的 key 就是函数（方法）名，value 就是该函数（方法）的引用。可以采用 __builtins__.__dict__ 来查看这些函数（方法）。</p><h2 id="字典的原理"><a href="#字典的原理" class="headerlink" title="字典的原理"></a>字典的原理</h2><p>Python 的字典是依据<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">散列表</a>（也叫哈希表）来实现的，首先简单介绍一下散列表的原理。</p><p>散列表中的每一个单元称为表元。在 dict 的实现里，每个 key-value 均占用一个表元，其中 key 为<strong>键的引用</strong>（这里是键的引用，而不是键本身，因为 key 可以为任意可散列对象），value 为值的引用。因为是引用：表元大小均一致，所以可通过偏移量来读取某个表元。</p><p>在 Python 中，散列函数由 hash() 方法出任，当我们查询 my_dict[search_key] 时，Python 会调用 hash(search_key) 来计算 search_key 的散列值，并将这个值的低几位数字当作偏移量，在散列表中查找表元，具体是几位，需要根据散列表的大小来决定。若表元为空，则说明 search_key 不存在，抛出 KeyError 异常。若非空，则表元会有一对 found_key:found_value，这时若 search_key == found_key 为真，那么就返回 found_value。</p><p>如果 search_key 和 found_key 不相等，这种情况成为散列冲突，发生这种情况是因为散列表只把该元素映射到了只有几位数字上。为了解决散列冲突，算法会在散列值中另外取几位，用新得到的数字做偏移量再次寻找。</p><h2 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h2><p>创建一个字典有许多方式：</p><pre><code class="python">a = dict(one=1, two=2, three=3)b = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}c = dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3]))d = dict([(&#39;two&#39;, 2), (&#39;one&#39;, 1), (&#39;three&#39;, 3)])e = dict({&#39;three&#39;: 3, &#39;one&#39;: 1, &#39;two&#39;: 2})&gt;&gt;&gt; a == b == c == d == eTrue</code></pre><p>在刚刚的原理中说到，由于字典的索引是根据 hash() 函数来获得的，所以 dict 其实是无序的，这也解释了为什么上面代码中的等式会成立。</p><h2 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h2><p>没错，在 Python3+ 里，推导式不再是列表的特性了。</p><pre><code class="python">numbers = range(5)numbers_square = {number: number ** 2 for number in numbers}</code></pre><h2 id="键查询"><a href="#键查询" class="headerlink" title="键查询"></a>键查询</h2><p>最简单的方法是采用下标方式来查询。即：my_dict[key]，这也是推荐的方法，但这是 key 存在的情况，而现实中，一定会遇到 key 不存在的时候，这时就会 raise 一个 KeyError。以下有几种解决办法：</p><h3 id="用-get-来获取"><a href="#用-get-来获取" class="headerlink" title="用 get 来获取"></a>用 get 来获取</h3><pre><code class="python">my_id = {&#39;name&#39;: &#39;wincer&#39;}&gt;&gt;&gt; my_id.get(&#39;name&#39;)&#39;wincer&#39;&gt;&gt;&gt; my_id.get(&#39;age&#39;, &#39;default&#39;)&#39;default&#39;</code></pre><p>若 key 存在，则返回对应的 value，若 key 不存在，且传入第二个参数，那么返回该参数，若无第二个参数，则返回 None。</p><h3 id="用-defaultdict-预先设置缺省（推荐）"><a href="#用-defaultdict-预先设置缺省（推荐）" class="headerlink" title="用 defaultdict 预先设置缺省（推荐）"></a>用 defaultdict 预先设置缺省（推荐）</h3><pre><code class="python">from collections import defaultdictmy_id = defaultdict(list)my_id.update({&#39;name&#39;: &#39;wincer&#39;})&gt;&gt;&gt; mydict[&#39;name&#39;]&#39;wincer&#39;&gt;&gt;&gt; mydict[&#39;age&#39;][]</code></pre><p>defaultdict 需要指定一个 factory，当查询 key 不存在时，会创建一个空的 factory 返回。推荐使用这种方式来处理 key 不存在的情况，因为该方法不仅可用于读取 value 值，还可随时用 append 来更新 value。同时需注意：<strong>defaultdict 中的参数只会在 __getitem__ 中被调用。如 dd 是一个 defaultdict，k 是一个不存在的键，dd[k] 用 factory 来创造一个默认值，但 dd.get(k) 却仍会返回 None。</strong></p><h3 id="使用-missing-方法"><a href="#使用-missing-方法" class="headerlink" title="使用 __missing__ 方法"></a>使用 __missing__ 方法</h3><p>当我们调用 my_dict[key] 时，<strong>如果 key 是一个字符串</strong>，我们会需要用 my_dict[‘name’] 来获取，如果你觉得比较麻烦，想直接用 my_dict[name] 的话，可以采用如下方法：</p><pre><code class="python">from collections import UserDictclass StrKeyDict(UserDict):    def __missing__(self, key):        if isinstance(key, str):            raise KeyError(key)        return self[str(key)]    def __contains__(self, key):        return str(key) in self.data    def __setitem__(self, key, item):        self.data[str(key)] = itemd = StrKetDict([(&#39;name&#39;, &#39;wincer&#39;), (&#39;age&#39;, &#39;20&#39;)])&gt;&gt;&gt; d[2]&#39;two&#39;</code></pre><h3 id="使用-getattr-方法（不推荐）"><a href="#使用-getattr-方法（不推荐）" class="headerlink" title="使用 __getattr__ 方法（不推荐）"></a>使用 __getattr__ 方法（不推荐）</h3><p>有时我们可能更懒，想要用类属性类似的 my_dict.name 方法来获取 value，这时，可以使用 __getattr__ 方法：</p><pre><code class="python">from collections import UserDictclass AttrDict(UserDict):    def __getattr__(self, attr):        return self[attr]d = AttrDict([(&#39;name&#39;, &#39;wincer&#39;), (&#39;age&#39;, &#39;20&#39;)])&gt;&gt;&gt; d.name&#39;wincer&#39;</code></pre><p>并不推荐这样做，因为在 dict 实现中，并没有要求 key 一定为合法标识符，只需要是可散列对象即可，而上面的写法一旦 key 不为合法标识符，会 raise 一个 SyntaxError：</p><pre><code class="python">d.update({(0): &#39;zero&#39;})&gt;&gt;&gt; d[(0)]&#39;zero&#39;&gt;&gt;&gt; d.0SyntaxError: invalid syntax</code></pre><p>如果非常想使用 . 来获取 value 的话，建议使用 namedtuple</p><p>当然这也就意味着必须使用合法标识符了：</p><pre><code class="python">from collections import namedtupleID = namedtuple(&#39;ID&#39;, &#39;name age&#39;)me = ID(&#39;wincer&#39;, 20)&gt;&gt;&gt; me.name&#39;wincer&#39;ID = namedtuple(&#39;ID&#39;, &#39;(1, 0) age&#39;)ValueError: Type names and field names must be valid identifiers: &#39;(1&#39;</code></pre><h3 id="实现-switch-…-case-结构"><a href="#实现-switch-…-case-结构" class="headerlink" title="实现 switch … case 结构"></a>实现 switch … case 结构</h3><p>同样借助键查询，可以实现 Python 中没有的 switch … case 结构：</p><pre><code class="python">def foo(x):    data = {        0: &#39;zero&#39;,        1: &#39;one&#39;,        2: &#39;two&#39;,    }    return data.get(x, None)</code></pre><p>所以说 Python 不设计 switch … case 语句是有原因的，看上面的实现，比 switch … case 不知道高到哪里去了。</p><h2 id="dict-和它的小伙伴们"><a href="#dict-和它的小伙伴们" class="headerlink" title="dict 和它的小伙伴们"></a>dict 和它的小伙伴们</h2><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>在添加键的时候会按顺序添加，同时 .popitem 是会删除并返回字典的最后一个元素而不是像 dict 里面一样可能会删除任意元素。</p><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>这个映射会给键一个计数器，每次更新键时都会增加这个计时器，所以这个类型可以用以给可迭代类型计数：</p><pre><code class="python">from collections import Counterct = Counter(&#39;hfkjahfkakhf&#39;)&gt;&gt;&gt; ctCounter({&#39;a&#39;: 2, &#39;f&#39;: 3, &#39;h&#39;: 3, &#39;j&#39;: 1, &#39;k&#39;: 3})ct.update(&#39;fdjlahkla&#39;)&gt;&gt;&gt; ctCounter({&#39;a&#39;: 4, &#39;d&#39;: 1, &#39;f&#39;: 4, &#39;h&#39;: 4, &#39;j&#39;: 2, &#39;k&#39;: 4, &#39;l&#39;: 2})&gt;&gt;&gt; ct.most_common(2)[(&#39;h&#39;, 4), (&#39;f&#39;, 4)]</code></pre><h3 id="UserDict"><a href="#UserDict" class="headerlink" title="UserDict"></a>UserDict</h3><p>用法见键查询。</p><h3 id="不可变映射"><a href="#不可变映射" class="headerlink" title="不可变映射"></a>不可变映射</h3><p>在 Python 3.3 后的版本，types 模块引入一个名为 MappingProxyType 的类。如果给这个类一个映射，它会返回一个只读的映射视图。但它是动态的，如果原映射改动，那么它也会相应改动。</p><pre><code class="python">&gt;&gt;&gt; int.__dict__mappingproxy({&#39;__abs__&#39;: &lt;slot wrapper &#39;__abs__&#39; of &#39;int&#39; objects&gt;,              &#39;__add__&#39;: &lt;slot wrapper &#39;__add__&#39; of &#39;int&#39; objects&gt;,              ...})from types import MappingProxyTyped = {1: &#39;A&#39;}d_proxy = MappingProxyType(d)&gt;&gt;&gt; d_proxy[2] = &#39;x&#39;TypeError: &#39;mappingproxy&#39; object does not support item assignmentd[2] = &#39;B&#39;&gt;&gt;&gt; d_proxy[2]&#39;B&#39;</code></pre>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《代码整洁之道》读书笔记</title>
      <link href="/posts/65e48179/"/>
      <url>/posts/65e48179/</url>
      <content type="html"><![CDATA[<blockquote><p>相对于任何宏伟愿景，对细节的关注甚至是更为关键的专业性基础。首先，开发者通过小型实践获得可用于大型实践的技能和信用度。其次，宏大建筑中最细小的部分，比如关不紧的门、有点儿没铺平的地板，甚至是凌乱的桌面，都会将整个大局的魅力毁灭殆尽。这就是整洁代码之所系。</p></blockquote><p><a id="more"></a>本书「序」中的这段话完美的诠释了作者写本书的意义。（简评在最后）</p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ol><li>神在细节之中。</li><li>5S 哲学包括以下概念：<ul><li>整理（Seiri）</li><li>整顿（Seiton）</li><li>清楚（Seiso）</li><li>清洁（Seiketsu）</li><li>身美（Shitsuke）</li></ul></li></ol><h2 id="整洁代码"><a href="#整洁代码" class="headerlink" title="整洁代码"></a>整洁代码</h2><ol><li>有人也许以为，关于代码的书有点落后于时代——代码不再是问题：我们应当关注模型和需求。……扯淡！我们永远抛不掉代码，因为代码呈现了需求的细节。在某些层面上，这些细节无法被忽略或抽象，必须明确之。将需求明确到机器可以执行的细节程度，就是编程要做的事。而这种规约正是<strong>代码</strong>。</li><li>勒布朗（LeBlanc）法则：<strong>稍后等于永不</strong>（Later equals never）。</li><li>多数人都知道一幅画是好还是坏。但能分辨优劣并不表示懂得绘画。能分辨整洁代码和肮脏代码，也不意味着会写整洁代码！</li><li><strong>Bjarne Stroustrup（C++ 语言发明者）</strong>：我喜欢优雅和高效的代码。代码逻辑应当直截了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没规矩的优化，高处一堆混乱来，整洁的代码只做好一件事。</li><li><strong>Grady Booch（《面向对象分析与设计》作者）</strong>：整洁的代码简单直接。整洁的代码如同优美的散文。整洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直截了当的控制语句。</li><li><strong>Ron Jeffries（《极限编程实施》作者）</strong>：简单代码，依其重要顺序：<ul><li>能通过所有测试；</li><li>没有重复代码；</li><li>体现系统中的全部设计理念；</li><li>包括尽量少的实体，比如类、方法、函数等。</li></ul></li><li><strong>Ward Cunningham（Wiki 发明者）</strong>：如果每个例程都让你感到深合己意，那就是整洁代码。如果代码让编程语言看起来像是专为解决那个问题而存在，就可以称之为漂亮的代码。</li><li>光把代码写好可不够。必须时时保持代码整洁。</li></ol><h2 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h2><ol><li><p><strong>名副其实</strong>：变量、函数或类的名称应该已经答复了所有的大问题。它该告诉你，它为什么会存在，它做什么事，应该怎么用。</p></li><li><p><strong>避免误导</strong>：应当避免使用与本意相悖的词。别用 accountList 来指称一组账号，除非它真的是 List 类型。用 accountGroup 或 bunchOfAccounts，甚至 accounts 都会好一些。</p></li><li><p><strong>做有意义的区分</strong>：以数字系列命名（a1、a2，……aN）是依义命名的对立面。这样的名称纯属误导——完全没有提供正确信息；没有提供导向作者意图的线索。</p><pre><code class="java">public static void copyChars(char a1[], char a2[]) {    for (int i = 0; i &lt; a1.length; i++) {        a2[i] = a1[i];    }}</code></pre><p>如果参数名改为 source 和 destination，这个函数就会像样许多。</p></li><li><p><strong>使用读得出来的名称</strong>：</p><pre><code class="java">private Date genymdhms; // 生成日期，年、月、日、时、分、秒private Date generationTimestamp;</code></pre></li><li><p><strong>使用可搜索的名称</strong>：窃以为单字母名称<strong>仅</strong>用于短方法中的本地变量。名称长短应于其作用域大小相对应。</p></li><li><p><strong>避免思维映射</strong>：不应当让读者在脑中把你的名称翻译为他们熟知的名称。</p></li><li><p><strong>类名</strong>：类名和对象名应该是名词或名词短语，如 Customer、WikiPage。避免使用 Manager、Data 这样的类名。</p></li><li><p><strong>方法名</strong>：方法名应当是动词或动词短语，如 postPayment、deletePage 或 save。</p></li><li><p><strong>每个概念对应一个词</strong>：给每个抽象概念选一个词，并且一以贯之。</p></li><li><p><strong>别用双关语</strong>：避免将同一单词用于不同目的。</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li>函数的第一规则是要短小。第二条规则是还要更短小。</li><li>函数应该做一件事。做好这件事。只做这一件事。</li><li>别害怕长名称。长而具有描述性的名称，要比短而令人费解的名称好。长而具有描述性的名称，要比描述性的长注释好。</li><li>最理想的参数数量是零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应尽量避免三（三参数函数）。如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。</li><li>函数要么做什么事，要么回答什么事，但二者不可兼得。函数应该修改某对象的状态，或是返回该对象的有关信息。</li><li>重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。</li><li>我写函数时，一开始都冗长而复杂。有太多缩进和嵌套循环。然后我打磨这些代码，分解函数、修改名称、消除重复。我缩短和重新安置方法。有时我还拆散类。</li><li>大师级程序员把系统当作故事来讲，而不是当作程序来写。他们使用选定编程语言提供的工具构建一种更为丰富且更具表达力的语言，用来讲那个故事。</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li><strong>Brian W. Kernighan 与 P. J. Plaugher</strong>：别给糟糕的代码加注释——重新写吧。</li><li>注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。注意，我用了「失败」一词。我是说真的。注释总是一种失败。我为什么要极力遍地注释？因为注释会撒谎。</li><li><strong>好注释</strong>：<ol><li>法律信息</li><li>提供信息的注释</li><li>对意图的解释</li><li>阐释</li><li>警示</li><li>TODO</li></ol></li></ol><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ol><li>你今天编写的功能，极有可能在下一版本中被修改，但代码的可读性却会对以后可能发生的修改行为产生深远影响。</li><li><strong>垂直格式</strong>：<ol><li>关系密切的概念应该相互靠近。</li><li>变量声明应尽可能靠近其使用位置。</li><li>实体变量应该在类的顶部声明。</li><li>若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽肯能放在被调用者上面。</li></ol></li><li><strong>横向格式</strong>：<ol><li>应该尽量保持代码行短小。死守 80 个字符上限有点僵化，至多在 100 或 120 个字符。</li><li>赋值操作符周围加上空格字符，以此加上强调目的。</li><li>不在函数名和左圆括号之间加空格。</li><li>源文件是一种继承结构，而不是一种大纲结构。类中的方法相对该类缩进一个层级。方法的实现相对方法声明缩进一个层级。</li></ol></li></ol><h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><ol><li><p>过程式代码便于在不该动既有数据结构的前提下添加新函数。面向对象代码便于在不改动既有函数的前提下添加新类。</p></li><li><p>得墨忒耳率认为，类 C 的方法 f 只应该调用以下对象的方法：</p><ul><li>C</li><li>由 f 创建的对象；</li><li>作为参数传递给 f 的对象；</li><li>由 C 的实体变量持有的对象。</li></ul><p>方法不应调用由任何函数返回的对象的方法。换言之，只跟朋友谈话，不与陌生人谈话。</p></li><li><p>对象曝露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。数据结构曝露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。</p></li></ol><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol><li>错误处理很重要，<strong>但如果它搞乱了代码逻辑，就是错误的做法</strong>。</li><li>在某种意义上，try 代码块就像是事务。catch 代码块将程序维持在一种状态，无论 try 代码块中发生了什么均如此，所以，在编写可能抛出异常的代码时，最好先写出 try-catch-finally 语句。</li><li>你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。</li><li>对异常可以依据其来源分类：是来自组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？不过，当我们在应用程序中定义异常类时，最重要的考虑应该是<strong>它们如何被捕获</strong>。</li><li>返回 null 值，基本上是在给自己增加工作量，也是在给调用者添乱。只要有一处没检查 null 值，应用程序就会失控。在方法中返回 null 值是糟糕的做法，但将 null 值传递给其他方法就更糟糕了。</li></ol><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><ol><li><strong>学习性测试</strong>（learning tests）：不要在生产代码中试验新东西，而是编写测试来遍览和理解第三方代码</li><li>使用尚不存在的代码，将尚未开发完毕的 API 从中隔离出来。自己通过使用符合应用程序的接口，一旦 API 被定义出来，再将二者对接。</li><li>通过代码中少数几处引用第三方边界接口的位置来管理第三方边界。</li></ol><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol><li>TDD 三定律：<ol><li>在编写不能通过的单元测试前，不可编写生产代码。</li><li>只可编写刚好无法通过的单元测试，不能编译也不算通过。</li><li>只可编写刚好足以通过当前失败测试的生产代码。</li></ol></li><li>脏测试等同于——如果不是坏于的话——没测试。</li><li>测试代码和生产代码一样重要。它可不是二等公民。它需要被思考、被设计和被照料。它该像生产代码一般保持整洁。</li><li>整洁的测试有什么要素？有三个要素：可读性、可读性和可读性。</li><li>整洁的测试遵循以下 5 条规则：<ol><li><strong>快速（Fast）</strong>：测试应该够快。</li><li><strong>独立（Independent）</strong>：测试应该相互独立。</li><li><strong>可重复（Repeatable）</strong>：测试应当可在任何环境中重复通过。</li><li><strong>自足验证（Self-Validating）</strong>：测试应该有布尔值输出。</li><li><strong>及时（Timely）</strong>：测试应及时编写。</li></ol></li></ol><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol><li>类的第一条规则是类应该短小。第二条规则是还要更短小。</li><li>单一权责原则（SRP）认为，类或模块应有且只有一条加以修改的理由。</li><li>系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。</li><li>通常而言，方法操作的变量越多，就越黏聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。</li><li>开放-闭合原则（OCP）：类应当对扩展开放，对修改封闭。</li><li>依赖倒置原则（DIP）：类应当依赖于抽象而不是依赖于具体细节。</li></ol><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><ol><li>软件系统应将启始过程和启始过程之后的运行时逻辑分离开，在启始过程中构建应用对象，也会存在相互缠结的以来关系。</li><li>可以使用抽象工厂模式让应用自行控制何时创建对象，但构造的细节却隔离于应用程序代码之外。</li><li>依赖注入（Dependency Injection）：对象不应负责实体化对自身的依赖。反之，它应当将这份权移交给其他「有权力」的机制，从而实现控制的反转。</li><li>我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事。这就是迭代和增量敏捷的精髓所在。</li><li>面向方面编程（aspect-oriented）:被称为方面的模块构造指明了系统中哪些点的行为会以某种一致的方式被修改，从而支持某种特定的场景。</li></ol><h2 id="迭进"><a href="#迭进" class="headerlink" title="迭进"></a>迭进</h2><ol><li>简单设计规则 1：运行所有测试：遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近 OO 低耦合度、高内聚度的目标。</li><li>简单设计规则 2：重构：在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称等。</li><li>不可重复：「小规模复用」可大量降低系统复杂性。</li><li>表达力：做到有表达力的最重要方式却是尝试。</li><li>尽可能少的类和方法。</li></ol><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><table><thead><tr><th>名词</th><th>基础定义</th></tr></thead><tbody><tr><td>限定资源</td><td>并发环境中有着固定尺寸或数量的资源。例如数据库连接和固定尺寸读/写缓存等</td></tr><tr><td>互斥</td><td>每一时刻仅有一个线程能访问共享数据或共享资源</td></tr><tr><td>线程饥饿</td><td>一个或一组线程互相等待执行结束。</td></tr><tr><td>死锁</td><td>两个或多个线程互相等待执行结束。</td></tr><tr><td>活锁</td><td>执行次序一致的线程，每个都想要起步，但发现其他线程已经「在路上」。</td></tr></tbody></table><ol><li><p>对象是过程的抽象。线程是调度的抽象。</p></li><li><p>并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。</p></li><li><p>并发软件的中肯说法：</p><ul><li>并发会在性能和编写额外代码上增加一些开销；</li><li>正确的并发是复杂的，即便对于简单的问题也是如此；</li><li>并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待；</li><li>并发常常需要对设计策略的根本性修改。</li></ul></li><li><p>生产者-消费者模型：一个或多个生产者线程创建某些工作，并置于缓存或者队列中。一个或者多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。</p></li><li><p>读者-作者模型：当存在一个主要为读者线程提供信息源，但只是偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。协调读者线程不去读取正在更新的信息，而作者线程倾向于长期锁定读者线程。</p></li><li><p>宴席哲学家：许多企业级应用中会存在进程竞争资源的情形，如果没有用心设计，这种竞争会遭遇死锁，活锁，吞吐量和效率低等问题。</p></li></ol><p>本书后几章主要侧重于讲解 Java 代码的一些例子，对其它语言帮助不大，在这里就不做整理了。</p><hr><p>正如我在<a href="../a6c2a51d/">上一篇读书笔记</a>中所说的：每一本中都会充斥着许多作者的自己的观点、看法，而唯有价值观相符合或相接近的人才会觉得本书写得很不错，上一本《黑客与画家》是，这本《代码整洁之道》也是，你可能很难认为变量的命名需要有那么考究，函数的长短有那么重要，心里想着程序能运行就没事，甚至连 WARNING 都忽视掉，这类人想必并不是本书的目标群体。而本书的目标群体在开头已经注明了：你想成为一个更好的程序员。其实我觉得目标群体还可以加上一小撮人：有强迫症的程序员——比如我。</p><p>我曾经看自己四个月前的代码能羞愧得钻进地里，心想着怎么能写出这么烂的<a href="https://gist.github.com/WincerChan/362331456a6e0417c5aa1cf3ff7be2b7/revisions" target="_blank" rel="noopener">代码</a>。这四个月固然有我对该门语言较高层级的数据结构更加熟悉，能更熟练的操作它们，但更多的是编程观念的改变：需要用心来写代码，不要简单敷衍了事，不要认为程序只要能运行就算成功。程序毕竟还是写给人看的，就算不是为了别人，看着意义明确的变量，缩进优美的段落，结构分明的函数，想必自己心里也会很舒畅的。</p>]]></content>
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nextcloud 搭建私人云服务教程</title>
      <link href="/posts/bf0413ac/"/>
      <url>/posts/bf0413ac/</url>
      <content type="html"><![CDATA[<p>我一直很不相信国内的那些云服务提供商（尤其是在李彦宏发表的讲话「中国用户对隐私问题没那么敏感，在个人隐私方面更加开放，一定程度上愿用隐私换方便和效率」后），因为怕隐私得不到保障，故而我的一些隐私数据都是存放在国外的云盘（如 Dropbox、Drive 等）上。<a id="more"></a></p><p>可这俩在国内都被墙了，而手机翻墙总是显得有些不够方便，与是我就琢磨着自己搭建一个云服务，随后就发现了 Nextcloud 这一开源云服务。而网上的教程都太过复杂了，对新手太过不友好，于是乎——一篇近乎傻瓜式的 Nextcloud 教程诞生了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里采用 Docker 容器方式来安装 Nextcloud，这样就不用担心各种环境依赖了（Nextcloud 的依赖简直多得吓人，而 Dockerfile 会帮你把依赖都配置好）</p><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><blockquote><p>注：Docker 仅支持 64-bit 的系统</p></blockquote><p>Docker 现已被各大发行版的仓库收入，采用正常安装命令即可：</p><pre><code class="bash">yum -y install docker</code></pre><p>随后，启动 Docker 守护进程：</p><pre><code class="bash"># systemctlsystemctl start docker# Serviceservice docker start</code></pre><h3 id="安装-NextCloud"><a href="#安装-NextCloud" class="headerlink" title="安装 NextCloud"></a>安装 NextCloud</h3><h4 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h4><p>有了 Docker 后，就可以几行代码安装 Nextcloud 了：</p><pre><code class="bash"># clone nextcloud 的 docker 容器git clone https://github.com/nextcloud/docker.git# 耐心等待安装docker run -d -p 8080:80 nextcloud </code></pre><p>安装完成后先别忙着启动，<code>docker ps -a -q</code> 查看一下容器的 id，是一串 12 位的字符串，为了便于记忆，重命名一下：</p><pre><code class="bash">docker rename ××× nextcloud     # ××× 即为容器 id</code></pre><p>随后就可以采用如下命令启动了：</p><pre><code class="bash">docker start nextcloud# 测试curl http://localhost:8080</code></pre><p>这样，就完成了 Nextcloud 的安装工作。</p><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>方法一只能安装最新版的 Nextcloud，而最新版缺少部分功能，如：无法添加 Drive 和 Dropbox 的外置存储。如果你对外置存储不是很 care 的话，那就按照方法一安装就可以了。</p><pre><code class="bash">git clone https://github.com/nextcloud/docker.gitcd docker/12.0/apache</code></pre><p>这里采用官方编写的 Dockerfile 手动构建，所以时间会花得比较久。</p><pre><code class="bash">docker build -t nextcloud .</code></pre><p>这时候用 <code>docker images</code> 应该可以看到刚刚创建的镜像了，随后创建容器：</p><pre><code class="bash">docker create -v /var/www/html/apps/:/var/www/html/apps -v /var/www/html/config/:/var/www/html/config -v /var/www/html/data/:/var/www/html/data -p 127.0.0.1:8080:80/tcp --name nextcloud nextcloud</code></pre><p>稍稍解释一下参数：</p><ul><li>-v 后面是地址，前半部分是 VPS 的地址，后半部分是容器内的地址</li><li>-p 后面是端口号</li><li>–name 后面是容器名称</li><li>最后的 nextcloud 是镜像名称</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h3><p>由于 NextCloud 已经占用了 8080 端口，这里采用 Nginx 做反向代理，将域名直接解析至 8080 端口。</p><pre><code class="nginx">server {  listen 80;  server_name cloud.example.com;  location / {    proxy_pass http://localhost:8080;  }}</code></pre><p>重启 Nginx 服务后，就可以通过 cloud.example.com 来访问云服务了。</p><h3 id="NextCloud-配置"><a href="#NextCloud-配置" class="headerlink" title="NextCloud 配置"></a>NextCloud 配置</h3><pre><code class="bash"># 进入容器内的 bashdocker exec -i -t nextcloud bash</code></pre><h4 id="重定向-overwritehost"><a href="#重定向-overwritehost" class="headerlink" title="重定向 overwritehost"></a>重定向 overwritehost</h4><p>有时候 NextCloud 会自己定向至本地的 8080 端口，所以需要手动重写正确的地址：如果提示不能定位软件包，先执行 <code>apt-get update</code>。</p><pre><code class="bash">vim config/config.php# 加上下面这行&#39;overwritehost&#39; =&gt; &#39;cloud.example.com&#39;,</code></pre><p>重启，让配置生效：</p><pre><code class="bash">docker restart nextcloud</code></pre><h3 id="MySQL-配置"><a href="#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h3><p><del>由于我 VPS 的内存比较小，所以并没有启用 MySQL/MariaDB 数据库（怕爆内存），而是采用了 SQLite，反正也是我一个人用，问题不大。</del></p><p>开启了 MySQL 后发现内存也就多了 20M（但性能的提升可不是一点半点），遂还是改成 MySQL 了：</p><ol><li><p>安装 MySQL（这里采用 MariaDB 分支）</p><pre><code class="bash">yum -y install mariadb-server mariadb-client# 设置一下 root 密码等mysql_secure_installation</code></pre></li><li><p>开启 daemon 服务</p><pre><code class="bash">systemctl start mariadbsystemctl enable mariadb</code></pre></li><li><p><code>mysql -uroot -p</code> 登录 MySQL</p><pre><code class="mysql"># 创建 nextcloud 数据库CREATE DATABASE nextcloud CHARACTER SET = utf8 COLLATE = utf8_general_ci;# 创建 nextcloud 的用户CREATE USER nextcloud IDENTIFIED BY &#39;admin123&#39;;# 赋予对数据库所有的权限GRANT ALL ON nextcloud.* TO nextcloud;</code></pre></li></ol><h3 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h3><ol><li><p>打开 <a href="https://cloud.example.com" target="_blank" rel="noopener">https://cloud.example.com</a></p></li><li><p>创建管理员帐号和密码</p></li><li><p>数据库就选择 MySQL/MariaDB，其它参考下表：</p></li></ol><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">用户名</td><td style="text-align:center">nextcloud</td></tr><tr><td style="text-align:center">密码</td><td style="text-align:center">admin123</td></tr><tr><td style="text-align:center">数据库名</td><td style="text-align:center">nextcloud</td></tr><tr><td style="text-align:center">地址</td><td style="text-align:center">172.17.0.1</td></tr></tbody></table><p><strong>注意：这里的地址千万不要填写成了 localhost 或者 172.0.0.1，因为这里的地址需要容器内与外部通信。</strong></p><p>点击完成后，等待几秒就可以使用了。</p><h2 id="挂载外部云盘"><a href="#挂载外部云盘" class="headerlink" title="挂载外部云盘"></a>挂载外部云盘</h2><p>由于我 VPS 的容量只有 10g，故而放不了过多的视频，就考虑采用外部存储的方法，将 Drive、Dropbox 挂载至 Nextcloud 外部存储或者 VPS。</p><blockquote><p>注：Nextcloud 13 已经取消对 Drive、Dropbox 外部存储的支持（这时候你也可以选择把 Drive 直接挂载至 VPS 本地目录，再通过外部存储链接至挂载目录来完成）。</p></blockquote><h3 id="启用外部存储插件"><a href="#启用外部存储插件" class="headerlink" title="启用外部存储插件"></a>启用外部存储插件</h3><p>在应用页面，启用 <code>External storage support</code> 插件：如果提示：「没有安装 “smbclient”无法挂载 “SMB / CIFS”, “SMB / CIFS 使用 OC 登录信息”. 请联系您的系统管理员安装」</p><p>解决办法：</p><h3 id="安装-smbclient"><a href="#安装-smbclient" class="headerlink" title="安装 smbclient"></a>安装 smbclient</h3><pre><code class="bash"># 进入容器的内的 consoledocker exec -i -t nextcloud bashapt-get install libsmbclient-dev</code></pre><p>这里简单说一下，不管你的 VPS 原本的系统是 CentOS、RedHat、Debian，统一都用 apt-get 安装，因为现在处于的是 docker 容器内的系统，与 VPS 的系统是分离的。</p><p>接着再安装 smbclient：</p><pre><code class="bash">pecl install smbclient</code></pre><p>同时会提示：「You should add “extension=smbclient.so” to php.ini」，这里又被小坑一把，网上大部分教程所说的 <code>/etc/php.d/php.ini</code> 并不存在，在 docker 容器内部该文件是在：</p><pre><code class="bash">vim /usr/local/etc/php/conf.d/docker-php-ext-intl.ini# 加上下面这行extension=smbclient.so</code></pre><p>随后重启 Nextcloud 服务就应该就 OK 了。</p><p>随后如果你安装的 Nextcloud 是 13 版本及以上的话，就只有考虑用 <a href="https://www.box.com/" target="_blank" rel="noopener">box</a> 提供的 <a href="https://community.box.com/t5/Upload-and-Download-Files-and/WebDav-with-Box/ta-p/310" target="_blank" rel="noopener">WebDAV</a> 来作为外置存储了，不过只有 10G 的容量，且最大文件限制是 250MB。如果是用的 12 版本及以下的话，就可以考虑采取 Drive 作为外置存储了：</p><h3 id="获取-API"><a href="#获取-API" class="headerlink" title="获取 API"></a>获取 API</h3><ol><li><p>访问 <a href="https://www.orgleaf.com/go.php?url=https://console.developers.google.com" target="_blank" rel="noopener">Google 开发者平台</a>：</p></li><li><p>点击「启用 API 和服务」</p></li><li><p>点击「Google Drive API」</p></li><li><p>点击「启用」</p></li><li><p>点击左侧的凭据 -&gt; OAuth 同意屏幕：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844300/blog/nextcloud_tutorial/oauth.png" alt="oauth 示例"></p><p>按照以上格式填写，点击保存</p></li><li><p>随后创建凭据：</p><p>应用类型选择<strong>网页应用</strong>，其它的参考以下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844366/blog/nextcloud_tutorial/url.png" alt="url 配置"></p><p>点击创建后，会弹出悬浮框告诉你 ID 和 Key。</p></li></ol><h3 id="配置-Nextcloud"><a href="#配置-Nextcloud" class="headerlink" title="配置 Nextcloud"></a>配置 Nextcloud</h3><p>登录 Nextcloud，转至管理页面，点击「外部存储」，选择 Google Drive，填入 API 和 Key，点击授权，若授权时出现 400 错误，那么是重定向的 URI 出问题了，再添加如下一条：</p><pre><code>https://cloud.example.com/index.php/settings/admin/externalstorages</code></pre><p>如果提示「此应用未经过验证」，点击高级 -&gt; 转至 example.com，忽略掉就行。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844407/blog/nextcloud_tutorial/external_storage.png" alt="外置存储"></p><p>当出现了绿色按钮，就表示配置成功了。</p><p>参考：</p><ul><li><a href="https://github.com/nextcloud/docker#how-to-use-this-image" target="_blank" rel="noopener">Docker image of Nextcloud</a></li><li><a href="https://oing9179.github.io/blog/2017/03/Setup-Nextcloud-using-Docker-and-Nginx/" target="_blank" rel="noopener">用 Docker 和 Nginx 搭建自己的云服务器（Nextcloud）</a></li><li><a href="https://www.orgleaf.com/903.html" target="_blank" rel="noopener">连接 Google Drive 教程</a></li><li><a href="https://www.brilliantcode.net/486/freenas-10-nextcloud-use-smb-as-external-storage/" target="_blank" rel="noopener">FreeNAS 10 NextCloud 開啟外部儲存媒體的 SMB 功能</a></li></ul>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务 </tag>
            
            <tag> NextCloud </tag>
            
            <tag> VPS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>没有希望的事儿，还有坚持的必要吗</title>
      <link href="/posts/18b98ea6/"/>
      <url>/posts/18b98ea6/</url>
      <content type="html"><![CDATA[<p>「你说，没有希望的事，还有坚持的必要吗？」</p><p>确实是没想到，看国产青春剧也能看出了共鸣。<a id="more"></a></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858577/blog/still_insist/caption1.jpg" alt="拼接截图.jpg"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858598/blog/still_insist/caption2.jpg" alt="拼接截图 (1).jpg"></p><p>忘记很早之前在哪看到过一句话：人会长大三次。第一次是在发现自己不是世界中心的时候；第二次是在发现即使再怎么努力，终究还是有些事令人无能为力的时候；第三次是在明知道有些事可能会无能为力，但还是会尽力争取的时候。</p><p>最初看这句话还没什么感觉，最近看了「最好的我们」后，突然就触动了。</p><p>那种触动，想来就是怎么也绕不开的「成长」了：自己做了想做的事，而生活却没有给自己想要的结果。于是乎，以后再遇见了想做的事，开始犹豫了，开始畏缩了，开始计较得失了，因为有了之前的经历，担心自己做了，却也得不到自己想要的结果。</p><p>你当然可以说是因为自己长大了，会计较得失了、不会像小时候一样：想干什么就去干什么。是啊，第二次成长的你知道了有些事情即使再怎么努力，也不会得到满意的结果，于是干脆就不去做了。</p><p>可目前处于不明成长阶段的我啊，又觉得凡事要是都仔细衡量得失后再去想做还是不做的话，那人生想必会少掉许多乐趣、会错过许多事情。</p><hr><p>我果然还是不适合看电视剧，花了一个月时间才把《最好的我们》看完（小时候那种看电视剧甚至广告时间都不愿意转台生怕错过衔接部分的劲儿都不知道哪去了，以后有时间还是多看看电影和书），听说还有几部青春剧也挺不错（《你好，旧时光》、《一起同过窗》等），就不看了，虽说确实能勾起高中时的那些或苦涩或美好的回忆，可那些回忆却再也不可得了。</p><p>也不想总是陷在回忆里，毕竟我，到底是已经长大了。</p>]]></content>
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>QQ 音乐外链解析</title>
      <link href="/posts/72171293/"/>
      <url>/posts/72171293/</url>
      <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>大概在五天前，忽然发现一直在用的网易云解析不能用了，去作者的项目查看才知道原来是网易云更换了新的接口，旧接口的请求现在统一返回 403。于是乎，便萌生了自己写一个接口的想法。<a id="more"></a></p><p>其实网易云的外链获取目前还是有几种可用方案，比如：</p><ol><li><a href="https://m1.jixun.moe/" target="_blank" rel="noopener">云音乐直链生成器</a></li><li>手动替换：<code>https://music.163.com/song/media/outer/url?id=[].mp3</code>，将中括号改为歌曲 id，即为外链</li></ol><p>这两种方法其实大同小异，都会 302 至歌曲的缓存地址，但也存在一个身为强迫症的我无法忍受的缺点——缓存地址的协议是 <code>http</code>（从云音乐官网现在还有大量的 Mixed Content 就可以看出网易对这方面并不上心），而且自己将协议修改成 <code>https</code> 后访问部分歌曲又会有机率出现 403，这可真是逼死我了：于是决定暂时放弃掉网易云，换其他家的顶着。</p><h2 id="QQ-音乐"><a href="#QQ-音乐" class="headerlink" title="QQ 音乐"></a>QQ 音乐</h2><p>考虑了一圈，还是决定选 QQ 音乐。在网上也找到了 QQ 音乐所提供的接口：</p><ul><li>请求地址：<code>https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg</code></li><li>参数，有三个：<ol><li>songmid：歌曲页 Url 的 <code>https://y.qq.com/n/yqq/song/{}.html</code> 括号部分</li><li>filename：歌曲名 <code>&#39;C00&#39; + songmid + &#39;.m4a&#39;</code></li><li>guid：随机生成的数字串 <code>int(random() * 2147483647) * int(time() * 1000) % 10000000000</code></li></ol></li></ul><p>综上，歌曲的请求地址为：<code>https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?format=json&amp;cid=205361747&amp;uin=0&amp;songmid={smid}&amp;filename={filename}&amp;guid={guid}</code></p><p>向这个地址请求后，会得到一个 JSON 格式的数据文件，包含了我们需要的信息：vkey</p><pre><code class="bash">curl &#39;https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?format=json&amp;cid=205361747&amp;uin=0&amp;songmid={smid}&amp;filename={filename}&amp;guid={guid}&#39;{&quot;code&quot;:0,&quot;cid&quot;:205361747,&quot;userip&quot;:&quot;××.××.××.××&quot;,&quot;data&quot;:{&quot;expiration&quot;:80400,&quot;items&quot;:[{&quot;subcode&quot;:104001,&quot;songmid&quot;:&quot;000uhMwj387EBp&quot;,&quot;filename&quot;:&quot;C00000uhMwj387EBp.m4a&quot;,&quot;vkey&quot;:&quot;B6BB8F604606DFDC82FD81CE33BC9C0277365D4B8B1BC8BCC909E408EAC9822315B2B9D021F42B495FA14AADCB598B21BCDB867931B7A953&quot;}]}}</code></pre><p>得到了最重要的 <code>vkey</code> 字段后，就可以解析出歌曲的「真实链接」了：</p><p><code>https://dl.stream.qqmusic.qq.com/{filename}?vkey={vkey}&amp;guid={guid}&amp;uin=0&amp;fromtag=66</code></p><p>你可能注意到返回的信息中还包含了 <code>expiration</code> 字段。是的，<code>vkey</code> 只有在该时间段内才有效，当然这个问题很好解决，可以把该程序部署至服务器，而从服务器发起请求获取链接后 302 至歌曲链接。</p><p>而当我满心欢喜的把这个脚本向服务端部署的时候，却失败了：原因是接口的请求地址只支持国内的（想来是因为 QQ 音乐只拿到了在大陆地区的版权），而我的服务器在美国，这个问题就有些难解决了（我没有国内的服务器）。</p><p>于是我想另辟蹊径。</p><h2 id="纯-JS-解析"><a href="#纯-JS-解析" class="headerlink" title="纯 JS 解析"></a>纯 JS 解析</h2><p>既然服务端无法解析，那就用 JS 在用户端解析。</p><p>但又带来了另一个问题——跨域。</p><p>目前跨域请求比较好的解决方案有两种：CORS 和 JSONP，其中 CORS 需要服务器端设置 <code>Access-Control-Allow-Origin</code>，所以也就只有使用 JSONP 了。</p><blockquote><p>注意：跨域请求失败原因浏览器端阻止显示，并非服务器端无法返回数据</p></blockquote><p>使用 JSONP 时要求服务端返回的是满足 <a href="https://zh.wikipedia.org/wiki/JSONP#%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">JSONP 模式</a>的文件，不能是纯 JSON 文件，举个例子：</p><pre><code class="javascript">var url1 = &quot;https://lab.itswincer.com/jsonp/without-callback.js&quot;;var url2 = &quot;https://lab.itswincer.com/jsonp/with-callback.js&quot;;function foo(data) {    alert(`Hi, I am ${data.name}`);}var script = document.createElement(&#39;script&#39;);script.setAttribute(&#39;src&#39;, url1);document.body.appendChild(script);script.setAttribute(&#39;src&#39;, url2);document.body.appendChild(script);</code></pre><p>其中 <code>without-callback.js</code> 返回的是纯 JS 文件，<code>with-callback.js</code> 返回的是满足模式的 JS 文件。可以运行上面代码看看结果。</p><p>本想直接用现成的 <code>ajax</code>，考虑到并非所有的网站都引入了 jQuery，而为 <code>ajax</code> 就引入一个那么庞大的库又有些没必要。</p><p>于是就自己封装了一个 <code>getJSONP()</code> 接口来搭配 <code>getMusic()</code> 使用。</p><p>项目已开源，具体的代码见<a href="https://github.com/WincerChan/QQMusic-Parse" target="_blank" rel="noopener">这里</a>，有很详细的注释。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>为了使接口更干净，没有使用 callback 函数，而是使用了 ES7 的新特性 async、await。尝试过使用 Babel 等工具转换成兼容更好的 ES5 代码，但是并没有成功，故而浏览器的兼容可能存在问题。</p><p>引入<a href="https://cdn.jsdelivr.net/gh/wincerchan/QQMusic-Parse@0.3/parse.min.js" target="_blank" rel="noopener">这个 JS 文件</a>：</p><p>接口：<code>await getMusic()</code>，如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844981/blog/qqmusic_parse/sample.png" alt="示例"></p><blockquote><p>注意：在调用 getMusic() 的时候一定要加上 await 关键字，否则返回的就是一个 Promise 对象了</p></blockquote><h3 id="配合-Aplayer"><a href="#配合-Aplayer" class="headerlink" title="配合 Aplayer"></a>配合 Aplayer</h3><p>由于使用了 ES7 的新特性：async 和 await，故而 Aplayer 的配置文件也需要稍加改动：需要将原配置信息放至包含 <code>async</code> 关键字的函数内，随后调用这个函数，如下：</p><pre><code class="javascript">async function syncHand() {    new Aplayer(...);}syncHand();</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>越来越认同保罗 · 格雷厄姆那句「黑客就像画家，工作起来是有心理周期的有时候，你有了一个令人兴奋的新项目，你会愿意为它一天工作 16 个小时。等过了这一阵，你又会觉得百无聊赖，对所有事情都提不起兴趣。」话了，简直就是我的写照：这四天大约花费了 30 小时（当然有很大一部分缘由是之前没怎么学过 JavaScript，修改一下别人的代码还行，自己写就有点「捉襟见肘」了），而估计后几天又会陷入「空窗期」了。</p><p>而 JavaScript 又是一门有很多<del>坑爹</del>特性的语言，也让我把初学者的坑基本上都踩完了（还是写 Python 爽）。同时也感觉学习新东西的最好、最快的方法就是实战，换句话说，抱着解决问题的目的去学习所学到的知识远比你抱着单纯学习目的所学的知识要更快、更牢靠。</p>]]></content>
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐解析 </tag>
            
            <tag> Javascript </tag>
            
            <tag> 网易云 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一台 VPS 的正确打开方式</title>
      <link href="/posts/b3085a7/"/>
      <url>/posts/b3085a7/</url>
      <content type="html"><![CDATA[<p>其实像 Hexo 这样的静态博客框架本不需要服务器的，GitHub Pages 就提供免费的托管服务、且不限流量，但内心那点不安分因素总是撩拨着我：比如可以自定防护规则、可以搭建私有 Git 服务、可以搭建自己的 API（这个比较重点）、还能自己搭建 SS 服务，于是乎就买了一台 VPS。<a id="more"></a></p><p>由于我的博客使用了 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare</a> 作为 CDN 服务商，而国内的电信和联通用户是默认解析到 Cloudflare 的美西结点，只有移动用户是解析到香港节点，所以为了 API 的快取速度（即：本机 -&gt; Cloudflare -&gt; VPS -&gt; Cloudflare -&gt; 本机），将服务器选在了洛杉矶，每年 20$、1T 流量、10G 固态、512M 内存，搭建一个静态博客和几个 API 足够了。</p><h2 id="简化-SSH-登录"><a href="#简化-SSH-登录" class="headerlink" title="简化 SSH 登录"></a>简化 SSH 登录</h2><p>SSH 的安全验证有两种级别：</p><ol><li>基于密码：知道帐号和密码，就可以登录到远程主机，这种方式无法避免「中间人」攻击</li><li>基于密钥：创建一对密钥，并把公钥放至服务器，每次通信都会检验密钥，从而可以避免「中间人」攻击</li></ol><p>这里介绍第二种方法。</p><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>如果在使用 GitHub 的时候已经生成过，那么这一步可以略过</p><pre><code class="bash">ssh-keygen                        # 默认生成长度为 2048 位的 RSA 密钥ssh-keygen -b 4096                # 可以通过添加参数 -b 设定长度</code></pre><p>随后就会生成一对密钥，默认为：id_rsa（私钥）、id_rsa.pub（公钥）</p><h3 id="上传至服务器"><a href="#上传至服务器" class="headerlink" title="上传至服务器"></a>上传至服务器</h3><p>使用 ssh-copy-id 命令</p><pre><code class="bash">ssh-copy-id username@server-addr</code></pre><p>需要输入远程服务器的登录密码，随后 id_rsa.pub（公钥）会自动上传至服务器的 <code>~/.ssh/authorized_keys</code> 文件中</p><p>随后再进行 SSH 连接时，就不需要再输入密码了</p><h3 id="简化-IP"><a href="#简化-IP" class="headerlink" title="简化 IP"></a>简化 IP</h3><p>虽不用输入密码，但仍需要输入服务器登录名和 IP 地址，所以需要将配置写入 <code>~/.ssh/config</code> 中：</p><pre><code class="yaml">Host wincer                # 这里填写简化名称  HostName ××.××.××.××    # 服务器 IP  Port 22                # 端口号  User root                # 远程登录用户名</code></pre><p>随后再进行 SSH 连接时，输入 <code>ssh wincer</code> 就可以登录了</p><p><code>scp</code> 命令也可以简化成以下：</p><pre><code class="bash">scp FILENAME wincer:PATH </code></pre><h2 id="作为-GitHub-Pages"><a href="#作为-GitHub-Pages" class="headerlink" title="作为 GitHub Pages"></a>作为 GitHub Pages</h2><p>目前我的博客仍然在<a href="https://github.com/WincerChan/MyBlog" target="_blank" rel="noopener">该仓库</a>的 master 分支上保留有静态文件，仅作备份。</p><h3 id="添加-DNS-记录"><a href="#添加-DNS-记录" class="headerlink" title="添加 DNS 记录"></a>添加 DNS 记录</h3><p>首先为 DNS 解析添加一条 「A 记录」，记录值为 VPS 所分配的 IP</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530857776/blog/vps_open_mode/a_record.png" alt="A 记录"></p><h3 id="更改-Nginx-配置"><a href="#更改-Nginx-配置" class="headerlink" title="更改 Nginx 配置"></a>更改 Nginx 配置</h3><p>SSH 登录后，编辑 Nginx 的配置文件 <code>vim /etc/nginx/nginx.conf</code>：</p><pre><code class="nginx">server {  listen        80;  server_name    blog.itswincer.com;  index         index.html;  root             /data/www/hexo;}</code></pre><p>可部署多个子域名，只需将 <code>server_name</code> 和 <code>root</code> 替换成相应的子域名和文件夹就可以了</p><p>可以先创建一个 <code>index.html</code>  测试一下，访问 <code>blog.itswincer.com</code>  看看是否成功</p><h3 id="加密-CI-配置"><a href="#加密-CI-配置" class="headerlink" title="加密 CI 配置"></a>加密 CI 配置</h3><p>这一步可选，你也可以手动用 <code>scp</code> 命令将每次 <code>hexo g</code> 生成的静态文件上传至服务器，只不过略微麻烦。</p><p>Travis CI 的终端并不能支持用户输入密码，而 GitHub 的 Token 又无法在自己的服务器使用，故而只能采取<a href="#简化 SSH 登录">简化 SSH 登录</a>这步中类似的方法，即用私钥（即 id_rsa）去确认登录的身份，而将私钥公开至 GitHub 又是很危险的，所以我们需要将私钥加密：</p><pre><code class="bash">gem install travis        # 需要安装 gem，自备梯子travis login            # 输入 GitHub 的账户密码travis encrypt-file ~/.ssh/id_rsa --add        # 加密私钥，同时解密命令会添加至 travis.yml</code></pre><p>Travis CI 上的 known_hosts 只添加了 GitHub 下的三个域名，在使用 SSH 登录时，会提示是否添加该主机，同样因为终端无法输入，所以需现将服务器的 IP 与端口号添加至 known_hosts：</p><pre><code class="yaml">addons:  ssh_known_hosts: ××.××.××.××</code></pre><blockquote><p>这里忍不住吐槽一下 Travis CI 的加密：居然无法同时加密两个文件，而官方提供的方法是先把需要加密的文件压缩后加密，再解压。</p></blockquote><h2 id="搭建-API"><a href="#搭建-API" class="headerlink" title="搭建 API"></a>搭建 API</h2><p>Hexo 这类静态博客所需的内存其实是挺少的，只需在后台运行一个 Nginx 进程就可以了，只运行一个 Nginx 进程时用「搬瓦工」的管理面板查看发现一共内存才使用了 40M，才用了不到 10%，所以就想着可以将之前写的「一言」API 放到我的服务器上，毕竟 Heroku 在国内访问还是挺不稳定的。</p><p>之前是用 Python3 写的，后来发现 VPS 自带的 Python 版本居然是 2.7，深知其中坑的我就没打算再用 Python 了，于是就是用 Node.JS 写了一个，本地调试了一下，就扔到服务器上了。第二天早上起来一看，发现内存占用居然到了 110M，一查看原来都是 Node 的占用，其中每一个 API 请求，平均就会多占用 2M 的内存，而且这个请求所占用的内存并不会释放，这样下去怕是没两天服务器就要爆内存了。</p><p>后来我也想过解决办法，比如用 PM2 这个工具来限制运行的内存，超过就重启 Node 环境，也想过定时重启服务器，再转念一想，我是大爷诶，凭啥要我去迁就辣鸡 Node.JS 的内存管理，你不行那我换一个具有垃圾回收的语言不就好了，那就 Java？好像也不太行，毕竟服务器就那么点硬盘，JDK 和 JRE 不知道要占用我多少空间，再者说来毕竟我可是 「Java 黑」。</p><p>那么就归纳一下我的需求：「占用内存小、部署方便、有垃圾回收（不会爆内存）、<del>不要 Java</del>」，然后考虑到编译型程序比解释型程序占用的内存更小，所以也就没考虑 Ruby &amp; Python，满足这些要求的好像也只有 Golang 了。</p><p>写了那么久的动态类型语言，突然要我写静态类型语言还真是有点不适应。在网上找了个例子，自己捣鼓了一个下午，就写出来了，算是一个勉强遵循「RESTful」风格的 API，开始还有日志功能，后来想想没必要，Nginx 也可以监控端口的访问日志，就删去了。</p><p>然后在 Nginx 配置端口</p><pre><code class="nginx">server {  listen        80;  server_name    api.itswincer.com;  location / {    add_header Content-Type &#39;application/javascript&#39;;    proxy_pass http://localhost:520;  }}</code></pre><p>而且 Golang 的部署也是很方便，将 *.go 拷贝就行了。跑了几天，内存占用稳定在 10M 上下。</p><p><a href="https://github.com/WincerChan/hitokoto" target="_blank" rel="noopener">该项目</a>已托管至 GitHub。</p><h2 id="搭建-SS"><a href="#搭建-SS" class="headerlink" title="搭建 SS"></a>搭建 SS</h2><p>搬瓦工的 SS/SSR 搭建可以说是非常的方便了：</p><ol><li>先进入 KiwiVM 面板</li><li>在左侧点击 <code>Shadowsocks Server</code> 按钮</li><li>再点击 <code>install Shadowsocks Server</code> 按钮</li></ol><p>大约半分钟后，会提示已经安装完成：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530857869/blog/vps_open_mode/ss_install.png" alt="安装"></p><p>再点击 <code>Go back</code> 按钮，回到以下界面，再点击 <code>Start</code>：<img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530857945/blog/vps_open_mode/ss_sample.png" alt="配置"></p><p>SS 服务配置完成了，将以上信息填入 SS 客户端即可使用。</p><p>不过由于服务器是在美西，所以无论怎么优化（BBR），延迟都会在 160ms 以上，当然这对浏览网页看视频来说也没有什么影响。</p><blockquote><p>注意：<strong>当你使用 VPS 翻墙时，会同时计算上行、下行流量，也就是说如果翻墙使用 1G 流量，其实等于使用了 VPS 的 2G 流量</strong>。</p></blockquote><h2 id="搭建私有云笔记"><a href="#搭建私有云笔记" class="headerlink" title="搭建私有云笔记"></a>搭建私有云笔记</h2><p>我最近有在思考私有云笔记的必要性，毕竟有了博客，那云笔记的作用可能就鸡肋了一点。但我还是选择了搭建。我的想法是：博客用于存放、发布一些较正式的文章，而笔记可以休闲一点（类似作文和日记的区别）。</p><p>回到正题，目前来说，体验好的云笔记要么需要会员、要么存在诸多功能限制，而我又不想多浪费钱，那么选择一个支持多设备（其实主要是解决手机设备）的同步方案并借助私有的服务器架设自然也就是最好的解决办法了。我选择了 <a href="../bf0413ac/">Nextcloud 作为解决方案</a>，并借助他的 WebDAV 功能作为多端同步工具。</p><p>手机端笔记软件选择的是<a href="https://www.coolapk.com/apk/me.tshine.easymark" target="_blank" rel="noopener">易码</a>，支持 Markdown 语法和 WebDAV 同步，电脑端可以选择直接用浏览器访问 Nextcloud，可以在线 Markdown 编辑和预览，当然也可以选择用 Nextcloud 同步至本地文件夹，并用其它编辑器打开就可以了。</p>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> VPS </tag>
            
            <tag> Nginx </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《黑客与画家》读书笔记</title>
      <link href="/posts/a6c2a51d/"/>
      <url>/posts/a6c2a51d/</url>
      <content type="html"><![CDATA[<p>去年年底那会，花了大概一周多时间，阅读完了《黑客与画家》这本书，收获颇丰。可惜当时确实没多少时间整理出读书笔记，期末考试结束后，回到家中，本想着有时间能好好补一下博客，结果回家之后也没有想象中的空闲，看着「搬瓦工」把每年 20$ 的套餐补货了，于是就购置了一台服务器，将博客源码从 GitHub 上转移到了自己的服务器上，还拿 Golang 重写了一下「一言」的 API（扯远了，服务器的事等以后再开一篇博客说说），还补了一部早已加入想看列表却一直没看的番——「反叛的鲁路修」（嘻嘻 😌）。</p><p>直到今天，才终于有时间能把这篇读书笔记给整理出来了，笔记是直接在 Kindle 上标注的，然后用「<a href="https://www.clippings.io/" target="_blank" rel="noopener">Clippings.io</a>」这个工具导出（为什么 Kindle 不能开发一个好用一点的笔记管理系统呢！？）。</p><p>好在 azw3 版本在 Kindle 上的体验还不错，即使有代码段排版也没有垮掉，所以决定原谅你。</p><p>（👇以下为文摘）</p><hr><ol><li><p>在一个人产生良知之前，折磨就是一种娱乐。</p></li><li><p>程序写出来是给人看的，附带能在机器上运行。（这句话的出处是在《SICP》这本书的卷首语，作者引用了）</p></li><li><p>如果有必要的话，大多数物理学家有能力拿到法国文学的博士学位，但是反过来就不行，很少存在法国文学的教授有能力拿到物理学的博士学位。</p></li><li><p>人们喜欢讨论的许多问题实际上都是很复杂的，马上说出你的想法对你并没有什么好处。</p></li><li><p>小时候，每个人都会鼓励你不断成长，变成一个心智成熟、不再耍小孩子脾气的人。但是，很少有人鼓励你继续成长，变成一个怀疑和抵制社会错误潮流的人。<br>如果自己就是潮水的一部分，怎么能看见潮流的方向呢？你只能永远保持质疑。</p></li><li><p>不服从管教，其实是黑客之所以成为优秀程序员的原因之一。</p></li><li><p>公民自由并不仅仅是社会制度的装饰品，或者一种很古老的传统。公民自由使得国家富强。</p></li><li><p>经济学里有一条拉弗曲线（Laffer curve），认为随着税率的上升，税收收入会先增加后减少。我认为政府的力量也是如此，随着对公民自由的限制不断上升，政府的力量会先增加后减小。</p></li><li><p>极权主义制度只要形成了，就很难废除。（咳咳）</p></li><li><p>一定数量的盗版对软件公司是有好处的。不管你的软件定价多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并没有任何损失。事实上，你反而赚到了，因为你的软件现在多了一个用户，市场影响力就更大了一些，而这个用户可能毕业以后就会出钱购买你的软件。</p></li><li><p>首先，管理企业其实很简单，只要记住两点就可以了：做出用户喜欢的产品，保证开支小于收入。</p></li><li><p>一个大学毕业生总是想「我需要一份工作」，别人也是这么对他说的，好像变成某个组织的成员是一件多么重要的事情。更直接的表达方式应该是「你需要去做一些人们需要的东西」。即使不加入公司，你也能做到。公司不过是一群人在一起工作，共同做出某种人们需要的东西。真正重要的是做出人们需要的东西，而不是加入某个公司。</p></li><li><p>要鼓励大家去创业。只要懂得藏富于民，国家就会变得强大。让书呆子保住他们的血汗钱，你就会无敌于天下。</p></li><li><p>财富是用工作成果衡量的，而不是用它花费的成本衡量的。如果我用牙刷油漆房屋，屋主也不会付给我额外工资的。</p></li><li><p>好设计是艰苦的设计。如果观察那些做出伟大作品的人，你会发现他们的共同点就是工作得非常艰苦。如果你工作得不艰苦，你可能正在浪费时间。</p></li><li><p>并非所有的痛苦都是有益的。世界上有有益的痛苦，也有无益的痛苦。你需要的是咬牙向前沖刺的痛苦，而不是脚被钉子扎破的痛苦。解决难题的痛苦对设计师有好处，但是对付挑剔的客户的痛苦或者对付质量低劣的建材的痛苦就是另外一回事了。</p></li><li><p>等到你逐渐对一件事产生热情的时候，就不会满足于模仿了。</p></li><li><p>「你用什么语言并不重要，重要的是你对问题是否有正确的理解。代码以外的东西才是关键。」这当然是一派胡言。各种语言简直是天差地别。</p></li><li><p>语言设计者之间的最大分歧也许就在于，有些人认为编程语言应该防止程序员干蠢事，另一些人则认为程序员应该可以用编程语言干一切他们想干的事。</p></li><li><p>允许你做某事的语言肯定不差于强迫你做某事的语言。</p></li><li><p>它们（指某些语言）的内核设计得并非很好，但是却有着无数强大的函数库，可以用来解决特定的问题。（你可以想象一辆本身性能很差的小汽车，车顶却绑着一个飞机发动机。）有一些很琐碎、很普遍的问题，程序员本来要花大量时间来解决，但是有了这些函数库以后，解决起来就变得很容易，所以这些库本身可能比核心的语言还要重要。所以，这些奇特组合的语言还是蛮有用的，一时间变得相当流行。车顶上绑着飞机发动机的小车也许真能开，只要你不尝试拐弯，可能就不会出问题。（内心 OS：我可没有针对 C++ 😏）</p></li><li><p>当我说 Java 不会成功时，我的意思是它和 Cobol 一样，进化之路已经走到了尽头。</p></li><li><p>如果摩尔定律依然成立，一百年后计算机的运行速度将是现在的 74 乘以 10 的 18 次方倍（准确地说是 73 786 976 294 838 206 464 倍）。</p></li><li><p>即使最后只是略微快了 100 万倍，也将实质性地改变编程的基本规则。如果其他条件不变，现在被认为运行速度慢的语言（即运行的效率不高）将来会有更大的发展空间。</p></li><li><p>效率低下的软件并不等于很烂的软件。一种让程序员做无用功的语言才真正称得上很烂。</p></li><li><p>自下而上的编程方法意味着要把软件分成好几层，每一层都可以充当它上面那一层的开发语言。这种方法往往会产生更小、更灵活的程序。它也是通往软件圣杯——可重用性（reusability）——的最佳路线。</p></li><li><p>罗伯特·莫里斯和我都很了解 Lisp 语言，我们相信自己的直觉，找不出任何不使用它的理由。我们知道其他人都用 C++ 或 Perl 开发软件，但是我们不觉得这说明了什么问题。如果别人用什么技术，你也用什么技术，那么你大概只能使用 Windows 了（日常黑 Windows）。</p></li><li><p>编程语言的特点之一就是它会使得大多数使用它的人满足于现状，不想改用其他语言。</p></li><li><p>如果从图灵等价（Turing-equivalent）的角度来看，所有语言都是一样强大的，但是这对程序员没有意义。</p></li><li><p>最不用担心的竞争对手就是那些要求应聘者具有 Oracle 数据库经验的公司，你永远不必担心他们。如果是招聘 C++ 或 Java 程序员的公司，对你也不会构成威胁。如果他们招聘 Perl 或 Python 程序员，就稍微有点威胁了。至少这听起来像一家技术公司，并且由黑客控制。如果我有幸见到一家招聘 Lisp 黑客的公司，就会真的感到如临大敌。</p></li><li><p>你的经理其实不关心公司是否真的能获得成功，他真正关心的是不承担决策失败的责任。</p></li><li><p>黑客欣赏的一个特点就是简洁。黑客都是懒人，他们同数学家和现代主义建筑师一样，痛恨任何冗余的东西或事情。</p></li><li><p>简洁性是静态类型语言的力所不及之处。只要计算机可以自己推断出来的事情，都应该让计算机自己去推断。举例来说，hello-world 本应该是一个很简单的程序，但是在 Java 语言中却要写上一大堆东西，这本身就差不多可以说明 Java 语言设计得有问题了。</p><pre><code class="java">public class Hello {  public static void main(String[] args) {    System.out.println(&quot;Hello, world!&quot;);  }}</code></pre><p>如果你从来没没有接触过编程，看到上面的代码可能会很奇怪，让计算机显示一句话为什么要搞得这么复杂？有意思的是，资深程序员的反应与你一样。</p></li><li><p>语言设计者应该假定他们的目标用户是一个天才，会做出各种他们无法预知的举动，而不是假定目标用户是一个笨手笨脚的傻瓜，需要别人的保护才不会伤到自己。如果用户真的是傻瓜，不管你怎么保护他，他还是会搬起石头砸自己的脚。</p></li><li><p>对黑客来说，选择编程语言的时候，还有一个因素比简洁更重要，那就是这种语言必须能够帮助自己做到想做的事。</p></li></ol><p>（👇以下为简评）</p><hr><p>这本书算是我从去年 7 月以来看完的第一本书了（《计算机程序的构造和解释》这本书太难了，看了前两章就没时间看，到还书的日期了），主要也在于作者 Paul Graham 的行文十分流畅，阮一峰的翻译也很到位，没有什么阅读障碍，还有「读至好几处都有一拍大腿，哎呀妈呀我也是这么想的啊」的想法，读完之后，思想也似乎豁然开朗了些。</p><p>关于第六章——「如何创造财富」，财富的获得是看你最终的结果，不是看你的付出（过程）。你做出了别人需要的产品，没人在乎你是做了三天还是三十天，他并不会因为你只做了三天就完成而少付给你报酬，更不会因为你是三十天完成而多给你报酬。还有关于「财富并不是固定不变的」这个理论，他给出了一个例子：你拥有一辆老爷车，你可以不去管它，也可以自己动手把它修葺一新这样的话，你就创造了财富：世界上因此多了一辆新的车，财富就变得多了一点，如果你把车卖掉，你得到的卖车款就会比以前更多，与此同时，你并没有使任何人变得更贫穷。正因为这个理由，他也建议我们多多创业，但也给我们泼了一盆「凉水」：创业的付出与回报总体上是成比例的，但是在个体上是不成比例的，不要把创业过于神话，但创业的确给了我们更多的可能。</p><p>还有就是关于编程语言的争论，作者似乎和我一样很喜欢黑 Java，认为 Java 是「进化之路已经走到了尽头」，因为编程语言并不应该限制程序员去做某些事情，即使这些事情是有害的。同时也抛出了另一个很新颖的说法：关于一百年以后，我们该使用什么样的编程语言？按照摩尔定律：预计 18 个月会将芯片的性能提高一倍，那时候电脑的运行速度将是现在的 73 786 976 294 838 206 464 倍，所以他认为现在某些因为运行速度略慢但编程起来更舒服的语言在未来反而是主流，即有更大的发展空间，同时作者似乎很推崇动态类型语言，因为写起来比静态类型语言方便、看起来也比较简洁。作者也不止一次的推崇了 Lisp，甚至不惜黑 Oracle 数据库、C++、Java（见上面第 30 条）。</p><p>最后，这本书算是 Paul Graham 的一本随笔文集，其中自然充斥着许多作者的价值观，如果这些价值观与你的价值观符合，那么你就会像「捡到宝」一样的对待这本书，反之，你会认为这本书的观点完全是和「邪教信条」一般，很庆幸，我是前者。</p><hr><p>处于马上步入社会的我啊，在迷茫的时候，不妨也多阅读几本好书。</p>]]></content>
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 黑客与画家 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>豆瓣电影 Top 250 数据分析</title>
      <link href="/posts/7a8186a0/"/>
      <url>/posts/7a8186a0/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间忙于备考，博客有段时间没更新了。其实早就有写这篇博客的想法了，原因嘛——我是比较喜欢看电影的，而且近来也对数据分析颇感兴趣，于是花了一天时间，先是爬取数据，再分析整理，数据可视化。<br><a id="more"></a></p><p>其实豆瓣对爬虫的防范算是比较高级了，即使伪造了 Cookie，还是会封禁 IP（还好我的代理 IP 多😏），甚至还会把你的帐号暂时冻结，其实要不是有一些电影词条必须登录才可见，也不用伪造 Cookie 这么麻烦。</p><h2 id="爬取"><a href="#爬取" class="headerlink" title="爬取"></a>爬取</h2><p>之前爬取都是用的正则匹配，这次首次接触了「<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">Beautiful Soup</a>」这个库，相见恨晚啊，不多说，先上代码：</p><pre><code class="python">def get_info(url):    movie = {}    proxies = {&#39;https&#39;: &quot;socks5://127.0.0.1:1080&quot;}    info = get(url, cookies=read_cookie(), proxies=proxies).text    soup = BeautifulSoup(info)    try:        # get movie name        name = soup.find(property=&#39;v:itemreviewed&#39;).get_text()        movie[&#39;name&#39;] = name.split(&#39; &#39;)[0]        # get movie year        year = soup.find(class_=&#39;year&#39;).get_text()        movie[&#39;year&#39;] = year[1:-1]        # get movie info        info = soup.find(id=&#39;info&#39;).get_text().replace(&#39; &#39;, &#39;&#39;).split(&#39;\n&#39;)        info = [x for x in info if x is not &#39;&#39;]        for item in info:            if &#39;导演:&#39; in item:                movie[&#39;director&#39;] = item[3:].split(&#39;/&#39;)            if &#39;主演:&#39; in item:                movie[&#39;actors&#39;] = item[3:].split(&#39;/&#39;)            if &#39;类型:&#39; in item:                movie[&#39;type&#39;] = item[3:].split(&#39;/&#39;)            if &#39;国家/地区:&#39; in item:                movie[&#39;region&#39;] = item[8:].split(&#39;/&#39;)            if &#39;语言:&#39; in item:                movie[&#39;language&#39;] = item[3:].split(&#39;/&#39;)            if &#39;片长:&#39; in item:                time = [                    search(r&#39;[\d]*&#39;, x).group() for x in item[3:].split(&#39;/&#39;)                ]                movie[&#39;time&#39;] = sorted(time, reverse=True)[0]        # get top250 info        movie[&#39;rank&#39;] = soup.find(class_=&#39;top250-no&#39;).get_text()        movie[&#39;number&#39;] = soup.find(property=&#39;v:votes&#39;).get_text()    except Exception as e:        print(e)    return movie</code></pre><p>其中片长取得是无删减版的片长，即不同版本中最长的。</p><p>地区、导演、语言等由于会出现多项内容，采取列表存放。</p><p><strong>以下统计数据截止至 2018/01/20</strong></p><h2 id="导演"><a href="#导演" class="headerlink" title="导演"></a>导演</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858719/blog/douban_movie_analytics/director.png" alt="电影导演统计"></p><p>其中由「宫崎骏」和「克里斯托弗·诺兰」贡献最多，均为 7 部，具体为：</p><p>宫崎骏（日本）：</p><ul><li>《千与千寻》，上映年份为「2001」，排名为 No.6</li><li>《龙猫》，上映年份为「1988」，排名为 No.17</li><li>《天空之城》，上映年份为「1986」，排名为 No.33</li><li>《哈尔的移动城堡》，上映年份为「2004」，排名为 No.45</li><li>《幽灵公主》，上映年份为「1997」，排名为 No.80</li><li>《风之谷》，上映年份为「1984」，排名为 No.106</li><li>《魔女宅急便》，上映年份为「1989」，排名为 No.189</li></ul><p>克里斯托弗·诺兰（英国）：</p><ul><li>《盗梦空间》，上映年份为「2010」，排名为 No.9</li><li>《星际穿越》，上映年份为「2014」，排名为 No.25</li><li>《蝙蝠侠：黑暗骑士》，上映年份为「2008」，排名为 No.32</li><li>《致命魔术》，上映年份为「2006」，排名为 No.61</li><li>《记忆碎片》，上映年份为「2000」，排名为 No.132</li><li>《蝙蝠侠：黑暗骑士崛起》，上映年份为「2012」，排名为 No.168</li><li>《追随》，上映年份为「1998」，排名为 No.170</li></ul><h2 id="演员"><a href="#演员" class="headerlink" title="演员"></a>演员</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858744/blog/douban_movie_analytics/actor.png" alt="电影演员统计"></p><p>其中由「张国荣」贡献最多（前三居然都是香港地区的演员），有 8 部，分别是：</p><ul><li>《霸王别姬》，导演为「陈凯歌」，上映年份为「1993」，排名为 No.2</li><li>《春光乍泄》，导演为「王家卫」，上映年份为「1997」，排名为 No.77</li><li>《射雕英雄传之东成西就》，导演为「刘镇伟」，上映年份为「1993」，排名为 No.88</li><li>《倩女幽魂》，导演为「程小东」，上映年份为「1987」，排名为 No.113</li><li>《东邪西毒》，导演为「王家卫」，上映年份为「1994」，排名为 No.131</li><li>《英雄本色》，导演为「吴宇森」，上映年份为「1986」，排名为 No.140</li><li>《纵横四海》，导演为「吴宇森」，上映年份为「1991」，排名为 No.149</li><li>《阿飞正传》，导演为「王家卫」，上映年份为「1990」，排名为 No.183</li></ul><h2 id="地区"><a href="#地区" class="headerlink" title="地区"></a>地区</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858784/blog/douban_movie_analytics/region.png" alt="电影地区统计"></p><p>其中「美国」地区一枝独秀，超过半数以上电影的制片地区均为「美国」，且远超第二名「英国」。</p><ul><li>美国：140 部</li><li>英国：34 部</li><li>日本：32 部</li><li>香港：26 部</li><li>法国：26 部</li><li>德国：20 部</li><li>中国大陆：16 部</li></ul><h2 id="片长"><a href="#片长" class="headerlink" title="片长"></a>片长</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858819/blog/douban_movie_analytics/length.png" alt="电影片长"></p><table><thead><tr><th>统计名称</th><th>数值</th></tr></thead><tbody><tr><td>中位数</td><td>118.0</td></tr><tr><td>均值</td><td>124.0</td></tr><tr><td>众数</td><td>98.0（10 次）</td></tr><tr><td>标准差</td><td>34.1</td></tr><tr><td>极差</td><td>218.0</td></tr></tbody></table><p>其中片长最长的电影为《指环王3：王者无敌》，导演是「彼得·杰克逊」，片长为 263 mins，排名是 No.30。</p><p>其中片长最短的电影为《萤火之森》，导演是「大森贵弘」，片长为 45 mins，排名是 No.150。</p><h2 id="年份"><a href="#年份" class="headerlink" title="年份"></a>年份</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858844/blog/douban_movie_analytics/years.png" alt="电影年份"></p><table><thead><tr><th>统计名称</th><th>数值</th></tr></thead><tbody><tr><td>中位数</td><td>2002.0</td></tr><tr><td>均值</td><td>1998.6</td></tr><tr><td>众数</td><td>2004（13 次）</td></tr><tr><td>标准差</td><td>15.6</td></tr><tr><td>极差</td><td>85</td></tr></tbody></table><p>其中距今最久远的电影是《城市之光》，导演是「查理·卓别林」，年份为 1931 年，排名是 No.210。</p><p>其中距今最接近的电影有 5 部，均为 2016 年上映：</p><ul><li>《疯狂动物城》，导演是「拜伦·霍华德」等，制片国家为「美国」，排名为 No.43</li><li>《看不见的客人》，导演是「奥里奥尔·保罗」，制片国家为「西班牙」，排名为 No.83</li><li>《摔跤吧！爸爸》，导演是「涅提·蒂瓦里」，制片国家为「印度」，排名为 No.104</li><li>《海边的曼彻斯特》，导演是「肯尼思·洛纳根」，制片国家为「美国」，排名为 No.151</li><li>《你的名字。》，导演是「新海诚」，制片国家为「日本」，排名为 No.245</li></ul><p>嘿嘿，没想到吧，贡献电影最多的年份并不是「Top 250」前四名中有三部的 1994 年，而是 2004 年。</p><h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858864/blog/douban_movie_analytics/grade.png" alt="电影评分统计"></p><table><thead><tr><th>统计名称</th><th>数值</th></tr></thead><tbody><tr><td>中位数</td><td>8.70</td></tr><tr><td>均值</td><td>8.78</td></tr><tr><td>众数</td><td>8.7（44 次）</td></tr><tr><td>标准差</td><td>0.27</td></tr><tr><td>极差</td><td>1.40</td></tr></tbody></table><p>其中最高分为 9.6 分，为两部电影所获得：</p><ul><li>《肖申克的救赎》，导演为「弗兰克·德拉邦特」，评分人数为 952814 人，排名为 No.1</li><li>《控方证人》，导演为「比利·怀尔德」，评分人数为 99908 人，排名为 No.41</li></ul><p>其中评分最低的电影为《疯狂的石头》，分数是 8.2 分，导演为「宁浩」，评分人数为 312083 人，排名为 No.230</p><p>可以看出豆瓣在进行「Top 250」排名时，并不是仅看评分，其中评分人数也占了很大的一部分比重，且似乎还有一些其它的因素，比如《血战钢锯岭》这部电影，评分 8.7，评分人数为 310624 人，却并没有上榜，同为评分 8.7，评分人数为 314940 的电影《看不见的客人》排名却早已进前百（No.83）。</p><p>最后，本人并非专业电影人士，无法针对以上数据提出建设性的建议，所做统计也仅仅是出于爱好，也愿自己能在闲暇时间里，多看几部电影。</p>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 豆瓣 </tag>
            
            <tag> 电影 </tag>
            
            <tag> 数据 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>再见，2017</title>
      <link href="/posts/5873b0c0/"/>
      <url>/posts/5873b0c0/</url>
      <content type="html"><![CDATA[<p><div id="aplayer1" class="aplayer" title="u4" author="Capo Productions" url="001RjIc40vapmG" pic="https://p1.music.126.net/f2VOlJsKhocM3DPba4SLXA==/6625657069970131.jpg?param=130y130" lrc="../../about/lrc/pure.lrc"></div><br>关于 2017 年，其实还真的有挺多想说的，也早就有想写一篇博客的想法了，差不多到今天才抽得出时间写。</p><p>前几天和朋友聊天时谈到关于今年最有成就感的一件事，我想了一会，应该是搭建了这样一个博客。<a id="more"></a><br>当初搭建博客的初衷其实很单纯：就是为了好玩，谁知从此就沉迷于此了。在之后的写博客的过程中甚至产生了一种当一个作家也还不错的想法（当然前提是我的文章还有人看😋），现在想想，与高中时期相比，我的想法是发生了一些转变（在高中时期的我是绝不可能产生这种想法的）。正如开始所说的，现在遇到点什么事就想写下来，在往年，我一直没有写年末总结的习惯。这种「创作欲」，类似作家：将自己内心的想法写成作品，实则是把自己的内心剖析给别人看。也渐渐有些明白卡尔·雅斯贝尔斯的那句「文学和科学相比，的确没什么用处，但文学最大的用处，也许就是它没有用处」的意思了。</p><hr><p>买了 kpw3 后，我很乐意培养自己的阅读习惯。大学时间其实还是比较宽松的，但我反而不能每天抽出一小时阅读时间。有时候看书没看两分钟，随便手机一个通知消息就能让我转移注意力——这也是我的缺点：当自己没有全神贯注的时候，很容易被其它的事情所吸引注意力（这也算我很迫切想改掉的一个坏习惯），也导致看了近两周才把《黑客与画家》这本书看完（书推过两天会补上）。</p><p>是太浮躁了，也太焦虑了，或许是因为到了大三，面临找工作的压力，这压力不仅体现在看书上，有时我就莫名想快些完成正在做的事情，后来多次发现快速完成的事情必然是敷衍的，而事后一旦想起这件「敷衍」的事情，会更加浮躁。其实这样并不好，道理古人都说给我们听了：「欲速则不达」，以后我会尽量放慢自己做事情的速度，投入自己的内心，问问自己真正想要的是什么。</p><hr><p>今年有过一段恋情，对我产生了一些影响，有好，也有坏，让我成长了许多，也意识到了自己的不足。是的，一段感情之后一定会让你成长的。我在这个过程中有开心、难过、有挂念一个人，甚至有些「病态」的想法——不论好坏，这些特殊的情感都是之前没有体会过的。</p><p>恋爱的时候，双方的关系一定需要去协商、磨合，这也会让你学会更好的与人沟通，同时你会发现有些问题如果脱离恋爱范围的话根本就不是问题。在一段恋情过后，我们获得的不仅仅是恋情，还有更好的、获得了成长的自己。你会更了解自己，也更了解你需要找一个什么样的人。</p><p>要有自己的生活，要坚持做自己。要学会去爱，但要先学会爱自己。</p><hr><p>接下来说说工作。</p><p>其实我很反感工作——即学校安排给你作为学生所必须学习的课程，所以这学期的课我基本没怎么去，因为去了我也不会听：我无法强迫自己去听那些完全没有兴趣的课程，那有点像是别人强迫要你去做的事情，我天生是一个「猫型人格」（即：你让我向左转，我会不由自主的向右转，同时心里还有一点歉疚），所以有些不由自主地抗拒。</p><p>在<a href="../11ab0263/">之前写的那篇文章</a>中就说到，我想更加追随自己内心的意愿去活着。具体到工作的说法就是：我想开始「不以找到工作为目的的学习」，学习自然指的是编程。</p><blockquote><p>编程这么有趣的事，竟然还有钱赚      ——by c++ 之父</p></blockquote><p>我喜欢编程，我愿意将自己的时间花费在上面做一些有趣的小程序，即使这在旁人看来对以后的工作没有什么帮助，我不想抱着太强的目的性、太多的功利心去学习，因为这样，会让学习变味。同时我也乐于看着指尖下的一串串字符到显示器上显示出成果，会有一种小小的满足感。</p><hr><p>最后，小小说一下对 2018 年的展望（这绝对不是 FLAG！）</p><ul><li>希望继续读书的习惯</li><li>希望做事情的时候更专注</li><li>希望能多吃水果、生活作息规律</li><li>希望学会使用 To-Do list（如果能有效治愈我的拖延症的话）</li></ul>]]></content>
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从 GnuPG 的使用谈谈密码学</title>
      <link href="/posts/4aa5d46d/"/>
      <url>/posts/4aa5d46d/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我是一个很注重隐私的人，所以对密码学也就很感兴趣，这学期本着想进一步了解密码学的念头选了一门应用密码学的选修课（其实是为了混学分），虽说也没去过几次，但总想着这门课都快结束了总不能像没上过一样。这次借着 GnuPG（以下简称 GPG） 软件的使用也聊聊目前现代密码学中以密钥性质进行区分的两大加密方式。</p><a id="more"></a><h2 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h2><p>大概半年前，写过一个暴力破解加密压缩文件的程序，说白了就是跑字典，不断的试密码，这只能破解常用密码，一旦用户采用随机生成的密码就无从下手。我们平时所用到的压缩加密大多都是对称性加密，即我们用同一字符串对文件进行加密，又用同一字符串进行解密（此时为了保证安全，密码需越复杂越好）。</p><blockquote><p>明文 &lt;–> 密钥 &lt;–> 密文</p></blockquote><p>对称加密很方便也很快速，但是也带来了一个很大的缺点，由于加密和解密用的都是同一密钥，在传输的过程中，要求双方取得相同的密钥，这会大大降低加密的安全性（注意：这里所说的不安全不是说对称加密算法不安全，而是从密钥的获取程度来说的，即密钥知道的人越少越安全）。</p><p>在如今的互联网时代，通信双方分隔异地且素为谋面，则对称加密要求事先交换共同密钥的安全性也无法得到保障。</p><h2 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h2><p>那么为了解决对称加密的安全隐患，非对称加密诞生了。<br>与对称加密不同的是，非对称加密的加密和解密所需要的密钥是不同的，而且知道了其中一方，想推导出另一方（需要解决一个数学难题），在量子计算机时代来临之前，基本是不可能完成的。<br>因此公开其中一个密钥，并不会对密钥对的安全性有影响。<br>我们常说，公钥可以公开，私钥需要保密，但其实公钥和私钥在生成过程上，并无什么不同。并不是因为公钥公开后，解密出私钥困难，如果公开的是私钥，解密出公钥也同样困难。也就是说我们将一对密钥公开的那部分叫公钥，另一部分叫做私钥。并不是因为公钥，才能公开，私钥，就必须保密。</p><blockquote><p>明文 &lt;–> 公钥 &lt;–> 密文 &lt;–> 私钥 &lt;–> 明文</p></blockquote><p>前一段时间很火的勒索病毒就是采用的非对称加密中的 RSA-4096 加密算法。<br>想具体了解 RSA 加密原理的话，<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">点击这里</a>。<br>由于公钥加密在计算上相当复杂，导致其加密速度相对于对称加密来说慢。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>其中对称加密还有一个用处：数字签名。<br>对称加密的公钥和私钥在使用顺序上并没有什么要求，你可以用公钥加密，私钥解密，这就是非对称加密算法，同样可以用私钥加密，公钥解密，而这就成为数字签名。<br>由于私钥是发送者保存的，发送者用私钥加密后的信息，任何拥有该发送者的公钥的人都可以解密该信息。如果接收用发送者公开的公钥解开了，那么说明这个信息是确实是发送者发送的（没有被篡改，也不是伪造的）。公众也可以信赖这条信息确实来自与该用户，用户无法否认。</p><p>一般来说，不直接对消息进行签名，而是对消息的哈希值进行签名，并将签名附赠在消息一起发送。</p><p>总结一下二者的优点与缺点：</p><ul><li>对称密钥加密（使用最广泛的 AES）：加解密速度很快，强度也足够，但问题在于寻找一个安全通道让通信双方交换密钥很困难</li><li>公开密钥加密（使用最广泛的 RSA）：加解密速度很慢，但可以解决通信双方安全通道的问题</li></ul><p>故现在多将二者结合使用：需要加密的主体内容使用对称加密，对称加密的密钥使用非对称加密。</p><h2 id="GPG-教程"><a href="#GPG-教程" class="headerlink" title="GPG 教程"></a>GPG 教程</h2><p>下面说说如何使用 GPG 软件加密文件。</p><p>GPG 支持的算法有很多：</p><blockquote><p>公钥：RSA, ELG, DSA, ECDH, ECDSA, EDDSA</p><p>对称加密：IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256,</p><p>​     TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256</p><p>散列：SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224</p><p>压缩：不压缩，ZIP，ZLIB，BZIP2</p></blockquote><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>使用对称加密很简单，只需要一行就可以：</p><pre><code class="bash">gpg --cipher-algo [对称加密算法名称] -c FILENAME</code></pre><p>随后会让你输入两次密码，就会生成一个 FILENAME.gpg 的文件在同目录下。</p><p>解密：</p><pre><code class="bash">gpg -o FILENAME -d FILENAME.gpg</code></pre><p>更多参数请输入 <code>gpg -h</code> 自行查阅。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>（这里如果输入的是 <code>--gen-key</code> 的话，会省去一些步骤：自动设置密钥尺寸为 2048 位、有效期限为 2 年、注释留空）：</p><pre><code class="bash">gpg --full-generate-key</code></pre><p>回车后，出现以下文字：</p><pre><code class="bash">gpg (GnuPG) 2.2.3; Copyright (C) 2017 Free Software Foundation, Inc.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.请选择您要使用的密钥种类：   (1) RSA and RSA (default)   (2) DSA and Elgamal   (3) DSA (仅用于签名)   (4) RSA (仅用于签名)您的选择？ </code></pre><p>选择 1：</p><pre><code class="bash">RSA 密钥长度应在 1024 位与 4096 位之间。您想要用多大的密钥尺寸？(2048)</code></pre><p>选择 4096：</p><pre><code class="bash">请设定这把密钥的有效期限。         0 = 密钥永不过期      &lt;n&gt;  = 密钥在 n 天后过期      &lt;n&gt;w = 密钥在 n 周后过期      &lt;n&gt;m = 密钥在 n 月后过期      &lt;n&gt;y = 密钥在 n 年后过期密钥的有效期限是？(0) </code></pre><p>如果想设置 5 年过期，输入 5y，我这里是自己私人用，选择 0，随后会让你确认以上信息正确与否，输入 y，系统会要求你提供一下个人信息：</p><pre><code class="bash">You need a user ID to identify your key; the software constructs the user IDfrom the Real Name, Comment and Email Address in this form:    &quot;Heinrich Heine (Der Dichter) &lt;heinrichh#duesseldorf.de&gt;&quot;真实姓名：电子邮件地址：注释：</code></pre><p>注释这一栏可以留空。</p><p>随后：</p><pre><code class="bash">您选定了这个用户标识：    &quot;×××××× &lt;××@×××.com&gt;&quot;更改姓名(N)、注释(C)、电子邮件地址(E)或确定(O)/退出(Q)？</code></pre><p>输入 o，会弹框提示设置一个密码，用于保护私钥。</p><p>与此同时，系统也会提示：</p><pre><code class="bash">我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。</code></pre><p>几秒后，系统就会提示密钥已经生成。</p><h4 id="导出密钥"><a href="#导出密钥" class="headerlink" title="导出密钥"></a>导出密钥</h4><p>显示系统的私钥：</p><pre><code class="bash">gpg -K</code></pre><p>显示系统的公钥：</p><pre><code class="bash">gpg -k</code></pre><p>删除密钥：</p><pre><code class="bash">gpg --delete-keys [uid]gpg --delete-secret-keys [uid]</code></pre><p>其中 uid 可以使用邮箱代替，下同。</p><p>导出公钥：</p><pre><code class="bash">gpg -o public.key --export [uid]</code></pre><p>导出私钥：</p><pre><code class="bash">gpg -o private.key --export-secret-keys</code></pre><p>这样导出的 key 文件是二进制，不可读，加上 –armor 参数可以保存为 ASCII 码形式。</p><p>导入密钥：</p><pre><code class="bash">gpg --import [key 文件]</code></pre><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><pre><code class="bash">gpg -r [uid] -o FILENAME.gpg -e FILENAME</code></pre><p>-r 指定用户的公钥，如自己使用改为自己邮箱即可，-o 指定加密后输出文件名称。</p><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><pre><code class="bash">gpg -o FILENAME -d FILENAME.gpg</code></pre><p>会让你输入密码，即用于保护私钥的密码。</p><p>参考：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">公开密钥加密</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">GPG 入门教程</a></li></ul>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> GPG </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web 性能优化（一）——使用 localStorage</title>
      <link href="/posts/a9d193c6/"/>
      <url>/posts/a9d193c6/</url>
      <content type="html"><![CDATA[<h2 id="localStorage-的意义"><a href="#localStorage-的意义" class="headerlink" title="localStorage 的意义"></a>localStorage 的意义</h2><p>为了针对我的网站提供更好的浏览体验（或者说更接近原生 App 的用户体验），在之前我就已经<a href="https://itswincer.com/posts/a0df572f/" target="_blank" rel="noopener">开启了 Server Worker 技术</a>，针对离线或者网速慢的情况下改善用户体验。但只有少数几个浏览器支持 （Chrome、Firefox、Opera），对目前手机端用户数最多的 QQ 浏览器、UC 浏览器却没有支持，也就是说该方法针对 QQ 浏览器和 UC 浏览器并没有什么实际优化。</p><a id="more"></a><p>而且对于 Server Worker，它并不能减少你的 HTTP 连接数量，只是拦截你的请求，减少 Stalled、Request sent 和 TTFB 的时间，见下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530845454/blog/web_optimization1/contrast.png" alt="左边从 SW 加载，右边正常加载" title="左边从 SW 加载，右边正常加载"></p><p>针对以上两个问题，本博客采用另一种 HTML5 新技术 —— local Storage。</p><h2 id="localStorage-简介"><a href="#localStorage-简介" class="headerlink" title="localStorage 简介"></a>localStorage 简介</h2><p>localStorage 是在 HTML5 中新引进的一项存储技术，（如果不被清除）存储没有时间限制，但是有大小限制，一般对于每个域名是 5MB，对于存储一些纯字符串脚本，足够了。且目前所有主流浏览器均支持此项技术。</p><p>但是需要注意，SW 是可以将所有的 HTTP 请求全部拦截，无论服务器的 Response Headers 中的 Content-Type 是什么类型都可以拦截从本地加载。而 localStorage 仅能存储静态资源（JS/CSS）。</p><p>而存储在 localStorage 的中的静态资源所带来的优点就在于再次加载时不需要发起 HTTP 请求（Queueing、Stalled、Request sent、TTFB、Content Download 这些都不需要），这可以大大改善不支持 SW 技术的浏览器在访问我网站时的浏览体验。</p><h2 id="本博客的实践"><a href="#本博客的实践" class="headerlink" title="本博客的实践"></a>本博客的实践</h2><p>本博客采用的是 <a href="https://github.com/addyosmani/basket.js/" target="_blank" rel="noopener">basket.js</a> 方案，将 js 和 css 存储在 localStorage 中，利用 localStorage 的特性，减少 HTTP 连接的次数，以达到改善页面加载体验的目的。</p><p>为了避免每次刷新页面 main.css 加载先后页面出现抖动的问题，默认不将 main.css 放入 localStorage 中存储。</p><p>另一个问题是 NexT 在设计之初就很依赖于 js（会加载大量的 js 文件），而这些 js 文件的加载顺序是有要求的，jquery 必须优先被加载，否则就会出现奇怪的 bug，好在 basket.js 提供了控制加载先后顺序的方案。</p><h2 id="危险性"><a href="#危险性" class="headerlink" title="危险性"></a>危险性</h2><p>在<a href="https://www.zhihu.com/question/28467444" target="_blank" rel="noopener">这篇知乎回答</a>中，很详细的列出了 localStorage 的优点和缺点。</p><p>其中最危险的是网站出现 xss 漏洞，就会被人利用将恶意代码注入到 localStorage 中，导致即便修复了 xss 漏洞存储的代码依然是被篡改的。</p><p>好在 basket.js 可以提供将 localStorage 中的代码重新从网络加载的问题。具体见<a href="https://addyosmani.com/basket.js/" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> localStorage </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>这盛世可如你所愿？</title>
      <link href="/posts/d67271d8/"/>
      <url>/posts/d67271d8/</url>
      <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt(pwd, onError) {console.log("in doDecrypt");var txt = document.getElementById("enc_content").innerHTML;var plantext;try {  var bytes = CryptoJS.AES.decrypt(txt, pwd);plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById("enc_content").innerHTML = plaintext;document.getElementById("enc_content").style.display = "block";   document.getElementById("enc_passwd").style.display = "none";}</script><div id="enc_content" style="display:none">U2FsdGVkX19dieyDqNGXG6XH7fF1eRDKa0WUkCf5yf2g3uauQFLysFpqOx44CYErgy0JFdnN87C973MyUYj+LctBdyIWkR+pciyoUmnpcw/EYYArAEq3JhVeI1MONfF/aaF9ikvV0m7eMd5GhLTIUwvq6Ulk01HqtLdprpDKZXBw8f5kjmbCria2CX5i1wRe+N5mHpzeKnqbfrXSS4Xu5dULGZKRe0zsWMODzLgKLj0Byf58JJQqQRmdC3B5zjvpR+kSO1s0Cw6myLPz5ATeuB91W3cBa8zzXcxMUT0XuFyO+vTlCxMQd6zfJBUFrezbEZlBqMqS6R2CCvl/fS/Fg/mSPawIKQSCTf2WsxYiLtKvPlqbz2lpqRHuqJyvMt967lvZMvVcXeu/5xGBQ/Ex/+JZfuSnSfu0IRkztEMjI3QDTJcMtUbKqc6rk3O/SLzic89Gnjl+VrhI/86cVefCQtgcDLjK+KOKp3NqXSCrn6ilTyRcfsE8hD35WYtRamJZNiCL2arZfKf/AoLRQvLu6iA3qmFDysgt2YXmye6Cde92QADY5ei5ByDhkUsxgLAQHHp7XGcK2m6k0Vnyu6+4ya6Nj1NotqxqS/5+p1K01aVqq2mUbp9oklZhHgl9YAu6M2EfFx7YJtk94ETywk00sdPAMjQcptFZGP/M5vjOJ3nBy4myRrOhiZvKxKPnKXRUF9v2zPKhva8WctI+HFXOf+4Nd8L7ghL/1Eq958d8nh1HF1asWMbHM6nZoSuwzLnglELyTgDsm/zJRmoXTVPylsbUdvAlmgJ3j3PsXlFmgf727qnx1IIOOnCYiNy8RjRfuk5u7p/0nFQYgNhXIEoWWh+B1dTEo1My+IhGCerNKrYaKv2+yBSaR2jOGnoUyTTyApTUH0meeAhCVI50urYUqKRxv2jLthwvzdxrhsaKnPZvT/ctvVGQGQoPgSQ5e25E62uMhVOubhY80SgNjMqGJkJCft25sksz/zkVORsgArG22atgkKo4v0fhvvQ5CT3vsS8OTLyCivvw/hyOAe4ttIYbPJLhrkTfRw+/91EM7wRK7Yysxu9G7kHZDw5mpXlmE+RqBf4BH7YQqOCZi0BqEPPy42FMdP08/paExctmbIFxbnJkxAERUxdTNWHqrEWJ2mGcZmq/TbozDkLYRNG3nDh8OrTrfbDw7/6gmPDOPOTUQOLxaJICWchG1lgoABzdqkguwwOVP1vac9n0qAOW0dDJeK7QIuCtHIcjfJKZT4Io7L6IRKaMusTMLKIEsXZIa3CHJr3CEqo+Zf8MyFv5xKpzokHMdbiZB43mE3vJat02TCLwGXmZnfm6i9tySIx0bl2IBAZLPhAMj3oDi0oInEJpk02BjVUyPtuNWMHYJEGkx2eVoF+921uNxdqQNJ9JjaREJ3pEgmHGI0xFBQptSJCDV5+uny+YNCbqWIiijJnLD/jwImZ0YxYk7Cy4veX/qF3FHCq5K1KvKbxIa1wCb2Xws0+/N7Dydq52wyg0gznE7yVdPfrescLH1KouzZTYzrhgfNGTGdlP9MRZXbwLio76N6AJZCRnxSdGlsVu/OCcWzuAlqYRZ1dbT8d8CdMYIa3H3c/7mjT05Ni5VgyMc4F9g+QUmxIqdSqa1FUd47+fnOazl94Ybv2+llqH1wtbCPMmbYxHv2tnO4hiv1bofMLPY5EZtUfCrvL6iGM37pAJt0Vi9G/hoAgjdGy76kgq36KDhRZAqsuQAPawMwh6vc94R8onZmRqY11AJwPoSeV4GR49txtJGIhNXpnU+sdRo7EfSPW12BHHmUFtxsFfcZ/Caf/nk7i1yWuKHIVhBwPsOejROaHhGtmtk0Bk+gXHWRwN5tNqliQm76MRrj+FtbcvCYfLqKW/1z9BZYmR6BhuZ7kYbLwdg9F/Vqg4jKjmudaMbqTVih2aJ63uty/Py31loDA4kCId0VbWVc7Sa18NT+Jje6c7tF4kVK4FjQRJxZbzU2tkVPmz/c10W3sY2TC9VFzXPtiP9zBstj8Xb0a2IM/VEBKWHqXeKqqsjuy6BK4OwSnwwSut6wd2xHoB/JuImfZFZqBKV/leDBh6ASLpPY+UYSmze8wWHwlbVW9jLOIn5RbpgANZNOuaojuwhDi1t5p4DvKG0/k9eO21dPg6f2WAkqVMpxer1FGAw48l8ajCN9M65rpkwQ9SjQrz08J8uwpBKkN5BSYs9Uf2DKt5uUab8LnIkQrObXZshZ5gNkCHVz9tHnRnr6voxEvE+oT2ikqdyR8oZmXq4NFA/VOXXERAjRpl2J7UTdujlIaH7V5wDpIMV7x22WW9a7ER4arSsAFRJ24QRt1gMqoDijveJbhb/bcM9NyMN1VP1Z0yKnyDZehTlEeyXHVqDEe8OGj/d/fN01+c05O4C4FxexilxgYJD4E5hF/UB7aCJ9qf6eZ8ymeObdS05TO8RhXlJeEDwH9RT4Mz1Yu8tDls6IaXJ/+DjIdqLGeSH5p16o1kkoEJ8BkulTfqSvHTxtqBo3jk7uHaviRV0cVgROb4tjJs1M7FTM1EFJw0L4xlY6iZAh6ucD6Rfpr1EGZU6Lox3Z2nOSQJa90GgHMgv47/HhrSK3Pt1tKifpI3yNHmoO53u8qs9n9FVSkyXMH8uDSbDD5eHv6gTPCJy2vm+RAW2mSDTARHh5JdDOf8ZN2D42rxDnaFtaVNHjqwbZikPg0c726lb7GeNgBCI4WFaPecP8Ka8iJyF8TPeE35IHK6qGk9SCSbe6JvEO8HbYOg83hb31SOTagHFsiZuU4UCizKPs691ZbdK/n9iHIUN2/f2VRlDbnS+bARdIPsGIjsBSAKHqJUzlVJzt1Y+PDrvaFv3US+EbfYbjJcspz2LDl6vmvOoOTEioFnRVMvH1h+d3F2z9sv/7//lNhfltmqa4mdCM/Wt2dPmgRBBYbO0IX2Nv0tAOp6KZaVa0bY89SXZJXthF3jm2yoVal3cf9OYhBlFC7WMGd8fTWZMmBehPX3nkOO4mKx0+TbJIb4KOhNb/2wJFs1L1p+lSQdq+fU35BG50moLnrNcXRvhUaxdCwkHNu89qoPePG1tapcFsfl0Q3SCWJfNR0mtd14Xnf5KII6RofuCErNc77+MBv23wAbSOweiR9WY7h9rx+GmaqO3RCQO8d/L+zMOnMqYAhNI0Ii3ofEK/uZA+WFg7o+8ehfDhMiHI4hQ3vHt3+Mwiug3aweuu5syp+u1p+2F93ww7+zH6qCm+bl5OLanjyTxIjGyi80DEmX1zldS1+j64fDKwtxtbF1zBL3rUlqFtV4sV92SP+oRfYzFRQB6V1HNUw2lp8U0kX2wu8fHvEa2ilVhJsqIUH7VTHk2TiOlMJSbdx1QTjAjRR0mex2GZRjYOAhovW/qQaj3bBfJciPTYI06C9NayCoY7sxW6ZJOcM+FkuED1NeF3uO7PzXiIAjacLWVGwhLj1UlFrotCDBqH8wlc34h8bxjauX4MghIWiKK1OU1CLU93cJYMPGsWgmY97RVJ4DrUYJi9eW/l/17r/ndHDwt4HQpyopnVA8gRMAYdQP4vw6ySEbUs9WVJpyh8OxObUm+cqo3bpl0xFpyOI8FHn+GFu0whiUp9DU7/e+/M/DTzNT+I9ZkexW9HmXr9aeb1EMCQhKitnZusq6i7rbX7eXc8ZJn+AqUPERZg3QxXvfyHbZgHa7pqamv4g6oKZ0FcF/EEfLmBmTnf1r8hJmuARQ8E/8h/7a7TamsdKuXA8NTrbc9az2t2eWXWzWwdBHLL9UvvsPnSKqoHmthj5YrSIxQvsWLQ2n+pp4MGv/WI1DDbarlfE16bXC4razXyA1WMCGR5UljOinB29chTaOh1uUbvNpVxw3Oh87ssS3zzmQyu+acgOhzfZat5cflHk3fqhFUxuLouv/RxgeccJGWbcS3sqUck1JECt4kFMLDiu7w3Ifhg1XdvAVTPATqnTVa5THLd7MFozXXnJDAMaWnGmBHzarh0mgEErv6FFe6jL30mAtqJuU3M5KCbSSpiZoLnBy53AC8TgMvTs/MKtH0XBYMpA6yaoZh+d5hMIrDucnYy3UAnY/sdJlkyhJY8YPqSL7HqDl4GfayVz1tyS1p4CR0LGNw2gwcz7aFUZ3XvRsVXaS+aBbYkjbfOEfmiSO1EPaCFGd1okVuRbdDvMXu23lEzHdheI3aqupY2oQKsUjWtviTRTujo6qxbSsGWxZ1L64V1gcmiiq0/9XE9ZOjaaZW0qZmkIIQ1tN9G0x7Nx6Bfj+UZ0VIlcrsxdt6bUAgwnp1e/xRvgL0vdc/YVOyf0SpOb/SLVEMWsxNwZ/TWfOpRdN4QaTZho9DqwCDPdH576iGca+BXScnfFT8ioIUO+775dlgEuICGOJZAXYPyAVEZsYA4Y456wPcvkmpuCuvYKMSEwecXbLxfsIlKZ9HdvlCRaW43St5jdET5HmhpvgxyYHnqI6/Sqxov1P7kbUTK7gjOIBUaxiVamc1eI5CCRTlQT0kRy4t7pdwVqWgSvYtoIFtQEykf27yzh3ab/xgSalFbxIMhOr0PY58BMBwzLBjQImxRzpSF1vh0S2JeG5pHr6xZsQAXDnriCrt8pZIReVxPS6GgLFCdUkO4IU6TstTA133s8828K/qC1ZXZUDzTNxLmOv9CPsUvYiVO5DYjEzC9fcAXUybhnwy0fGa6atx58E1HknVr7tbRL7rKPRQI4=</div><div id="enc_passwd"> <div class="encrypt"> <script> var onError = function(error) { $("#enc_error")[0].innerHTML = "密码错误！"; }; function decrypt() { var passwd = $("#enc_passwd input")[0].value; console.log(passwd); doDecrypt(passwd, onError); } function EnterPress(e){ var e = window.event || e; if (e.keyCode == 13){ decrypt(); } } </script> <input type="text" onkeydown="EnterPress" onkeypress="EnterPress(event)" style="/* border-radius: 10px; */border-style: groove;/* border: 0px; */border-bottom: 2px solid #0097a7; /* 下划线效果 */border-top:0px;border-left:0px;border-right:0px;height: 30px;width: 61.8%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;background: #61616;padding-left: 5px" placeholder="输入密码后请按回车"> <div id="enc_error" style=" display: inline-block; color: #d84527; font: large; "> </div> </div> </div>]]></content>
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 政治 </tag>
            
            <tag> 国情 </tag>
            
            <tag> 严肃向 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Poker 机械键盘开箱与简评</title>
      <link href="/posts/72474942/"/>
      <url>/posts/72474942/</url>
      <content type="html"><![CDATA[<blockquote><p>一入外设深似海，从此钱财是路人。</p></blockquote><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>第一次知道外设这个概念，是在高中的时候，在网上偶然逛到机械键盘贴吧，只是当时忙于准备高考，而外设又价格不菲，于是念头便搁置了。</p><p>后来上了大学，买了笔记本，敲着笔记本自带的键盘「 shit 」一般的手感，才想到我应该买一把机械键盘了。于是就在网上找，看到一个段子说：</p><p>年轻人千万别碰哪些东西？</p><ol><li>毒品</li><li>游戏显卡</li><li>Hi-Fi 耳机</li><li>固态硬盘</li><li>机械键盘</li><li>Steam Origin Uplay</li><li>. . .</li></ol><a id="more"></a><p>当时大一，看到这个段子就笑了一笑，面对从一百多到一千多价位不等的机械键盘，还是比较理智的，听人说凯华轴的手感也是最接近 Cherry 轴的，于是就买了贼鸥 87，用了快两年，这期间：鼠标换了两个，耳机也买了两个，键盘却一直在用这一个，最近有几个键不灵了，正好趁着双十一，想着干脆换一把新的。心中对 Poker 那独特的键位种草已久，可惜京东没有 Poker II 的红轴版本，于是便入手了一代。</p><h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><p>不愧是「二手东」，这饱经沧桑的包装盒：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844580/blog/poker_unpacking/packaging.jpg" alt="Poker 外包装" title="Poker 外包装"></p><p>关于包装盒，去拿快递的时候还发生了一个小插曲：当时京东的人问我手机尾号，我告诉了她，然后又问我是什么东西，我说是一把键盘，然后他就去找，找了半天，没找到，然后就问另一个人，说：“尾号是 6 的快件都在这里了吧，怎么没有键盘啊？”，然后转头问我：“键盘应该是挺大的吧？”，我说：“不，不大，挺短的”，然后她又去找小一点的包裹，结果一找就找到了。</p><p>回到寝室，迫不及待的拆开了包装：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844624/blog/poker_unpacking/package_contents.jpg" alt="Poker 包装内容" title="Poker 包装内容"></p><p>这便是全家福了，包含：键盘本体、USB 连接线、RGB 的大键键帽、说明书、拔键器。</p><p>其中连接线带有屏蔽磁环，做工也算精良。</p><h2 id="60"><a href="#60" class="headerlink" title="60%"></a>60%</h2><p>Poker 这一系列，最大的特点应当就是 60% 尺寸的设计了，准确来说是 61 键。相对于普通 87 键的键盘，尺寸更加玲珑小巧，省去了方向键和功能键，改为用 <code>FN</code> 的组合键来实现相应功能。方向键是用 <code>Fn</code> + WASD 来实现，不过，对于用 Spacemacs 的我来说，没啥影响，哈哈。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844657/blog/poker_unpacking/ontology.jpg" alt="键盘本体" title="键盘本体"></p><p>真正拆开的时候才发现 60% 尺寸带来的冲击有多么大。</p><p>说到组合键，<code>Fn</code> 与组合键的功能在侧刻上都已标注：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844715/blog/poker_unpacking/side_engraved.jpg" alt="Poker 的侧刻" title="Poker 的侧刻"></p><p><code>Fn</code> 与数字键组合就是 F1~F12。<code>Fn</code> + N、M、&lt; 分别是音量 -、+、静音等。</p><h2 id="轴和键帽"><a href="#轴和键帽" class="headerlink" title="轴和键帽"></a>轴和键帽</h2><p>说道机械键盘的核心，应当就是轴体和键帽了。</p><h3 id="轴体"><a href="#轴体" class="headerlink" title="轴体"></a>轴体</h3><p>轴体方面，采用的是 Cherry 原厂轴体，大键也是卫星轴设计。手感嘛，自然是没话说了。我这里购买的是红轴的版本，毕竟用了两年，还是红轴最为顺手。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844769/blog/poker_unpacking/cherry_axis.jpg" alt="Cherry 红轴" title="Cherry 红轴"></p><h3 id="键帽"><a href="#键帽" class="headerlink" title="键帽"></a>键帽</h3><p>键帽采用的是 PBT 材质，对于 ABS 来说，PBT 的好处就是绝不会打油。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844798/blog/poker_unpacking/hand_rest.jpg" alt="键盘 + 手托" title="键盘 + 手托"></p><p>而且这款 PBT 键帽比我之前在网上购入的 PBT 键帽手感要更胜一筹，对着光看起来还闪着微弱的光，挺有意思。</p><p>在上图键 F、G、H 的侧面，可以看到有三个数字，分别是 15ms、0.1s、0.5s，这是允许用户调整按下键帽时的响应速度。这一点也是比较新奇。</p><h2 id="背部"><a href="#背部" class="headerlink" title="背部"></a>背部</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844838/blog/poker_unpacking/front.jpg" alt="正面&#39;遗照&#39;" title="正面&#39;遗照&#39;"></p><p>相对与小巧玲珑的正面来说，背部就没有那么精致了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844860/blog/poker_unpacking/back.jpg" alt="键盘背部" title="键盘背部"></p><p>四周是四个黑色的防滑垫，没有撑脚，可能是为了缩减体积来作出的取舍（当然键盘也设计成了前高后低的人体工学形状），防滑垫对我来说用处不大，因为我是把键盘放在鼠标垫上使用的。</p><p>中间那块金属铭牌上刻着一句英文：「<strong>The keyboard to cheer you up</strong>」（用这把键盘让你高兴起来！）</p><p>可能会注意到在底部的右侧有四个很小的指拨开关，作用分别是：</p><ul><li>开关 1：CAP = 左 WIN；CAP 灯 = 左 WIN 灯</li><li>开关 2：右 CTRL = `~</li><li>开关 3：左 WIN = 左 FN</li><li>开关 4：写保护键盘</li></ul><h2 id="编程功能"><a href="#编程功能" class="headerlink" title="编程功能"></a>编程功能</h2><p>这一功能也算是 Poker 的特色了，目前还不是很了解，先放一放，过几天等了解了再补上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>换上附赠的 RGB 键帽后，白色素雅的 Poker 顿时骚了起来，哈哈。</p><p>由于是 mini 键盘，我的手托也就不那么合适（长了一截，无关紧要）。</p><p>一把 60% 键盘，精简了多余的按键和尺寸，为便携带来了许多好处（要是再赠送一个保护套就更完美了）。做工上乘，手感尚佳，不过大键的手感稍肉，Cherry 原厂轴加上 PBT 键帽，算的是 IKBC 的良心之作，值得入手。（怎么感觉写成了软文 23333</p>]]></content>
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开箱 </tag>
            
            <tag> 键盘 </tag>
            
            <tag> 评测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>构建一言 API 踩坑记录</title>
      <link href="/posts/f6e1eb2a/"/>
      <url>/posts/f6e1eb2a/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最初是在手机上一个叫「一言」的 App 接触到 Hitokoto，一见倾心啊。之前我看书时遇到写的不错的句子就喜欢摘录下来，在有自己的博客之后，本想是单独写一篇博文来存放，后来分析了 NexT 的布局后，就想到在侧栏底部可以加上一个单独的模块。</p><p>最开始，是使用别人的 API，后来觉得不太好，有诸多限制，而我又没有主机，于是就自己用 Javascript 写了一个本地的脚本。后来发现这样也不太好，因为本地的脚本每次加载势必要加载存放 Hitokoto 的 JSON 文件一次，当记录越来越多时，会消耗不必要的资源。毕竟每次只需要加载一条。<br><a id="more"></a></p><h2 id="获取一言"><a href="#获取一言" class="headerlink" title="获取一言"></a>获取一言</h2><p>最开始准备构建的时候，就遇到了一个问题：一言的数据库去哪里找。我翻便了 Google，基本都是提供 API 的，并不会将完整的数据库给你。这想想也正常，都把数据库给你了，那谁还用你的 API 呢。</p><p>我就花了一下午，写了一个爬虫，对准了几个提供 API 的网站，开始爬去数据。但是由于 API 产生的数据是随机的，难免会有重复。所以爬取之后又要查重，着实花费了我不少时间。</p><p>整个过程大概花了一天多，做成了一个 JSON 格式的文件，然后用 JS 导入成为数组，再随机访问数组的某一项，这便是最初“本地版”的「一言」了。</p><h2 id="转化数据库"><a href="#转化数据库" class="headerlink" title="转化数据库"></a>转化数据库</h2><p>先前已经说过，一旦数据多了起来。那么数组的访问和加载都是问题，而访问慢的问题可以用数据库来解决。而这学期正好在学数据库这门课，于是便花了点时间将 JSON 格式的数据转化成 sqlite 数据库。JSON 格式的数据有需要的只有 3 项，分别是 ID（用以标识每个 Hitokoto）、HITOKOTO（每个 Hitokoto 的内容）、SOURCE（每个 Hitokoto 的出处）。知道了这些，转化的代码就呼之欲出了：</p><pre><code class="python">import jsonimport sqlite3JSON_FILE = &quot;hitodb.json&quot;DB_FILE = &quot;HITODB.db&quot;conn = sqlite3.connect(DB_FILE)with open(JSON_FILE, &#39;r&#39;) as load_f:    data = json.load(load_f)    for line in data:        print(int(line[&quot;id&quot;]), line[&quot;hitokoto&quot;], line[&quot;from&quot;])        conn.execute(            &#39;INSERT INTO HITOKOTO (ID, HITO, SOURCE) VALUES ({a}, \&#39;{b}\&#39;, \&#39;{c}\&#39;)&#39;.            format(a=line[&#39;id&#39;], b=line[&#39;hitokoto&#39;], c=line[&#39;from&#39;]))        conn.commit()print(&#39;Successfully&#39;)conn.close()</code></pre><p>截至至本文发布，该「一言」数据库共收录了 880 条记录，以后我还会陆续添加。</p><h2 id="生成-API"><a href="#生成-API" class="headerlink" title="生成 API"></a>生成 API</h2><p>有了数据库，自然要构建一个 API，这里选用的是 Flask 框架提供的接口。</p><p>首先你需要安装 Flask，而 Python 是自带 sqlite3 模块的。直接上代码：</p><pre><code class="python">import sqlite3from flask import Flask, jsonifyapp = Flask(__name__)@app.route(&#39;/&#39;)def index():    return &#39;Hello World!&#39;@app.route(&#39;/api/&#39;)def get_hito():    conn = sqlite3.connect(&#39;HITODB.db&#39;)    hito = conn.execute(        &#39;select * from hitokoto order by random() limit 1&#39;).fetchone()    hitokoto = &quot;{} ——「{}」&quot;.format(hito[1], hito[2])    return &#39;function hitokoto() { &#39; + &#39;document.write(\&#39;{}\&#39;);&#39;.format(        hitokoto) + &#39;}&#39;@app.route(&#39;/api/json/&#39;)def get_json():    conn = sqlite3.connect(&#39;HITODB.db&#39;)    hito = conn.execute(        &#39;select * from hitokoto order by random() limit 1&#39;).fetchone()    hitokoto = {}    hitokoto[&#39;id&#39;] = hito[0]    hitokoto[&#39;hito&#39;] = hito[1]    hitokoto[&#39;source&#39;] = hito[2]    return jsonify(hitokoto)if __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;, debug=True)</code></pre><p>保存为 <code>run.py</code>。然后运行，打开 <code>http://0.0.0.0/api/</code> 如果没有意外的话，应当是成功了。接下来就是部署了。</p><h2 id="部署至-Heroku"><a href="#部署至-Heroku" class="headerlink" title="部署至 Heroku"></a>部署至 Heroku</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>一开始担心是没有主机，后来才知道有「<a href="https://dashboard.heroku.com/" target="_blank" rel="noopener">Heroku</a>」这个造福大众的云平台服务。</p><p>首先你需要安装 <a href="https://toolbelt.heroku.com/" target="_blank" rel="noopener">Heroku 客户端工具</a>，安装完成后，输入以下命令来验证安装是否成功：</p><pre><code class="bash">$ heroku --version</code></pre><p>安装成功后，在本地命令行登录 Heroku：</p><pre><code class="bash">$ heroku login</code></pre><p>然后输入你的帐号和密码即可</p><h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>可以在<a href="https://dashboard.heroku.com/apps" target="_blank" rel="noopener">网页端创建</a>，也可以在命令行创建：</p><pre><code class="bash">$ heroku create wincer-hito</code></pre><p>这里或许会提示你名字已经被使用了，换一个就好。接下来要初始化本地和远程代码库。</p><pre><code class="bash">$ mkdir hitokoto                    # 创建本地代码仓库$ cd hitokoto                        # 切换至本地仓库目录$ git init                            # 初始化本地仓库$ heroku git:remote -a wincer-hito    # 链接到远程仓库</code></pre><h3 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><p>除了代码和数据库外，两个必要的文件：<code>requirements.txt</code> 部署应用时，远程环境会自动安装 <code>requirements.txt</code> 文件中列出的依赖。我们 <code>requirements.txt</code> 文件内容如下：</p><pre><code class="python">Flask==0.12.2gunicorn==19.4.5</code></pre><p>接下来，我们如何告诉服务器如何运行这个文件呢？就要通过 <code>Procfile</code> 文件了。</p><pre><code>web: gunicorn run:app</code></pre><p>以上就是 <code>Procfile</code> 的内容。</p><p>另根据习惯，可自行添加对该项目的描述。</p><p>接下来就是激动人心的提交了：</p><pre><code class="bash">$ git add .$ git commit -m &quot;Init commit&quot;$ git push heroku master</code></pre><p>打开 <a href="https://wincer-hito.herokuapp.com/api/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/</a> 看看效果吧！</p><h3 id="升级应用"><a href="#升级应用" class="headerlink" title="升级应用"></a>升级应用</h3><p>升级程序的时候，在所有的改动提交后，建议按照如下步骤升级：</p><pre><code class="bash">$ heroku maintenance:on$ git push heroku master$ heroku run python run.py deploy        # run.py改成自己的文件名$ heroku restart$ heroku maintenance:off</code></pre><h2 id="使用-API"><a href="#使用-API" class="headerlink" title="使用 API"></a>使用 API</h2><p>数据获取：</p><ul><li>请求地址：<a href="https://wincer-hito.herokuapp.com/api/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/</a></li><li>请求方式：GET</li><li>返回函数名 hitokoto 的 js 脚本，本质为 document.write 函数的脚本</li><li>如果需要 json 格式的数据：<a href="https://wincer-hito.herokuapp.com/api/json/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/json/</a></li><li>如果仅需要 hitokoto 主体：<a href="https://wincer-hito.herokuapp.com/api/main/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/main/</a></li></ul><p>在你想使用「一言」的地方插入以下代码：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;https://wincer-hito.herokuapp.com/api/&quot;&gt;&lt;/script&gt;&lt;script&gt;hitokoto();&lt;/script&gt;</code></pre><p>演示效果看侧栏。</p><p>注：由于是 Heroku 的主机是在美国，所以该 API 延迟可能会有一点高。</p>]]></content>
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Hitokoto </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 与 Windows 10 用 GRUB 引导教程</title>
      <link href="/posts/ad42f575/"/>
      <url>/posts/ad42f575/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年暑假的时候，写了一篇如何装 Linux 和 Windows 10 双系统的文章发在了简书上，我写这篇文章的原因是当初装双系统确实是折腾了许久，网上也找不到一篇详尽的教程。由于去年对于写教程还不是熟练，而这一年多的使用过程也遇到了一些问题，所以就准备「Refactoring」这篇文章。<br><a id="more"></a></p><h2 id="EFI-分区"><a href="#EFI-分区" class="headerlink" title="EFI 分区"></a>EFI 分区</h2><p>在教程正式开始之前，先花一点时间说明 EFI 分区的组成和作用。<br>首先，在你装了 Windows 之后，Windows 在装机过程中会将硬盘划分出一个约 100m 大小的分区，称为 EFI 分区这个分区就是起引导作用的。在资源管理器中是看不到的这个分区的，可以在磁盘管理中看到，管理则需要借助 <a href="http://www.diskgenius.cn/" target="_blank" rel="noopener">DG 工具</a>。便于说明，在装好了 Linux 之后，我将 EFI 挂载至 boot 分区截图：<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861605/blog/linux_guide/efi_folder.png" alt=""><br>可以看到，该分区包含 3 个文件夹（如果你没有装 Linux 的话，就只有两个），分别是 Boot、Microsoft 和 Manjaro，其中 Boot 文件夹就是 UEFI 引导所必需的文件。<br>我们继续打开 <code>Microsoft/Boot</code> 文件夹：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861647/blog/linux_guide/boot_folder.png" alt=""></p><p>这些文件就是启动 Windows 10 所必需的，包含了语言包、字体等，BCD 包含了 Windows 引导开始以后的信息。其中，<strong>bootmgfw.efi 是 Windows 默认引导文件</strong>。</p><ol><li>EFI/Boot/bootx64.efi</li><li>EFI/Microsoft/Boot/bootmgfw.efi</li></ol><p>以上是采用 UEFI 启动 Windows 10 的文件结构，也就是说，当你按下开机按钮的时候，首先 UEFI 找到 EFI 分区的 Boot 文件夹，然后加载 <code>bootx64.efi</code> 文件，读取文件信息，找到 <code>EFI/Microsoft/Boot/bootmgfw.efi</code>，按照 <code>bootmgfw.efi</code> 的要求，加载所需的启动信息，启动 Windows 10。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在正式装系统之前，我们还需要做一些准备工作：</p><h3 id="关闭-Windows-的快速启动"><a href="#关闭-Windows-的快速启动" class="headerlink" title="关闭 Windows 的快速启动"></a>关闭 Windows 的快速启动</h3><p>这个功能的作用是在于关机的时候不完全断电，类似将系统处于「休眠」状态，这样可以让开机更加迅速。但这也就导致了只能使用 Windows 系统。</p><h3 id="关闭-BIOS-的-Secure-Boot-的功能"><a href="#关闭-BIOS-的-Secure-Boot-的功能" class="headerlink" title="关闭 BIOS 的 Secure Boot 的功能"></a>关闭 BIOS 的 Secure Boot 的功能</h3><p>在默认情况下，UEFI 固件只会加载那些被签名的引导程序。在缺少 Secure Boot 功能的传统 PC 机上，恶意的后门程序可以加载自身，进而摇身一变伪装成一个引导程序。这样的话，BIOS 就会在启动的时候加载后门程序，这样它就可以躲过操作系统，把自己隐藏得很深。<br>但是不得不说，这对我们安装 Linux 造成了很大的困扰，也是直接导致我们重启到 Windows 10 后进不去 Linux 的原因。<br>首先我们要关闭这个功能：进入 BIOS 找到 Secure Boot，选择 disabled，这样就关闭了。当然，有些人进入 BIOS 会发现 Secure Boot 这个选项是灰色的（比如我的就是），这时你需要先给你的 BIOS 设一个密码，然后就能关 Secure Boot 了。</p><h2 id="安装-Linux"><a href="#安装-Linux" class="headerlink" title="安装 Linux"></a>安装 Linux</h2><p>所有的准备都已经完成，这时就可以准备刻录 U 盘了，不推荐 UltraISO，经亲测，软碟通仅刻录 Ubuntu 能成功，其它绝大多数发行版都会失败。推荐「<a href="https://rufus.akeo.ie/" target="_blank" rel="noopener">Rufus</a>」和「<a href="https://sourceforge.net/projects/usbwriter/" target="_blank" rel="noopener">USBWriter</a>」，这两个软件都可以。<br>刻录完成后，重启按 <code>f12</code>，选择从 USB 设备启动，对于绝大多数发行版来说一路回车就行了，只需要注意一点：<strong>在选择挂载 boot 位置的时候，一定要挂载在 efi 分区</strong>，别的都不行。<br>重启之后，不出意外的话，你会直接进入 Windows 10，不要担心，这时 Linux 已经安装成功了，我们只需要将引导文件替换一下。</p><h2 id="替换引导文件"><a href="#替换引导文件" class="headerlink" title="替换引导文件"></a>替换引导文件</h2><p>先用 DG 打开 EFI 分区，你会看到多了一个文件夹，名称取决于你安装的是哪一个发行版。我安装的是 Manjaro Linux，名称就是 Manjaro，打开之后会发现里面有一个名为 grubx64.efi 的文件，这就是启动 Linux 的引导文件。和 Windows 10 的 bootmgfw.efi 类似，我们想要用 grubx64.efi 引导代替掉 bootmgfw.efi，这样就可以用 GRUB 引导了。步骤：</p><ol><li>进入管理员命令行。方法：win + x，再按 a</li><li>输入 <code>bcdedit /set {bootmgr} path \EFI\Manjaro\grubx64.efi</code>。提示操作成功的话，就完成了。</li></ol><blockquote><p>注：经人提醒，如果输入以上命令提示「参数错误」的话，将 {bootmgr} 改为 ‘{bootmgr}’，原因是 PowerShell 和 CMD 语法的差别。</p></blockquote><p>至此，如果你安装的是除 Arch 之外绝大多数发行版，那么接下来就和你没有啥关系了，你已经成功了，好好享受吧！</p><p>开机之后会发现进入 GRUB 的引导了，通常会包含至少三个选项（以 Manjaro 举例）：Manjaro、Manjaro 高级选项和 Windows Manager。这就代表你已经完美的解决了 Windows 和 Linux 双系统引导的问题。</p><h2 id="修复-Windows-引导"><a href="#修复-Windows-引导" class="headerlink" title="修复 Windows 引导"></a>修复 Windows 引导</h2><p>这一点是我安装 Arch Llinux 的时候发现的，Arch Linux 安装过程是手动安装的，在编写 GRUB 的时候会扫描不到 Windows Manager 所在的分区（当然可能不是所有人都会遇到），所以在 GRUB 界面可能会看不到 Windows Manager 选项，导致进不去 Windows 10，这里就需要手动编辑 GRUB 信息，我们打开 <code>/boot/grub/grub.cfg</code> 文件，发现里面确实没有 Windows 10 的启动信息，在后面加上：</p><pre><code class="bash">menuentry &quot;Microsoft Windows 10&quot; {  insmod part_get  insmod fat  insmod search_fs_uuid  insmod chain  search --fs-uuid --set=root $hints_string $fs_uuid  chainloader /EFI/Microsoft/Boot/bootmgfw.efi}</code></pre><p><strong>注意</strong>：</p><p>这里的 <code>$hints_string</code>，代表的是终端执行命令：</p><pre><code class="bash">sudo grub-probe --target=hints_string /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi</code></pre><p>后的输出；</p><p>而 <code>$fs_uuid</code> 代表的是：</p><pre><code class="bash">sudo grub-probe --target=fs_uuid /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi</code></pre><p>的输出。</p><p>然后保存。在终端执行命令：<code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code>，就 OK 了。</p><p>到此，Arch Linux 和 Windows 10 双系统也配置完毕了。</p><h2 id="附加问题"><a href="#附加问题" class="headerlink" title="附加问题"></a>附加问题</h2><p>在使用这一年多的时间，遇到了以下的几个问题：</p><ol><li>在 Windows 10 进行了一个大更新后，会发现 GRUB 引导界面没有了，还是直接进入了 Windows 10，这时只需要按照 <code>替换引导文件</code> 的方法重新输入一遍命令就行。</li><li>使用 Linux 某个发行版一段时间之后，难免会想尝试一下另一个发行版。这时请务必将之前的发型版的引导文件删除，否则可能会出现无论怎么设置都无法进入 GRUB 的情况。例如：我之前用的是 Ubuntu，我现在换成了 Manjaro，我就需要用 DG 删除 EFI 分区的 Ubuntu 文件夹。</li><li>在我使用 Manjaro 更新了一次 Linux 的内核后，进不去 Windows 10 了，这个时候千万不要直接修复 Windows 10 引导，这会格式化 EFI 分区，只需要按上面 <a href="https://itswincer.com/posts/ad42f575/#%E4%BF%AE%E5%A4%8D-Windows-%E5%BC%95%E5%AF%BC" target="_blank" rel="noopener">修复 Windows 引导</a> 的方法编辑一下 GRUB 就可以了。</li></ol><p>最后：祝使用愉快。</p>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Windows </tag>
            
            <tag> 双系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kindle Papwerwhite 开箱 &amp; 简评</title>
      <link href="/posts/6619f85a/"/>
      <url>/posts/6619f85a/</url>
      <content type="html"><![CDATA[<blockquote><p>If you don’t let go old things, new ones wouldn’t come.                   —— Nicolas Wincer</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>时间是在 9 月 27 日晚，我用了一年零 8 个月的 Kindle 正式宣布坏掉，原因是充不进电，我的第一反应是想着去修，后来还是打消了这个念头。主要是这个 Kindle 实在算是家族里的「老古董」了，我对 kpw3 的 300 ppi 也是种草许久，正好本着“旧的不去，新的不来”的观念，就入了一部 kpw3，其实在我想着要买  kpw3 的时候，是有点纠结 Voyage 的，因为用了快两年的 Kindle3 我已经习惯了实体翻页键，奈何囊中羞涩，只是为了这一个功能就要多花 600 +，有些不值当，想着等工作了之后直接上 Oasis。</p><a id="more"></a><p>其实我最近是比较少看书了，现在看的这本《雪中悍刀行》看了半年多才看了一半，上本《将夜》看了一年，一方面是看的书越多，品味自然也高了起来，现在写的好的小说是越来越少，之前一直很喜欢的几个作者要么更新是越来越慢（比方说：烽火戏诸侯，愤怒的香蕉）、要么是书的质量不如之前（比方说：烟雨江南、猫腻），有点担心自己看完了就书荒了。</p><p>我买 Kindle 不是为了亚马逊庞大的图书资源（我看书只自己在网上找），而是因为那块 E-ink 屏幕，而且因为 Kindle 那可怜兮兮的娱乐功能，用 Kindle 时可以更专注于看书。而国庆前几天一直忙于跑亲戚，所以直到今天才有空闲时间开箱。</p><h2 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h2><p>这就是全部的配件（裸机 + 数据线）了：右边是卖家附赠的</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861449/blog/kindle_unpacking/pic1.jpg" alt=""></p><table><thead><tr><th>参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>阅读灯</td><td style="text-align:left">4 颗</td></tr><tr><td>解析度</td><td style="text-align:left">300 ppi</td></tr><tr><td>重量</td><td style="text-align:left">205 g</td></tr><tr><td>尺寸</td><td style="text-align:left">169 × 117 × 9.1 mm</td></tr><tr><td>屏幕</td><td style="text-align:left">6 吋</td></tr><tr><td>容量</td><td style="text-align:left">4 GB</td></tr><tr><td>连接</td><td style="text-align:left">Wi-Fi</td></tr><tr><td>运存</td><td style="text-align:left">512 mb</td></tr></tbody></table><h2 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h2><p>开完箱经过简单的设置之后，迫不及待的从电脑传了几本书（谁都阻止不了我想读书的心情！）。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861472/blog/kindle_unpacking/pic2.png" alt=""></p><p>吐槽一下，这里是无法像多看一样做成文件浏览的形式，也就是说，即使你把一些书放进新建的文件夹里（便于归类管理），它也是直接在首页显示。</p><p>这就是阅读界面的选项了，选项少的可怜，而且页边距太大！我这已经设置页边距最小了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861491/blog/kindle_unpacking/pic3.png" alt=""></p><p>得益于 Kindle 这块 4:3 的屏幕，看漫画可以说是比手机更具优势。清晰度是够了，要是屏幕再大一些就好了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861506/blog/kindle_unpacking/pic4.png" alt=""></p><p>如果想要购买正版书，就在上方的搜索按钮输入书名：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861524/blog/kindle_unpacking/pic5.png" alt=""></p><p>设置界面确实寒酸，不过想想要的只是纯粹的阅读体验，也就释然了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861537/blog/kindle_unpacking/pic6.png" alt=""></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861554/blog/kindle_unpacking/pic7.png" alt=""></p><p>使用了<del>半个多小时</del>两天多了，简单总结一下感受：</p><ol><li>300 ppi 看起书来真的是太 ™ 爽了</li><li>在翻页的速度上，相比前几代快了不少，当然和手机还是没法比</li><li>阅读灯对我来说没啥用，我晚上看书也会开台灯</li><li>页边距实在太大，我都已经调整成了最小边距了，可还是留白太多</li><li>系统功能相比多看来说还是少了一些，比如无法设置全刷页数</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>买 kpw3 之前其实还有一个顾虑，就是刷不了「多看」，我的电子书资源多是 「epub」格式的，而 Kindle 的原生系统是<strong>不支持</strong>「epub」格式的（我一直搞不懂为什么亚马逊不支持）现在我每一本书都要转成 「mobi」 才能在 Kindle 上看。</p><p>还有就是实体翻页键了，等我经济独立之后，一定要买 Oasis！</p>]]></content>
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开箱 </tag>
            
            <tag> Kindle </tag>
            
            <tag> 简评 </tag>
            
            <tag> 电子书 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spacemacs 生存指北</title>
      <link href="/posts/2aa541e6/"/>
      <url>/posts/2aa541e6/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="http://spacemacs.org/" target="_blank" rel="noopener">Spacemacs</a> 是一份 <a href="https://www.gnu.org/s/emacs/" target="_blank" rel="noopener">Emacs</a> 的配置文件，将 <a href="https://github.com/vim/vim" target="_blank" rel="noopener">Vim</a> 的快捷键移植到了 Emacs 上，可以提供 Vimer 至 Emacs 的无缝衔接。有了 Spacemacs，你不需要花那么多时间去学习 Emacs 就可以真正用 Spacemacs 开始做一些事情。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="bash">$ mv ~/.emacs.d ~/.emacs.d.bak$ git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d$ emacs</code></pre><p>Clone 至本地后，第一次使用 Spacemacs 时要加载一些 Package，以及根据你的喜好所生成的配置，建议一路回车。</p><p>此时会加载很多的 Package，如果没有挂代理的话，就会很慢很慢，可以采用 <a href="https://elpa.emacs-china.org/" target="_blank" rel="noopener">emacs-china</a> 的配置源。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Spacemacs 基本使用的是原生 Vim 的快捷键，此前请先熟悉 Vim 的操作。我这里只贴出个人认为比较常用的快捷键。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><code>SPC f e d</code> 快速打开配置文件</p><p><code>SPC f e R</code> 同步配置文件</p><p><code>SPC q q</code> 退出 Emacs</p><p><code>SPC q R</code> 重启 Emacs</p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p><code>SPC f f</code> 打开文件</p><p><code>SPC f t</code> neotree 方式显示文件路径</p><p><code>Ctrl s</code> 搜索当前文件（需安装 ivy layer）</p><p><code>*</code> 另一种搜索文件的姿势（需将光标置于需搜索的单词处）</p><ul><li><code>n</code>  下一个匹配</li><li><code>N/p</code> 前一个匹配</li><li><code>r</code> 改变范围：当前屏幕，当前函数，当前 buffer</li><li><code>e</code> 编辑所有匹配（类似于替换）</li><li><code>/</code> 在当前 project 搜索</li></ul><p><code>SPC s c</code> 清除搜索高亮</p><p><code>SPC f R</code> 重命名当前文件</p><p><code>SPC f E</code> 使用 sudo 来编辑文件（当某些文件的权限是只读的时候）</p><p><code>SPC f D</code> 删除当前文件</p><p><code>SPC f r</code> 打开最近文件列表（需安装 ivy layer）</p><p><code>SPC f y</code> 复制当前文件的绝对路径</p><p><code>SPC f c</code> 复制文件</p><h3 id="buffer-管理"><a href="#buffer-管理" class="headerlink" title="buffer 管理"></a>buffer 管理</h3><p><code>SPC b b</code> 显示已经打开的 buffer</p><p><code>SPC b d</code> 关闭当前 buffer</p><p><code>SPC b h</code> 进入 Spacemacs 初始界面</p><p><code>SPC b N</code> 新建一个 buffer</p><p><code>SPC b R</code> 从自动备份的文件中恢复</p><p><code>SPC b Y</code> 复制整个 buffer 的内容</p><p><code>SPC b P</code> 将剪贴板的内容粘贴到整个 buffer</p><p><code>SPC Tab</code> 切换至上一个 buffer</p><h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><p><code>SPC n(number)</code> 跳转至第 n 号窗口</p><p><code>SPC 0</code> 跳转至 neotree 侧边栏</p><p><code>SPC w m</code> 当前窗口最大化</p><p><code>SPC w s</code> 或 <code>SPC w -</code> 水平分割窗口</p><p><code>SPC w v</code> 或 <code>SPC w /</code> 竖直分割窗口</p><p><code>SPC w =</code> 平衡窗口</p><p><code>SPC w d</code> 删除当前窗口</p><p><code>SPC w o</code> 切换至其他窗口</p><p><code>SPC t g</code> 将当前窗口与其他窗口 黄金分割</p><h3 id="project-管理"><a href="#project-管理" class="headerlink" title="project 管理"></a>project 管理</h3><p><code>SPC p f</code> 在当前 project 中查找文件</p><p><code>SPC p p</code> 切换项目</p><p><code>SPC /</code> 在该项目中搜索字符串</p><p><code>SPC p R</code> 在项目中替换字符串，先输入「匹配」的，再输入「替换」的字符串（我一般不使用这种方式，我用<code>*</code>来替换）</p><h3 id="缩进代码"><a href="#缩进代码" class="headerlink" title="缩进代码"></a>缩进代码</h3><p><code>SPC j =</code> 自动对齐</p><p><code>SPC m =</code> 美化代码（不适用于所有语言）</p><h3 id="shell-操作"><a href="#shell-操作" class="headerlink" title="shell 操作"></a>shell 操作</h3><p><code>SPC &#39;</code> 打开/关闭 Eshell（需安装 shell layer）</p><p><code>SPC a s</code> 打开其它种类的 Shell</p><h3 id="中断操作"><a href="#中断操作" class="headerlink" title="中断操作"></a>中断操作</h3><p><code>C g</code> 输错命令时，可取消该次输入</p><h2 id="显示动态行号"><a href="#显示动态行号" class="headerlink" title="显示动态行号"></a>显示动态行号</h2><p>将  <code>dotspacemacs-line-numbers</code> 的值改为 ‘relative</p><h2 id="Magit"><a href="#Magit" class="headerlink" title="Magit"></a>Magit</h2><p>Spacemacs 中集成了 Git 管理工具，需先安装 git layer。</p><p>常用的快捷键：</p><table><thead><tr><th>git</th><th>magit</th></tr></thead><tbody><tr><td><code>git init</code></td><td><code>SPC g i</code></td></tr><tr><td><code>git status</code></td><td><code>SPC g s</code></td></tr><tr><td><code>git add</code></td><td><code>SPC g s</code> 弹出然后按 <code>s</code></td></tr><tr><td><code>git add currentfile</code></td><td><code>SPC g</code></td></tr><tr><td><code>git commit</code></td><td><code>SPC g c c</code></td></tr><tr><td><code>git push</code></td><td><code>SPC g P</code></td></tr><tr><td><code>git log</code></td><td><code>SPC g l l</code></td></tr><tr><td><code>git checkout xxx</code></td><td><code>SPC gn C</code></td></tr><tr><td><code>git checkout -- xxx</code></td><td><code>SPC g s</code> 弹出然后按 <code>u</code></td></tr><tr><td><code>git reset --hard xxx</code></td><td><code>SPC g s</code> 弹出然后按 <code>x</code></td></tr></tbody></table><h2 id="守护模式"><a href="#守护模式" class="headerlink" title="守护模式"></a>守护模式</h2><p>终端使用 <code>emacs -daemon</code> 以守护模式开启 emacs：</p><p><code>$ emacsclient -c</code> 打开 Emacs GUI<br><code>$ emacsclient -t</code> 打开 命令行 Emacs</p><p>当开启守护进程时，点击关闭按钮后进程还是会保留在后台，如果想要彻底关闭 Emacs 可以：<code>SPC q q</code> 或者<code>$ killall emacs</code></p><p>以下是我针对我常用的一些语言做的一些特殊的设置：</p><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><p>我没有采用 Spacemacs 提供的 c/c++ layer，而是采用的 <a href="https://github.com/Sarcasm/irony-mode" target="_blank" rel="noopener">Irony-Mode</a>，因为原生的 c/c++ layer 自动补全需要 ycmd，而 ycmd 安装配置起来实在太麻烦了。</p><h3 id="快捷键-1"><a href="#快捷键-1" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>:gdb</code> 启用 gdb 调试</p><p><code>SPC c C</code> 编译程序</p><ul><li>默认是用 <code>cmake</code> 编译，可以替换成 <code>clang/gcc -g main.C -o main</code> （这些参数会被记住）</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Python 用的 Spacemacs 自带的 python layer，添加了一些参数：</p><pre><code class="emacs-lisp">(python :variables        python-enable-yapf-format-on-save t ;; 当保存的时候自动 `yapf&#39; 美化        python-fill-column 80                ;; 开启 80 列的提示        python-sort-imports-on-save t)        ;; 当保存的时候自动排序导入的包</code></pre><h3 id="快捷键-2"><a href="#快捷键-2" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>, c c</code> 运行当前文件</p><p><code>, =</code> 美化代码</p><p><code>, &#39;</code> 打开 IPython repl</p><p><code>, g</code> 跳转至定义处：</p><ul><li><code>, g g</code> 在当前窗口跳转至定义处</li><li><code>, g G</code> 在另一窗口跳转至定义处</li><li><code>, g b</code> 回到原处</li></ul><p><code>, s</code> 将当前文件发送至 repl:</p><ul><li><code>, s b</code> 将当前 buffer 发送至 repl</li><li><code>, s f</code> 将当前 defun 发送至 repl</li><li><code>, s r</code> 将当前选中内容发送至 repl</li></ul><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>我将 JavaScript layer 自带的 repl 换成了 nodejs，自带的不太好用。</p><pre><code class="emacs-lisp">(javascript :variables            tern-command &#39;(&quot;node&quot; &quot;/home/wincer/.npm-global/bin/tern&quot;)    ;; 指定 `tern&#39; 的路径            javascript-disable-tern-port-files nil)</code></pre><p>设置了一些快捷键：(o 开始的默认为用户自定义的)</p><p><code>SPC o s i</code> 启动 nodejs repl</p><p><code>SPC o s b</code> 将当前 buffer 发送至 repl</p><p><code>SPC o s r</code> 将选中内容发送至 repl</p><p><code>SPC o s l</code> 将当前行发送至 repl</p><h2 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h2><p>我是在学 sicp 时才用到 Scheme，所以采用的 Scheme 实现是 MIT-Scheme，并将其设置为默认 repl：</p><h3 id="快捷键-3"><a href="#快捷键-3" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>, &#39;</code> 切换至 repl</p><p><code>, s</code> 评估算式：</p><ul><li><code>, s b</code> 计算当前 buffer</li><li><code>, s e</code> 计算最后一个表达式</li><li><code>, s f</code> 计算当前定义的函数</li><li><code>, s r</code> 计算当前选中的内容</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我的 Spacemacs 配置放在了 GitHub 上，<a href="https://github.com/WincerChan/Spacemacs-Config" target="_blank" rel="noopener">这是地址</a>。</p>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spacemacs </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从 HTTP 到 HTTPS 再到 HSTS</title>
      <link href="/posts/dfc84766/"/>
      <url>/posts/dfc84766/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我的博客是在三个月前就完成了 <code>HTTPS</code> 加密工作，方式嘛，和大多数网站类似，是将 <code>HTTP</code> 的请求 301 跳转至 <code>HTTPS</code>，这样虽然可以让用户即使输入的不包含 <code>HTTPS</code> 的网址，也可以跳转至 <code>HTTPS</code>。但是当你输入的是域名（不带 <code>HTTP</code> 或 <code>HTTPS</code> ）时，浏览器会自动帮助你填充的是 <code>HTTP</code> 而不是 <code>HTTPS</code>。</p><p>虽然正常情况你会跳转至 <code>HTTPS</code>，但是啊但是目前有一种称为「<strong>降级攻击</strong>」的技术（具体原理自行查阅），我这里简单说一下后果：这种技术是借助中间人发动的攻击，中间人会在浏览器和目标网站之间尝试拦截跳转至 <code>HTTPS</code> 的内容，将浏览器重定向至受攻击者控制的服务器，这也就是我们所说的「HTTP 请求劫持」。</p><p>那么怎么预防呢？</p><ol><li>在每个域名之前手动输入 <code>https://</code></li><li>网站启用 <code>HSTS</code></li></ol><p>第一种每次都要手写输入，自然很麻烦，第二点也就是本文所说的。</p><a id="more"></a><h2 id="HSTS-原理"><a href="#HSTS-原理" class="headerlink" title="HSTS 原理"></a>HSTS 原理</h2><p> <code>HSTS</code> 是 <code>HTTP Strict Transport Security</code> 的简称，定义在「<a href="https://tools.ietf.org/html/rfc6797" target="_blank" rel="noopener">RFC 6797</a> 」，旨在帮助使用 <code>HTTPS</code> 的服务器免受「<strong>降级攻击</strong>」。</p><p>工作流程如下：</p><ol><li>用户首次访问开启 <code>HSTS</code> 服务的网站</li><li>浏览器会留下一个包含 <code>max-age</code> 参数的 <code>HSTS</code> 缓存文件</li><li>在 <code>max-age</code> 到期之前访问网站，浏览器会根据缓存中的 <code>HSTS</code> 设置自动访问 <code>HTTPS</code> 页面</li></ol><p>开启 <code>HSTS</code> 后可以有效防止「<strong>降级攻击</strong>」，同时也会省去 301 至 <code>HTTPS</code> 的时间，于安全系数和用户体验都有提升。</p><h2 id="如何开启-HSTS"><a href="#如何开启-HSTS" class="headerlink" title="如何开启 HSTS"></a>如何开启 HSTS</h2><p>由于我的网站的 cdn 提供商 Cloudflare（CloudFlare 大法好！） 已经提供了 <code>HSTS</code> 技术，只需要手动开启就可以了。</p><p>在 <code>Crypto -&gt; HTTP Strict Transport Security (HSTS)</code>开启如下配置：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861893/blog/http_https_hsts/cf_crypto.png" alt=""></p><h3 id="安全系数检测"><a href="#安全系数检测" class="headerlink" title="安全系数检测"></a>安全系数检测</h3><p>开启之后，进入 <a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener">https://www.ssllabs.com/ssltest/</a> 这个网站，输入域名后，该网站会对你的网站进行一次测试：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861939/blog/http_https_hsts/ssllab_summary.png" alt=""></p><p>在开启后，我的网站安全等级变成了 A+，开启之前是 A。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在用户第一次访问时，如果输入网址没有 <code>HTTPS</code> 字段，无法避免的会进行一次 301 跳转，有可能还是会被攻击。</p><p>这个时候就需要用到 <a href="https://hstspreload.org/" target="_blank" rel="noopener">HSTS Preload</a> （本站域名已申请加入），这是由 Google 维护的一个域名列表，只要加入这个列表的域名，当使用主流浏览器，如：Chrome, Firefox, Opera, Safari, IE 11 和 Edge 时，即使第一次也会强制转换成 <code>HTTPS</code> 再访问。从而使访问更加安全。</p>]]></content>
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> HSTS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>爬虫模拟登录之一般性解决方法（Cookie）</title>
      <link href="/posts/d68153f1/"/>
      <url>/posts/d68153f1/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几周写了<a href="https://itswincer.com/posts/94e157f8/" target="_blank" rel="noopener">一篇文章</a>，介绍了如何利用 post 方法来验证登录的问题，我也是一直在使用此方法登录豆瓣爬取一些信息，可是前两天突然就不能用了。我也再次查看了豆瓣的源代码，确认了豆瓣的验证信息并没有发生改变，但就是一直登录不上去，我猜想到可能是这个方法行不通了，于是我就换了一个思路：之前的思路是需要将 <code>post</code> 提交的表单数据保存在一个 <code>session</code> 的实例中，然后调用这个 <code>session</code> 实例的 <code>get</code> 方法就可以使用之前保存的数据。</p><p>而现在这一方法失效了，我猜想就是 <code>post</code> 方法提交数据这一步出了问题。那么就换一个思路，直接将服务器返回的数据存入 <code>session</code>，那么这个数据具体是什么？从哪儿来呢？这就是这篇文章所要谈到的。</p><a id="more"></a><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>这里简单说一下 Cookie 的作用，详细的定义见 <a href="https://www.ietf.org/rfc/rfc2109.txt" target="_blank" rel="noopener">RFC2109</a>。</p><blockquote><p>当登录一个网站的时候，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站，用户会发现没输用户名和密码就已经登录了。这是因为前一次登录时，服务器发送了包含登录凭据的 Cookie 到用户的硬盘里。下次登录时，如果 Cookie 尚未到期，那么浏览器就会发送该 Cookie，服务器验证凭据，于是就不需要用户名和密码就可以登录了。——维基百科</p></blockquote><p>也就是说我们只需要获取这个保存在硬盘中的 Cookie 信息，并将它传入程序可以登录了。</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>打开 Chrome 的开发工具的 Network 一栏，输入完用户名和密码及验证码后，点击登录。以简书为例（因为简书是需要滑动验证的，比豆瓣的验证码更麻烦）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862655/blog/imatate_general_solution/cookie.png" alt=""></p><p>你会发现有一个 <code>Type</code> 为 <code>document</code>、名为 <code>www.jianshu.com</code> 的文档，点开他并滑动到最下面你就会看到在 <code>Requests Header</code> 中有一项名为 <code>Cookie</code> 的很长很长的字符串，这里面就保存了你的登录信息，这些信息通常是经过加密的，所以不可读。Cookie 的格式一般是：<code>name1=value1;name2=value2</code>。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>那么获取了 Cookie 之后，该怎么在程序中使用呢？</p><p><code>requests</code> 库提供了<a href="http://docs.python-requests.org/zh_CN/latest/user/advanced.html#session-objects" target="_blank" rel="noopener">这样的方法</a>，首先我们将从浏览器获取的 Cookie 的格式转换成 Python 的字典格式，如 <code>name1=value1;name2=value2</code> 转化为：</p><pre><code class="python">cookie = {    &#39;name1&#39;: &#39;value1&#39;,    &#39;name2&#39;: &#39;value2&#39;}</code></pre><p>然后，运用 <code>requests.get</code> 方法获取的时候将 cookie 传入就 OK 了：</p><pre><code class="python">from requests import get, session# 这里最好设置一下User-Agenthead = {    &#39;User-Agent&#39;:    (&#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 &#39;     &#39;(KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&#39;)}url = &#39;http://www.jianshu.com&#39;r = get(url, headers=head, cookies=cookie)# 如果登录成功就会在首页的html中出现我的主页字样r.text.find(&#39;我的主页&#39;)</code></pre><p>有一点麻烦的是，每次都需要在 <code>get</code> 方法的参数列表中加入 headers 和 cookies 项，这样有点不利于我们书写，而且对爬取速度也有影响。那么有没有解决办法呢？</p><p>这里就要借用到上篇文章中使用的 <code>session</code> 机制，我们创建一个 <code>session</code> 的实例，首次 <code>get</code> 需要提交 headers 和 cookies，随后这些信息就会保存在创建的 <code>session</code> 实例中，下次直接调用实例的 <code>get</code> 方法，只需传入一个 url 即可。</p><pre><code class="python">ssion = session()ss = ssion.get(url, headers=head, cookies=cookies)&gt;&gt;&gt; ss.text.find(&#39;我的主页&#39;)&gt;&gt;&gt; 5180&gt;&gt;&gt; s = ssion.get(url)&gt;&gt;&gt; s.text.find(&#39;我的主页&#39;)&gt;&gt;&gt; 5180</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我之所以把这种方法成为一般性解决方法是因为这种方法的应用范围更广泛。上一篇文章介绍的方法仅适用于验证方式最为简单的网站（没有验证码或验证码是图片）而且失误率还高；本文介绍的方法相对来说就好了许多，唯一繁琐的一点可能就是将 cookies 转化为字典需要花费一点时间了。</p>]]></content>
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 模拟登录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写给 20 岁的自己</title>
      <link href="/posts/11ab0263/"/>
      <url>/posts/11ab0263/</url>
      <content type="html"><![CDATA[<blockquote><p>凡心所向，素履所往，生如逆旅，一苇以航。</p></blockquote><p>一直很喜欢海子对于时间的说法——“打马而过”。就像我还没来得及细数，20 个年头匆匆已逝。没有那么多时间细想，这一天就这么来临了，来不及回忆过去，也来不及憧憬未来，一眨眼，就发现自己已经 20 岁了。</p><p>在许久之前，我便对自己的 20 岁有过憧憬，想着，20 岁的我会在哪里，做着什么事情。是有了一项划时代的发明，成为震惊世界的奇才；还是偏居一隅，发出「天地与我并生 万物与我为一」的感慨。是的，我希望自己能真实的活着，不像那些忙忙碌碌一辈子不知道为谁而活的人那样。不在意别人的眼光，不为了生存而活。</p><a id="more"></a><p>但是，现在的我，也就只是在大学里，做着大多数人应该做的事情，过着大多数人应该过的生活。看来在这二十年的生命中，我还是不够坚韧。</p><p>我想我是不甘于于平凡的，很小的时候，我就会告诉自己，不要去重复别人做过的事情，因为我是独一无二的（后来才知道原来小孩都会有这样的想法），我有自己的事情去做。现在回想起来，还真的觉得挺可爱的。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862176/blog/to_20_me/fight_club.png" alt="搏击俱乐部" title="搏击俱乐部"></p><p>《搏击俱乐部》里泰勒抢了一个便利店员（雷蒙）的钱包并拿枪指着他的后脑勺，雷蒙跪在地上颤抖着，泰勒问他想做什么，同时扳下击锤，雷蒙颤抖得更厉害了。</p><p>“兽医”，雷蒙颤几乎是带着哭腔说了出来。</p><p>“我知道了，我要拿走你的驾照。我随时会去看你，我知道你住在哪”，泰勒说。</p><p>“要是在六星期内你没当上兽医，你就死定了”，泰勒把钱包还给他了，并让他跑回了家。</p><p>同行的杰克表示不理解：“拜托 那有什么好玩的？那样做有什么意义？”</p><p>泰勒背对着他，“明天会是他一生中最美的一天，他的早餐会比我们吃过的都甜美。”</p><hr><p>蒋勋在《孤独六讲》中写到，好像只有孤独，生命可以变得丰富而华丽。</p><p>无人理解的泰勒，他的人生想必是华丽到了极点。他内心所真正向往的地方是只有自己知晓的一方天地，他会去做自己想做的事，并因此让自己的生命变得有意义起来。</p><p>这一切都是因为做自己喜欢的事情，无关别人，只是为了自己的热爱。</p><p>从小到大，父母乃至老师灌输的思想就是：用心念书，从市重点初中，到省重点高中，再到一本大学，过更好的生活。</p><p>是的，过去二十年我仿佛就是按照这个既定的轨迹，一步一步活成了别人眼中的自己。等到我现在可以反思我的生活时，才发现<strong>我想做的事情</strong>和<strong>我应该做的事情</strong>那条清楚的界限早已模糊不清，长期的压力仿佛让自己对一切都失去了兴趣。</p><p>我抗争过吗？当然抗争过，不过一个人的力量终究是难以改变什么，泰勒也深知这一点，才会成立“搏击俱乐部”。</p><p>这样的生活很可怕。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862262/blog/to_20_me/3_idiots.png" alt="三傻大闹宝莱坞" title="三傻大闹宝莱坞"></p><p>《三傻大闹宝莱坞》兰彻对法汗说：</p><blockquote><p>知道我为什么第一名吗？因为我热爱机械，工程学就是我的兴趣所在，知道你的兴趣吗？这就是你的兴趣……跟工程学说拜拜，跟摄影业结婚，发挥你的才能，想想迈克尔杰克逊的爸爸硬逼他成为拳击手，拳王阿里的爸爸非要他去唱歌，想想后果多可怕？</p></blockquote><p>是的，被别人强迫去做自己不喜欢的事情，是很可怕的。更可怕的是，被强迫的多了，就会麻木。</p><p>从小学到高中，我的生活一直像父母要求的那样，努力，不轻言放弃。被强迫穿着这许多外衣的我，沿着既定的轨迹一点一点的行进。</p><p>如果说，之前的我，不是为自己而活，那么从此时此刻，我就要像小时候自己想的那样，不为别人而活，为自己真实地活着。去寻找自己喜欢且甘之如饴的事情。</p><hr><p>作家吴晓波在《把生命浪费在美好的事情上》中写到：</p><blockquote><p>喜欢，是一切付出的前提。只有真心的喜欢了，你才会去投入，才不会抱怨这些投入，无论是时间、精力还是感情。</p></blockquote><blockquote><p>在这个世界上，不是每个国家每个时代每个家庭的年轻人，都有权利去追求自己所喜欢的未来，所以，如果你侥幸可以请千万不要错过。</p></blockquote><p>我还年轻，以后的路还很长，我可以做得更好。</p><p>不要害怕前路，我会迈着缓慢而坚定的步伐走下去。</p><p>我不要自己做到最好、最优秀，只希望能在接下来的时光里，变得柔软而坚韧。</p><p>最后，二十岁快乐，送给自己。</p>]]></content>
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>爬虫模拟登录</title>
      <link href="/posts/94e157f8/"/>
      <url>/posts/94e157f8/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>有时候就在想，要是所有的网站对爬虫友好该多好。</p></blockquote><p>当然这是不可能的：网站重要的数据往往就是一个产品的价值所在，如果被我们轻松的获取，这自然对网站经营者来说是一种损失，所以就有了以下各种策略去阻碍爬虫：</p><ul><li>User-Agent 检测</li><li>帐号及 Cookie 验证</li><li>验证码</li><li>限制 IP 次数或频率</li></ul><p>这篇文章主要来说说如何解决验证码问题。</p><a id="more"></a><h2 id="获取网页结构"><a href="#获取网页结构" class="headerlink" title="获取网页结构"></a>获取网页结构</h2><p>验证码多是在登录的情况下与 <code>username</code>、<code>password</code> 一同用 <code>post</code> 方法传给服务器进行验证，所以我们首先需要去查看一个网页的结构，这里以豆瓣为例：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862520/blog/imitate_login/source.png" alt=""></p><p>检查元素后发现登录是单独存在的一个界面，网址是 <code>https://www.douban.com/accounts/login</code>，而且也标注了是以 <code>post</code> 去提交，接下来输入用户名和密码，点击登录，ok，我们就登录成功了，这是人为的方式，那么我们这种操作翻译成程序是怎么样的呢？</p><h3 id="检查-post-提交的信息"><a href="#检查-post-提交的信息" class="headerlink" title="检查 post 提交的信息"></a>检查 post 提交的信息</h3><p><code>F12</code> 打开调试工具，在 <code>Network</code> 一栏把 <code>Preserve log</code> 勾上，这一点是因为一点登录就跳转到另一个界面了，捕捉不到登录信息</p><p>随后你会看到加载了许多的信息，没关系，把滚动条拉至最上方，你会看到名为 <code>login</code> 的一个报文，点击，然后滑动到最下方，你就会看到一个 <code>Form Data</code> 的数据表，这就是 post 提交的东西，你会看到有包括你的邮箱、密码在内的 5 项内容，我们浏览器发送的也就是这 5 项。</p><h2 id="构造程序"><a href="#构造程序" class="headerlink" title="构造程序"></a>构造程序</h2><p>既然知道了需要提交的信息，也就成功了一大半了，这里用 requests 库的 session 来保存 cookie 信息</p><pre><code class="python">from requests import sessionurl = &#39;https://accounts.douban.com/login&#39;#豆瓣貌似并不会验证User-Agenthead = {                  &#39;User-Agent&#39;:    (&#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 &#39;        &#39;(KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&#39;)}# 这里就是刚刚获取的post需要提交的信息data = {                                            &#39;source&#39;: &#39;None&#39;,    &#39;redir&#39;: &#39;https://www.douban.com&#39;,    &#39;form_email&#39;: &#39;&#39;,    &#39;form_password&#39;: &#39;&#39;,    &#39;login&#39;: &#39;登录&#39;}ssion = session()ssion.post(url, header=head, data=data)</code></pre><p>用 <code>ssion.get()</code> 就可以使用刚刚保存在 session 中的信息进行登录了，你可以采取以下代码看看你是不是成功登录了：</p><pre><code class="python">t = ssion.get(&#39;https://www.douban.com&#39;).textprint(t)</code></pre><p>如果你发现了自己的帐号名称，那么就成功了。</p><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>大多数情况登录是不需要验证码的，但是亲测发现频繁登录大概 5 次左右就会需要验证码，同样检查 <code>post</code> 发现多了两项：</p><p><code>captcha-solution</code>、<code>captcha-id</code> 内容，自然就是我们输入的验证码了其中 <code>solution</code> 就是验证码的内容，<code>id</code> 就是验证码的编号，当二者与数据库的内容与编号对应时，就验证通过。</p><p>这里提供一个简单的思路：将验证码的图片保存至本地，然后用户输入验证码内容后再提交：</p><pre><code class="python">from re import search, compilefrom PIL impoet Imageimg = compile(r&#39;img id=&quot;captcha_image&quot; src=&quot;(.*?)&quot;&#39;)img_url = img.findall(response)[0]jpg = get(img_url).contentwith open(&#39;captcha.jpg&#39;, &#39;wb&#39;) as f:    f.write(jpg)Image.open(&#39;captcha.jpg&#39;).show()captcha_solu = input(&#39;input captcha: &#39;)capt = compile(r&#39;captcha\?id=(.*?)\&amp;amp&#39;)captcha_id = capt.findall(img_url)[0]data = {    &#39;source&#39;: &#39;None&#39;,    &#39;redir&#39;: &#39;https://www.douban.com&#39;,    &#39;form_email&#39;: &#39;&#39;,    &#39;form_password&#39;: &#39;&#39;,    &#39;captcha-solution&#39;: captcha_solu,    &#39;captcha-id&#39;: captcha_id,    &#39;login&#39;: &#39;登录&#39;}</code></pre><p>当你运行的时候，会弹出一个小框框显示的是验证码，在终端输入内容就可以了，如下图</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862603/blog/imitate_login/captcha.png" alt=""></p><p>用 class 封装一下，完整的代码见<a href="https://gist.github.com/WincerChan/3574fd7714e939d3d7ff4ac436c7371b" target="_blank" rel="noopener">这里</a>，main 函数返回的就是 <code>ssion</code>，直接使用即可。</p>]]></content>
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 模拟登录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>再见 LiveRe，拥抱 Disqus</title>
      <link href="/posts/e5d13eb/"/>
      <url>/posts/e5d13eb/</url>
      <content type="html"><![CDATA[<p>没错，我又双叒叕换评论系统了，从最初的网易云跟帖，到后来的 LiveRe，再到现在的 Disqus，两个多月就换了好了三四次（中间从 LiveRe 切换过一次 Disqus，后来又换回来了）了，仿佛我在折腾这些非博客主体的路上越走越远，也幸好我的博客才建成，没啥人留言，不然就得不偿失了。</p><a id="more"></a><h2 id="LiveRe"><a href="#LiveRe" class="headerlink" title="LiveRe"></a>LiveRe</h2><p>其实 LiveRe 真的做的挺棒的，中国的本地化做的更是没话说，支持国内的社交媒体：微信、QQ、百度、人人、豆瓣、新浪，国外的支持的就更多了，上次我因为评论框颜色的问题发送了邮件，结果不到 12 个小时 LiveRe 中国区的负责人亲自发邮件解答了这个疑问，就这点来说简直太良心了。</p><p>但是美中不足的是：</p><ol><li>不支持游客评论（其实这点倒无关紧要）</li><li>不支持导出评论</li><li>在我博客的加载速度问题</li></ol><p>我最不能忍受的就是第三点了，由于我博客是采用了 CloudFlare 的 Keyless SSL 技术，流量都会走 CloudFlare 的 CDN 节点，但是由于节点在国外，国内访问速度实在是太慢了，每次点开网页都会看到圈圈不停的转，这简直不能忍啊，于是我就想做一个延时加载的，后来想想，既然都要做延时加载的了，那我为什么不干脆换成 Disqus 呢？</p><h2 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a>Disqus</h2><p>那么说到 Disqus，之前为什么会不用 Disqus 呢，主要还是担心国内不会翻墙用户无法评论的问题，后来想想其实这点不重要，因为：</p><ol><li>我的博客只是在 <a href="https://www.google.com/webmasters/tools/home#utm_source=zh-CN-wmxmsg&amp;utm_medium=wmxmsg&amp;utm_campaign=bm&amp;authuser=0" target="_blank" rel="noopener">Google Search Console</a> 添加了信息，没有在百度站长平台添加，<del>所以百度是搜索不到我的网站</del>现在貌似已经可以搜到了；既然是从谷歌搜索进入的话，那自然也就不存在不会翻墙的问题了；</li><li>不是所有的用户都需要看评论，于是我就把评论功能隐藏了起来，<del>需要的话点击下方按钮加载评论</del>，如果网络比较好的话，会自动显示，否则需要手动点击；</li></ol><p>这样优化过后，总算好多了。</p><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>原理嘛，先用 ajax 异步发送一个 get 请求至 Disqus 服务器，接收成功则屏蔽按钮，加载评论；超时则自动断开，并显示加载按钮：</p><pre><code class="ejs">&lt;button class=&quot;disqus_click_btn&quot;&gt;点击以加载评论&lt;/button&gt;&lt;%/*延迟加载 disqus，timeout 可以自己设置时长*/%&gt;&lt;script type=&quot;text/javascript&quot; id=&quot;disqus-lazy-load-script&quot;&gt;    $.ajax({    url: &#39;https://disqus.com/next/config.json&#39;,    timeout: 300,    type: &#39;GET&#39;,    success: function(){        var d = document;        var s = d.createElement(&#39;script&#39;);        s.src = &#39;//&lt;%= theme.comment.shortname %&gt;.disqus.com/embed.js&#39;;        s.setAttribute(&#39;data-timestamp&#39;, + new Date());        (d.head || d.body).appendChild(s);        $(&#39;.disqus_click_btn&#39;).css(&#39;display&#39;, &#39;none&#39;);    },    error: function() {        $(&#39;.disqus_click_btn&#39;).css(&#39;display&#39;, &#39;block&#39;);    }    });&lt;/script&gt;&lt;%/*由于我超时时长设置得比较短，所以可能翻墙了还是没有自动加载评论，这时就需要手动点击加载了*/%&gt;&lt;script type=&quot;text/javascript&quot; id=&quot;disqus-click-load&quot;&gt;    $(&#39;.btn_click_load&#39;).click(() =&gt; {  //click to load comments        (() =&gt; { // DON&#39;T EDIT BELOW THIS LINE            var d = document;            var s = d.createElement(&#39;script&#39;);            s.src = &#39;//&lt;%= theme.comment.shortname %&gt;.disqus.com/embed.js&#39;;            s.setAttribute(&#39;data-timestamp&#39;, + new Date());            (d.head || d.body).appendChild(s);        })();        $(&#39;.disqus_click_btn&#39;).css(&#39;display&#39;,&#39;none&#39;);    });&lt;/script&gt;</code></pre><p>最后，列一下我对博客的优化：</p><ol><li>使用 glup 插件压缩 html、css、js、img 等；</li><li>CloudFlare 的 CDN 加速访问资源；</li><li>ServiceWorker 提供离线访问技术；</li><li>延时加载 Disqus 评论；</li></ol><p>每一点优化我都有写文章，文章链接可以通过搜索关键字获取。</p>]]></content>
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Disqus </tag>
            
            <tag> 博客 </tag>
            
            <tag> 评论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 Service Worker 优化网站</title>
      <link href="/posts/a0df572f/"/>
      <url>/posts/a0df572f/</url>
      <content type="html"><![CDATA[<p>静态博客的内容是很适合用缓存来加速访问的，除了采用常见的 CDN 加速和压缩博文等方法，通过客户端也可以实现加速访问，本文介绍的是「服务工作线程—— Service Worker」。关于 Service Worker 的具体介绍见<a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="noopener">这里</a>。本文主要需要的是它的离线加载的特性。</p><a id="more"></a><p>本博客使用 Service Worker 可分为两个阶段，在我最初撰写本文的时候，使用的是 Service Worker 原生的接口。在不久之后，Google 推出了 <a href="https://github.com/GoogleChromeLabs/sw-toolbox" target="_blank" rel="noopener">sw-toolbox</a> 和 <a href="https://github.com/GoogleChromeLabs/sw-precache" target="_blank" rel="noopener">sw-precache</a> 用以让用户更全面的掌控 Service Worker 缓存的方式：包括版本控制、文件缓存级别、具体路径等，与、于是在经历了漫长的实践后（其实是因为懒），有了本文 Version 2.0。</p><h2 id="启用-Service-Worker"><a href="#启用-Service-Worker" class="headerlink" title="启用 Service Worker"></a>启用 Service Worker</h2><h3 id="添加注册代码"><a href="#添加注册代码" class="headerlink" title="添加注册代码"></a>添加注册代码</h3><p>以下注册代码需要在网站的根目录添加，这样才能保证接管整个网站的全部资源。</p><pre><code class="javascript">if (&#39;serviceWorker&#39; in navigator) {    navigator.serviceWorker.register(&#39;/sw.js&#39;)    .then(function() {        console.log(&#39;A new service worker is being installed.&#39;);    })    .catch(function(error) {      console.log(&#39;Service worker registration failed:&#39;, error);    });  } else {    console.log(&#39;Service workers are not supported.&#39;);  }</code></pre><p>将以上代码加入主题中，至于加在哪需要根据主题的结构决定。你只需要保证生成的静态资源中包含以上代码，那么就算添加成功。以 NexT 为例，你可以把以上代码添加到 <code></code>/next/layout/_thrid-party/comments/ ` 下的任一评论配置文件中（前提是你开启了该评论组件）。</p><h3 id="添加静态资源"><a href="#添加静态资源" class="headerlink" title="添加静态资源"></a>添加静态资源</h3><p>将以下代码保存为 <code>sw.js</code>，并确保生成静态文件的时候，<code>sw.js</code> 在网站根目录下（你可以把它放在 <code>source</code> 文件夹内）。</p><pre><code class="javascript"> &quot;use strict&quot;; (function() {     var cacheVersion = &quot;-180503&quot;;     var staticCacheName = &quot;asset&quot; + cacheVersion;     var maxEntries = 100;     self.importScripts(&quot;https://cdn.jsdelivr.net/npm/sw-toolbox@3.6.0/sw-toolbox.js&quot;);     self.toolbox.options.debug = false;     self.toolbox.options.networkTimeoutSeconds = 1;     /* staticImageCache */     self.toolbox.router.get(&quot;/(.*)&quot;,self.toolbox.cacheFirst, {         cache: {          name: staticCacheName,             maxEntries: maxEntries         }     }) })();</code></pre><p>首先指定 cacheVersion，在刷新缓存的时候会进行匹配；其次是一个 Cache Storage 名称的有关变量，我这里只是简单划分为静态资源——全部从缓存中加载的资源；关闭 debug 模式，设置 Timeout 时间为 1s。</p><p>其中 sw-toolbox 的<a href="https://github.com/GoogleChromeLabs/sw-toolbox/blob/master/docs/api.md#handlers" target="_blank" rel="noopener">缓存级别</a>共有 5 个（网络优先、缓存优先、速度优先、仅缓存、仅网络）。</p><p>我这里采用的是 <code>cacheFirst</code>，即缓存优先加载。可针对具体的资源进行不同的缓存级别分配。</p><p>其中 <code>self.toolbox.router.get</code> 表示每一个你需要操作的资源，第一个参数表示匹配的网址，第二个表示缓存级别，第三个是回调函数。</p><p>具体到以本站为例的话，你可以参考本站的<a href="https://github.com/WincerChan/MyBlog/blob/hexo/source/sw.js" target="_blank" rel="noopener">配置文件</a>。</p><h2 id="加速效果"><a href="#加速效果" class="headerlink" title="加速效果"></a>加速效果</h2><h3 id="离线"><a href="#离线" class="headerlink" title="离线"></a>离线</h3><p>可以看到在启用了 <code>Offline</code> 仍然可以加载页面</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862392/blog/sw_optimize/pic1.gif" alt="效果1"></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>刷新页面可以看到许多资源是直接 ( from ServiceWorker ) 加载的，并未发起新的 http 请求。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862438/blog/sw_optimize/pic2.gif" alt="效果2"></p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p> <a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="noopener">is Serviceworker ready</a> 详细列出了所有浏览器支持的情况。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862459/blog/sw_optimize/broswer_support.png" alt=""></p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>服务器工作线程只能工作在 HTTPS 加密的网站上，本地的 <code>localhost</code> 是默认安全。</p><p>参考文章：</p><ul><li><a href="https://developer.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="noopener">服务工作线程：简介</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration" target="_blank" rel="noopener">ServiceWorkerRegistration</a></li></ul>]]></content>
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> 博客 </tag>
            
            <tag> ServiceWorker </tag>
            
            <tag> sw-toolbox </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 实现多线程下载器</title>
      <link href="/posts/80689c8d/"/>
      <url>/posts/80689c8d/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我为什么会想到要写一个下载器呢，实在是被百度云给逼的没招了，之前用 Axel 配合直链在百度云下载视频能达到满速，结果最近两天 Axel 忽然不能用了，于是我就想着要不干脆自己写一个吧，就开始四处查询资料，这就有了这篇博客。</p><p>我假设阅读这篇博客的你已经对以下知识有所了解：</p><ul><li>Python 的文件操作</li><li>Python 的多线程</li><li>Python 的线程池</li><li>Python 的 requests 库</li><li>HTTP 报文的首部信息</li></ul><a id="more"></a><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>获取文件采用的是 requests 库，该已经封装好了许多 http 请求，我们只需要发送 get 请求，然后将请求的内容写入文件即可：</p><pre><code class="python">import requestsr = requests.get(&#39;http://files.smashingmagazine.com/wallpapers/july-17/summer-cannonball/cal/july-17-summer-cannonball-cal-1920x1080.png&#39;)with open(&#39;wallpaper.png&#39;, &#39;wb&#39;) as f:    f.write(r.content)</code></pre><p>随后看看文件夹，那张名为 <code>wallpaper.png</code> 的图片就是我们刚刚下载的。</p><p>但是这个功能太简单了，甚至简陋，我们需要多线程并发执行下载各自的部分，然后再汇总。</p><h2 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h2><p>为了拆分，首先得知道数据块的大小，HTTP 报文首部提供了这样的信息：</p><ul><li>用 head 方法去获取 http 首部信息，再从获取的信息提取出 <code>Content-Length</code> 字段（上文图片大小为 261258 bytes）</li></ul><pre><code class="python">import requestsheaders = {&#39;Range&#39;: &#39;bytes={}-{}&#39;.format(0, 100000)}r = requests.get(&#39;http://files.smashingmagazine.com/wallpapers/july-17/summer-cannonball/cal/july-17-summer-cannonball-cal-1920x1080.png&#39;, headers = headers)with open(&#39;wallpaper.png&#39;, &#39;wb&#39;) as f:    f.write(r.content)</code></pre><p>我们得到了图片的前 100001 个字节（Range 的范围是包括起始和终止的），打开 <code>wallpaper.png</code> 你应该能看到一幅“半残”的图。</p><p>这样我们里目标更近了一步，继续：</p><ul><li>确认线程数（比如 8 个），261258//8 = 32657，前 7 个线程都取 32657 个 bytes，第八个取剩余的</li></ul><pre><code class="python">part = size // numsfor i in range(nums):        start = part * i        if i == num_thread - 1:   # 最后一块            end = file_size        else:            end = start + part</code></pre><ul><li>每个线程获取到的内容按顺序写入文件（file.seek() 调节文件指针）</li></ul><pre><code class="python">def down(start, end):    headers = {&#39;Range&#39;: &#39;bytes={}-{}&#39;.format(start, end)}    # 这里最好加上 stream=True，避免下载大文件出现问题    r = requests.get(self.url, headers=headers, stream=True)    with open(filename, &quot;wb+&quot;) as fp:        fp.seek(start)        fp.write(r.content)</code></pre><p>嘛，线程多了起来就扔到线程池让它来帮我们调度。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>功能复杂了，用对象来封装整理一下：</p><pre><code class="python">class Downloader():     def __init__(self, url, num, name):        self.url = url        self.num = num        self.name = name        r = requests.head(self.url)        self.size = int(r.headers[&#39;Content-Length&#39;])     def down(self, start, end):        headers = {&#39;Range&#39;: &#39;bytes={}-{}&#39;.format(start, end)}        r = requests.get(self.url, headers=headers, stream=True)        # 写入文件对应位置        with open(self.name, &quot;rb+&quot;) as f:            f.seek(start)            f.write(r.content)    def run(self):        f = open(self.name, &quot;wb&quot;)        f.truncate(self.size)        f.close()        futures = []        part = self.size // self.num         pool = ThreadPoolExecutor(max_workers = self.num)        for i in range(self.num):            start = part * i            if i == self.num - 1:                   end = self.size            else:                end = start + part - 1            # 扔进线程池            futures.append(pool.submit(self.down, start, end))        wait(futures)</code></pre><p>至此，核心功能都完成了，剩下的就是实际体验的优化了。</p><p>完整的代码已托管至 GitHub，地址见<a href="https://github.com/WincerChan/Py-Downloader" target="_blank" rel="noopener">这里</a>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很可惜，我写的这个下载器还是不能下载百度云直链，不过嘛，好多人都说结果不重要，都说重要的是过程，不是么？写这个下载器我也确实学到了许多，至于一开始我是出于什么样的目的？管他呢</p>]]></content>
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么学习算法</title>
      <link href="/posts/af991767/"/>
      <url>/posts/af991767/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于算法，我个人的心情是挺复杂的，去年的时候有去刷过一段时间的 ACM 算法题，后来就不知怎么荒废了，直到最近看「SICP」才决定捡起来，这篇文章也算是对算法的一点感想。<br><a id="more"></a></p><h2 id="增长的阶"><a href="#增长的阶" class="headerlink" title="增长的阶"></a>增长的阶</h2><p>不同计算过程在消耗计算资源速率可能存在巨大差异。为了描述这些差异的一种方法是采用「增长的阶」的记法，分析这一过程消耗的资源也就是我们平时所说的「算法分析」。</p><p>「令 $n$ 为一个参数，它能作为问题规模的一种度量，令 $R(n)$ 是一个计算过程在处理规模为 n 的问题时所需要的资源量。</p><p>我们称 $R(n)$ 具有 $\Theta(f(n))$ 的增长阶，记为 $R(n)=Θ(f(n))$，如果存在与 $n$ 无关的整数 $k_1$ 和 $k_2$，使得：$k_1f(n)\leq R(n)\le k_2f(n)$ 对于足够大的$n$值都成立。」</p><p>有了增长的阶的定义，我们就可以对一个过程所需资源有较具体的描述，例如：在上篇<a href="../aabe7c53/">博客</a>描述的线性递归计算过程中，步骤数目增长正比于输入 $n$。也就是说，这一计算过程所需步骤增长为 $Θ(n)$，其空间需求也是 $Θ(n)$。迭代的阶乘，其步数还是 $Θ(n)$ 而空间是 $Θ(1)$，即为一个常数。本文介绍的树形递归的「斐波那契」计算需要 $Θ(\phi^n)$ 步骤和 $Θ(n)$ 的空间。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面这个定义给定基数 $b$ 和正整数指数 $n$ 来计算 $b^n$：</p><p>$b^n=b\cdot b^{n-1}$</p><p>$b^0=1$</p><p>可以直接翻译成如下过程：</p><pre><code class="lisp">(define (expt b n)  (if (= n 0)      1      (* b (expt b (- n 1)))))</code></pre><p>这是一个线性的递归计算过程，需要 $Θ(n)$ 步和 $Θ(n)$ 空间。就像阶乘和「斐波那契」，我们很容易将其形式化为一个等价的线性迭代：</p><pre><code class="lisp">(define (expt b n)  (expt-iter b n 1))(define (expt-iter b counter product)  (if (= counter 0)      product      (expt-iter b                 (- counter 1)                 (* b product))))</code></pre><p>这一版本需要 $Θ(n)$ 步和 $Θ(1)$ 空间。这一算法自然比一算法更好，复杂度更低，那么，还能更优化吗？</p><p>我们可以采用递归的思想，把问题转化为规模较小的子问题。例如：不是以采用下面这样的方式算 $b^8$：</p><p>$b\cdot(b\cdot(b\cdot(b\cdot(b\cdot(b\cdot(b\cdot b))))))$</p><p>而是用连续求平方，以更少的步骤完成计算：<br>$b^8=b^4\cdot b^4$<br>$b^4=b^2\cdot b^2$<br>$b^2=b\cdot b$</p><p>这一方法对于指数是 2 的乘幂都可以用。如果采用下面规则，我们就可以借助于连续求平方，来完成一般性的乘幂运算：</p><p>$b^n=(b^{n/2})^2$                若 $n$ 是偶数</p><p>$b^n=b\cdot b^{n-1}$                若 $n$ 是奇数</p><p>这一方法翻译为如下程序：</p><pre><code class="lisp">(define (fast-expt b n)  (cond ((= n 0) 1)        ((even? n) (square (fast-expt b (/ n 2))))        (else (* b (fast-expt b (- n 1))))))(define (even? n)  (= (remainder n 2) 0))</code></pre><p>这一计算过程，在空间和步数上相对于 $n$ 都是对数的：用 <code>fast-expt</code> 计算 $b^{2n}$的时候，只需要比 $b^n$ 多做一次乘法。能够计算的指数值大约增长一倍。这样，计算指数 $n$ 所需要乘法次数增长大约以 $2$ 为底 $n$ 的对数值，这一计算过程增长的阶为 $\Theta(log\ n)$。</p><p>随着 $n$ 变大，$\Theta(log\ n)$ 增长与 $\Theta(n)$ 增长差异会变得非常明显。当 $n =1000$ 时，<code>fast-expt</code> 只需要 $14$ 次乘法。</p><p>当然，我们同样可以通过连续求平方的方法，设计一个对数步数的计算乘幂的迭代算法：</p><pre><code class="lisp">(define (even? n) (= (remainder n 2) 0))(define (fast-expt b n) (fast-expt-iter b n 1))(define (fast-expt-iter b counter product) (cond ((= counter 0) 1)       ((even? counter) (square (fast-expt-iter b (/ counter 2) (* product b))))       (else (* b (fast-expt-iter b (- counter 1) (* product b))))))</code></pre><p>这一计算过程需要 $\Theta(log\ n)$ 步，$\Theta(1)$ 空间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你越努力的去思考、将算法的复杂度降的越低，算法应用于程序所占用的资源就越少，尽管该程序会不那么直截了当，但这是值得的。</p>]]></content>
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SICP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树形递归</title>
      <link href="/posts/99a81f4c/"/>
      <url>/posts/99a81f4c/</url>
      <content type="html"><![CDATA[<h2 id="树形递归"><a href="#树形递归" class="headerlink" title="树形递归"></a>树形递归</h2><p>与上一篇介绍的「<a href="https://www.itswincer.com/posts/aabe7c53/" target="_blank" rel="noopener">线性递归</a>」类似的另一种常见计算模式为「树形递归」。本质嘛，可以看作许多分支的线性递归。</p><a id="more"></a><p>还是直接上具体的例题。</p><p>「斐波那契数列<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" target="_blank" rel="noopener">^1</a>」的定义如下<img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861989/blog/tree_recursion/fib.png" alt="v"></p><p>看到这个定义我们马上就能把它编写成程序：</p><pre><code class="lisp">(define (fib n)  (cond ((= n 0) 0)        ((= n 1) 1)        (else (+ (fib (- n 1))                 (fib (- n 2))))))</code></pre><p>这个程序完全就是按照定义来的，定义怎么说我就怎么写，不需要什么额外的思考。</p><p>来分析一下，如果我们需要计算 <code>(fib 5)</code>，就需要计算出 <code>(fib 4)</code> 和 <code>(fib 3)</code>。而为了计算 <code>(fib 4)</code>，又需要计算出 <code>(fib 3)</code> 和 <code>(fib 2)</code>。将这一过程展开后会像一棵数，如下图所示。这里的每一层都分裂为两个分支（除了最下面），也就是说对 <code>fib</code> 函数的每个调用中都包含了两次调用自身。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-13.gif" alt="fib"></p><p>这是一个很经典的树形递归的例子，但是它的计算效率太低了，做了太多的冗余计算。在图中求 <code>(fib 3)</code> 这个过程重复了 2 次。或者更明白的说：<code>Fib(n)</code> 值的增长对于 <code>n</code> 是指数的。<code>Fib(n)</code> 是最接近 $\phi^n/\sqrt5$ 的整数，其中 $\phi$ 满足 $\phi^2=\phi+1$，证明过程见<a href="https://github.com/WincerChan/sicp/blob/master/chapter1/e1.13.png" target="_blank" rel="noopener">这里</a>。</p><p>也就是说这个 <code>Fib(n)</code> 计算过程随着输入 <code>n</code> 的增长而指数性增长。而空间需求是线性增长，为什么呢？因为在计算中的每一点，我们只需要保存树中在此之上节点的轨迹。具体的，当我们所处的位置是 <code>Fib(3)</code> 的时候，只需要保存的轨迹是如何到达 <code>Fib(3)</code> 的就行了，至于后续是如何的，那不是当前 <code>Fib(3)</code> 所需要考虑的。</p><p>一般说，树形递归计算过程所需的步骤数正比于树中的结点数，其空间需求正比于数的最大深度。</p><h2 id="迭代转化"><a href="#迭代转化" class="headerlink" title="迭代转化"></a>迭代转化</h2><p>我们当然可以规划一种迭代计算过程来计算「斐波那契数列」，基本想法是用一对整数 $a$ 和 $b$，将它们分别初始化为 <code>Fib(1)=1</code> 和 <code>Fib(0)=0</code>，而后反复使用下面规则变换：</p><p>$a\longleftarrow a+b$</p><p>$b\longleftarrow a$</p><p>在应用了这些变换后，$a$ 和 $b$ 将分别等于 <code>Fib(n+1)</code> 和 <code>Fib(n)</code>。因此，我们可以编成以下程序：</p><pre><code class="lisp">(define (fib n)  (fib-iter 1 0 n))(define (fib-iter a b count)  (if (= count 0)      b      (fib-iter (+ a b) a (- count 1))))</code></pre><p>这种方法的计算步骤相对于 $n$ 来说是线性的，与上一个方法差距巨大。那么，到底有多大呢？我们编写一个程序测试：</p><pre><code class="lisp">(define (Fibo n start)  (fib n)  (- (real-time-clock) start));递归方法：(单位为ms)1 ]=&gt; (Fibo 30 (real-time-clock));Value: 12141 ]=&gt; (Fibo 31 (real-time-clock));Value: 17351 ]=&gt; (Fibo 32 (real-time-clock));Value: 2793;迭代方法：1 ]=&gt; (Fibo 1000 (real-time-clock));Value: 11 ]=&gt; (Fibo 5000 (real-time-clock));Value: 61 ]=&gt; (Fibo 10000 (real-time-clock));Value: 13</code></pre><p>当然这个并不严谨，实际的算法分析还是要根据数学公式推导、证明，但足以让我们感受到这二者方法的 天差地别。</p><p>当然也不能说树形递归计算过程根本没有用。因为树形递归计算过程可以帮助我们理解和设计程序。以「斐波那契数列」为例，虽然第一个方法远比第二个低效，但却更加直截了当，基本就是把定义翻译成了 Lisp 语言。</p><p><strong>本文系本人阅读 SICP 时所做的笔记，全部笔记可在标签 SICP 中查看</strong></p>]]></content>
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SICP </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>谈谈递归和迭代</title>
      <link href="/posts/aabe7c53/"/>
      <url>/posts/aabe7c53/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首次接触递归（recursion）这个概念是在学习 C 语言的时候，当时老师是根据「汉诺塔」<a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E8%AF%BA%E5%A1%94" target="_blank" rel="noopener">^1</a>这一具体问题的求解来介绍递归这个概念，至于迭代（iterate），好像 C 语言老师压根没提这个概念，第一次是在 MIT 的 Python 导论中听说的，但当时听完之后也只是对迭代和递归只有极其有限的了解。正好借着 SICP，好好弄清楚二者的概念。</p><a id="more"></a><p>首先明确二者的概念：</p><ul><li><p>递归：是指在函数的定义中使用函数自身的方法。</p></li><li><p>迭代：迭代是程序中对一组指令（或一定步骤）的重复。在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。<br>循环，则是一种更宽泛的概念，凡是重复执行的一段代码，都可以称之循环，它是作为一种控制流程存在的，它与递归和迭代不同，个人认为递归和迭代更像是一种算法思想，而循环结构则是这种思想在程序中的一种体现方式。</p></li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>用一个具体的题目来说明一下。</p><p>定义一个阶乘函数：<br>$$n!=n\times(n-1)\times(n-2)\times\cdots\times3\times2\times1$$<br>有一种很容易想到的计算方式就是：对于一个正整数 $n$，$n!$ 就等于 $n$ 乘以 $(n-1)!$:<br>$$n!=n\times[(n-1)\times(n-2)\times\cdots\times3\times2\times1]=n\times(n-1)!$$<br>这样我们就能通过算出 $(n-1)!$，并将其结果乘以 $n$ 的方式来计算出 $n!$。再注意到 $1!$ 就是 $1$，我们就可以出编写一个程序：</p><pre><code class="lisp">(define (factorial n)  (if (= n 1)      1      (* n (factorial (- n 1)))))</code></pre><p>我们采取代换模型分析以下当这个程序在计算 $6!$ 时的具体过程。</p><pre><code class="lisp">(factorial 6)(* 6 (factorial 5))(* 6 (* 5 (factorial 4)))(* 6 (* 5 (* 4 (factorial 3))))(* 6 (* 5 (* 4 (* 3 (factorial 2)))))(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))(* 6 (* 5 (* 4 (* 3 (* 2 1)))))(* 6 (* 5 (* 4 (* 3 2))))(* 6 (* 5 (* 4 6)))(* 6 (* 5 24))(* 6 120)720</code></pre><p>递归的代换模型显示的是一种逐步展开而后收缩的形状。在展开的阶段中，这一计算过程构造了一个「推迟进行」的操作所形成的链条，收缩阶段表现为这些运算的实际执行。这种类型的计算过程由一个「推迟进行」的运算链条刻画，称之为「递归计算过程」。</p><p>要执行这种计算过程，解释器（或者编译器）就需要保护好那些以后将要执行的操作的轨迹。</p><p>在计算 $n!$ 时，推迟执行的乘法链条的长度就是为保存其轨迹需要保存的信息量，这个长度随着 $n$ 值而线性增长，就像计算中的步骤数目一样。这样的计算过程成为<strong>线性递归过程</strong>。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>我们同样可以将计算阶乘$n!$的规则描述为：先乘 $1$ 和 $2$，而后将结果乘以 $3$，而后再乘以 $4$，这样下去直到到达 $n$。更程序化的说，我们要保存一个变动的乘积 <code>product</code>，以及一个从 $1$ 到 $n$ 的计数器 <code>counter</code>，这一计算过程可以描述为 <code>counter</code> 和 <code>product</code> 的如下变化，每一步都按照如下变化<br>​     $$product \longleftarrow counter\times product$$<br>​     $$counter \longleftarrow counter+1$$<br>可以看到，$n!$ 也就是当 <code>counter</code> 超过 $n$ 的时候成绩 <code>product</code> 的值。</p><p>将上述描述编写成程序：</p><pre><code class="lisp">(define (factorial n)  (fact-iter 1 1 n))(define (fact-iter product counter max-count)  (if (&gt; counter max-count)      product      (fact-iter (* counter product)                 (+ counter 1)                 max-count)))</code></pre><p>与递归类似，同样采取代换模型来查看 $6!$ 详细过程：</p><pre><code class="lisp">(factorial 6)(factorial 1 1 6)(factorial 1 2 6)(factorial 2 3 6)(factorial 6 4 6)(factorial 24 5 6)(factorial 120 6 6)(factorial 720 7 6)</code></pre><p>迭代的计算过程并没有任何增长或者收缩。对于任意一个 $n$，在计算过程中的每一步，我们所需要保存的就只有变量 <code>product</code>、<code>counter</code>、<code>max-count</code> 的<strong>当前值</strong>。这种过程就称为「迭代计算过程」。</p><p>「迭代计算过程」就是状态可以用固定数目的变量来描述的计算过程，但不仅仅如此，还需要一套规则来描述计算过程从这个状态到下一状态转换时，这些变量的更新方式以及结束时的检测。</p><p>在计算 $n!$ 的时候，所需计算步骤随着 $n$ 线性增长，这种过程成为<strong>线性迭代过程</strong>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在做迭代和递归之间比较的时候，我们需要注意「递归计算过程」和「递归过程」的概念。当我们说一个程序是递归的时候，论述的是一个程序在语法层面上的一种形式：（直接或者间接地）引用了该程序的本身。在说某一计算过程具有某种模式时，我们说的是这一计算过程的进展方式（如，先伸展后收缩等等），而不是书写相应程序所体现的语法形式。</p><p>我们可以说 <code>fact-iter</code> 是一个递归过程（调用了自身），但是 <code>fact-iter</code> 产生的是一个迭代的计算过程，这么说可能会感觉很不舒服，甚至第一次听还会觉得这句话是错误的。但是这一计算过程确实是迭代的，因为它的状态由三个变量刻画就足够了。</p><p><strong>本文系本人阅读 SICP 时所做的笔记，全部笔记可在标签 SICP 中查看</strong></p>]]></content>
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SICP </tag>
            
            <tag> 递归 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 的迭代器和生成器</title>
      <link href="/posts/903c6509/"/>
      <url>/posts/903c6509/</url>
      <content type="html"><![CDATA[<p>我最初接触 Python 是在 17 年 2 月份，现在半年过去了，对迭代器和生成器的概念却及其有限，其实也是因为其它主流语言如：C、Java 中没有生成器的概念，所以当时学了就忘了。现在正准备好好复习一下迭代器和生成器。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代（即可以通过 <code>for</code> 循环去遍历）获取，可以用 <code>in</code>，<code>not in</code> 关键字判断元素是否包含在容器中。</p><p>在 Python 中，常见的容器对象有：</p><ul><li>list, deque</li><li>set, frozensets</li><li>dict, defaultdict, OrderedDict, Counter</li><li>tuple, namedtuple</li><li>str</li></ul><a id="more"></a><p>容器的概念比较容易理解，你可以把它看作一个盒子、一间屋子，里面可以塞许多东西。从某种意义来说，当它可以被询问某个元素是否包含在其中时，那么它就可以认为是一个容器。比如 <code>list</code>、<code>set</code>、<code>tuple</code> 等都是容器对象：</p><pre><code class="python">&gt;&gt;&gt; assert 1 in [1, 2, 3]    &gt;&gt;&gt; assert 4 not in [1, 2, 3]&gt;&gt;&gt; assert 1 in {1: &#39;foo&#39;, 2: &#39;bar&#39;, 3: &#39;qux&#39;}&gt;&gt;&gt; assert &#39;foo&#39; not in {1: &#39;foo&#39;, 2: &#39;bar&#39;, 3: &#39;qux&#39;}  &gt;&gt;&gt; assert &#39;b&#39; in &#39;foobar&#39;&gt;&gt;&gt; assert &#39;x&#39; not in &#39;foobar&#39;</code></pre><p>尽管绝大多数容器都提供了迭代的方式来获取其中每一个元素，但这并不是容器本身的能力，而是当容器对象需要提供迭代功能的时候，<strong>可迭代对象</strong>赋予了容器这种能力。</p><h2 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h2><p>迭代器协议是指对象需要提供 <code>__iter__()</code>、<code>__next__()</code> 方法，其中：</p><ul><li><code>__iter__()</code>返回迭代器对象本身</li><li><code>__next__()</code>从容器中返回迭代中的下一项，要么引起一个 <code>StopIteration</code> 异常，以终止迭代</li></ul><p>而迭代器对象就是实现了迭代器协议的对象。</p><pre><code class="python">&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; y = x.__iter__()&gt;&gt;&gt; type(x)&lt;class &#39;list&#39;&gt;&gt;&gt;&gt; next(x)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#39;list&#39; object is not an iterator&gt;&gt;&gt; type(y)&lt;class &#39;list_iterator&#39;&gt;&gt;&gt;&gt; next(y)1</code></pre><p>这里的 <code>x</code> 就是一个可迭代对象（但并不是一个迭代器，注意看报错），可迭代对象和容器一样是一种通俗的叫法，不是某种具体的数据类型。<code>y</code> 是一个迭代器，具体来说 <code>y</code> 的迭代器类型是 <code>list_iterator</code>。可迭代对象实现了 <code>__iter__()</code>，该方法返回一个迭代器对象。</p><p>对 Python 稍微熟悉的朋友应该知道，<code>for</code> 循环不但可以用来遍历 <code>list</code>，还可以来遍历文件对象：</p><pre><code class="python">&gt;&gt;&gt; f = open(&#39;test.txt&#39;, &#39;r&#39;) &gt;&gt;&gt; type(f)&lt;_io.TextIOWrapper name=&#39;test.txt&#39; mode=&#39;r&#39; encoding=&#39;UTF-8&#39;&gt;&gt;&gt;&gt; for line in f:        print(line)...&gt;&gt;&gt; next(f)...</code></pre><p>为什么在 Python 中，文件还可以使用 <code>for</code> 循环遍历呢，这是因为文件对象实现了迭代器协议，<code>for</code> 循环并不知道它遍历的是一个文件爱呢对象，它只需要使用迭代器协议访问对象即可。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>那么什么才是迭代器呢？它是一个带状态的对象，能在调用 <code>next()</code> 方法的时候返回容器下一个值，任何遵循了迭代器协议的对象都是迭代器。</p><p>为了更直观感受迭代器内部执行，我们自己定义一个迭代器，以斐波那契数列为例：</p><pre><code class="python">class Fib:    def __init__(self):        self.prev, self.curr = 0, 1    def __iter__(self):        return self    def __next__(self):        value = self.curr        self.curr += self.prev        self.prev = value        return value&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f&lt;__main__.Fib object at 0x7f383fbdd438&gt;&gt;&gt;&gt; for x in range(5):...     next(f)... 11235</code></pre><p>Fib 既是一个可迭代对象（实现了 <code>__iter()</code> 方法），又是一个迭代器（实现了 <code>__next__()</code> 方法）。变量 <code>prev</code> 和 <code>curr</code> 用户维护迭代器内部的状态。每次调用 <code>next()</code> 方法的时候做两件事：</p><ol><li>为下一次调用 <code>next()</code>方法修改状态</li><li>为当前这次调用生成返回结果</li></ol><p>迭代器使用的是惰性计算，等到有需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>在 Python 这门语言中，生成器算得上最有用的特性之一了，也算是使用最不广泛的特性之一。原因嘛，就像我开头所说的，其它主流语言没有这个概念。</p><p>生成器是一种特殊的迭代器，不过这种迭代器更加优雅。它不再需要上面的类一样需要写 <code>__iter__()</code>、<code>__next__()</code> 方法，只需要一个 <code>yield</code> 语句，<code>yield</code> 语句一次返回一个结果，在返回结果之后，挂起函数，以便下次从离开的地方继续执行。下面用生成器来实现斐波那契数列：</p><pre><code class="python">def Fib():    prev, curr = 0, 1    while True:        yield curr        prev, curr = curr, curr + prev&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f&lt;generator object Fib at 0x7f307048e570&gt;&gt;&gt;&gt; &gt;&gt;&gt; for x in range(5):...     next(f)... 11235</code></pre><p>当执行 <code>f = Fib()</code> 的时候返回的是一个生成器的对象，此时函数体的代码并没有执行，只有调用 <code>next()</code> 的时候才会真正执行代码。</p><p>除了给函数加上 <code>yield</code>语句之外，还有一种方法创建生成器，只要把一个列表生成式的 <code>[]</code> 改成 <code>()</code>，就创建了一个生成器：</p><pre><code class="python">&gt;&gt;&gt; L = [x for x in range(5)]&gt;&gt;&gt; L[0, 1, 2, 3, 4]&gt;&gt;&gt; G = (x for x in range(5))&gt;&gt;&gt; G&lt;generator object &lt;genexpr&gt; at 0x7f307048e5c8&gt;</code></pre><p>生成器在 Python 中是非常强大的，可以更少的使用中间变量，也可以更少的占用内存空间，而且可以缩减代码量来维持相同的功能：</p><pre><code class="python">def something():    result = []    for x in ... :        result.append(x)    return result</code></pre><p>类似的都可以用生成器来替换：</p><pre><code class="python">def gen_something():    for x in ... :        yield x</code></pre><p><strong>注意事项：生成器只能遍历一次</strong></p>]]></content>
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>导出 QQ 聊天记录</title>
      <link href="/posts/1060d444/"/>
      <url>/posts/1060d444/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从 2013 年开始，手机 QQ 就已经不支持私人聊天记录的导出功能了（群聊的记录还是可以导出），目的当然是为了推广超级会员，毕竟超级会员的聊天记录有 2 年漫游时间，而不想给腾讯送钱的我，就只好另辟蹊径了。<a id="more"></a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>我并不算是那种埋头造轮子的人，所以遇到问题总是先问谷歌，确实也寻找到了一些工具，可惜有的不能用能用的还要收费。看来还是需要自己动手（当然，不动手也就没有这篇文章了）。</p><h3 id="数据库位置"><a href="#数据库位置" class="headerlink" title="数据库位置"></a>数据库位置</h3><p>安卓手机 QQ 的数据库文件保存在 <code>data/data/com.tencent.monileqq/databases/{QQ 号}.db</code> 下，所以一般情况下需要 Root，当然用 adb 工具也可以，这里并非本文的重点，就不展开说了。数据库里面不仅有聊天记录，基本上包括了 QQ 号的所有信息。</p><p>不幸的是，里面的重要数据被加密了。</p><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><p>另外很幸运的是，加密方式采用的是「<a href="https://zh.wikipedia.org/zh-hans/%E5%BC%82%E6%88%96%E5%AF%86%E7%A0%81" target="_blank" rel="noopener">异或加密</a>」，而用于加密的字符串就是你手机的 <a href="https://zh.wikipedia.org/wiki/IMEI" target="_blank" rel="noopener">IMEI</a>，所有手机的 IMEI 都是不同的，这样也可以确保加密后的数据是唯一的，既然知道了加密方式和密钥，那么解密自然也就不是难事了。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>先想一下，我们聊天记录想导出成什么格式：</p><p>我的想法是：<code>时间--发信人--内容</code> 这样的格式。打开数据库文件：</p><p>如下图，mr_friend_** **_New 就是你与每一个好友聊天的信息，包括昵称、备注、qq 号码、聊天记录等，直接查看就会发现是被加密过的。这一串 32 位的字符串就是 QQ 号码的 md5 值。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862867/blog/export_chat_record/md5.png" alt=""></p><p>由于 QQ 在手机端使用的数据库是 sqlite，Python 有很方便的 sqlite 的工具，而且 Python 针对字符串处理很方便，这里就采用 Python 来解密。</p><p>用浏览工具打开数据库，以我的数据库为例：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862890/blog/export_chat_record/database.png" alt=""></p><p><code>msgData</code> 保存的就是聊天记录，<code>selfuin</code> 就是聊天对象的 QQ 号码，<code>time</code>就是发送消息的时间，既然知道了这三个就是我们想要的，那么接下来的就好办多了，解密这三个就好了。</p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>既然牵扯到解密，自然也就逃不掉编码和解码。尤其是 <code>msgData</code> 项，确实是花费了我好久才解决（哼，我才不会说这是因为我对 Python 的编码不熟悉呢）。</p><p>代码已托管至 Gist，见<a href="https://gist.github.com/362331456a6e0417c5aa1cf3ff7be2b7.git" target="_blank" rel="noopener">这里</a>。</p><p>参考：</p><ul><li><a href="http://www.freebuf.com/articles/terminal/68224.html" target="_blank" rel="noopener">用 Python 解密手机 QQ 聊天记录</a></li></ul>]]></content>
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> QQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编程入门指南</title>
      <link href="/posts/48621277/"/>
      <url>/posts/48621277/</url>
      <content type="html"><![CDATA[<p>作者：<a href="https://www.zhihu.com/people/fd7c571a0ada1a72e42e8d7992c4a780" target="_blank" rel="noopener">@萧井陌</a>，<a href="https://www.zhihu.com/people/d2facf05b7138a6eb4631a161915f7d4" target="_blank" rel="noopener">@Badger</a></p><p>自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如今编程成为了一个越来越重要的「技能」：作为设计师，懂一些编程可能会帮你更好地理解自己的工作内容；作为创业者，技术创始人的身份则会让你的很多工作显得更容易。而作为刚想入门的新手，面对眼前海量的信息，或许根本不知道从哪里开始；入门轻松度过初级材料的学习后，发现学习越来越困难，陡峭的学习曲线又让你望而却步；你知道如何在页面上打印输出一些文本行，但是你不知道何时该进行一个真正的有用的项目；你不清楚自己还有哪些不知道的东西，你甚至搞不清下一步该学什么。</p><p>这篇文章的内容对此不仅会有一些方向性的建议，还会包含一个<strong>基础核心向</strong>的编程入门导引。当然，Step by Step 的路线是不现实的，并且每个人都会有自己的特点，所以给出的这个编程入门导引更多的是为了引发读者的思考，最终帮助你形成适用于自己的学习路线。</p><a id="more"></a><p>但要注意：这篇文章是写给那些真心想学编程的人看的——那些憋着一股狠劲儿，一定要做出个什么真东西，不学好不罢休的人；而不是那些「听说编程好玩」的人，在我看来，这种人永远都入不了编程的门，更别提做出个像样的东西来了。</p><p>「Disclaimer」：虽然整篇文章的基调都是所谓的「Strong Opinions, Weakly Held」，但读者还是应该像怀疑身边所有东西那样 怀疑我们所写内容的准确性。若有任何相关疑问欢迎在知乎或技术社区 <a href="http://cocode.cc/" target="_blank" rel="noopener">CoCode</a> 公开讨论。</p><h2 id="心态调整"><a href="#心态调整" class="headerlink" title="心态调整"></a>心态调整</h2><h3 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h3><p>在你学习编程之前思考一下你的目标，当你有最终目标时道路会更加的清晰。那么，你想要写什么？网站？游戏？iOS 或者 Android 应用？或是你是想自动化完成一些乏味的任务让你有更多的时间看窗外的风景？也许你只是想更具有就业竞争力找个好工作。所有的这些都是有价值的目标，这些目标都是你编程学习推动力的一部分，没有推动力的人，是无法在略显枯燥的漫长学习之旅中走远的。</p><p>这段视频也许能给你启发：<a href="http://v.youku.com/v_show/id_XNTIzNzE2NzQ4.html" target="_blank" rel="noopener">What Most Schools Don’t Teach</a></p><h3 id="不要浮躁"><a href="#不要浮躁" class="headerlink" title="不要浮躁"></a>不要浮躁</h3><p>Bad programming is easy. Even Dummies can learn it in 21 days. Good programming requires thought, but everyone can do it and everyone can experience the extreme satisfaction that comes with it.</p><p>不管是在线下还是线上的书店，满目都是《21 天学通 X》这种速成书目，它们都承诺在很短一段时间内就让你能够学会相关技术。Matthias Felleisen 在他的著作 <a href="http://www.ccs.neu.edu/home/matthi" target="_blank" rel="noopener">How to Design Programs</a> 一书中明确指出了这种「速成」的趋势并予以了以上的讽刺。</p><p>所谓的「捷径」或者说「<a href="http://en.wikipedia.org/wiki/No_Silver_Bullet" target="_blank" rel="noopener">银弹</a>」是不存在的，智者说过，精通某个东西需要 10 年或 10000 个小时，也就是汉语中的「十年磨一剑」，所以不用着急，功不唐捐。</p><h3 id="培养兴趣"><a href="#培养兴趣" class="headerlink" title="培养兴趣"></a>培养兴趣</h3><p>Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program.</p><p>–<a href="http://en.wikipedia.org/wiki/Linus_Torvalds" target="_blank" rel="noopener">Linus Torvalds</a></p><p>沉醉于编程，编程更是为了兴趣。兴趣是推动力的不竭源泉，保持这种充满兴趣的感觉，以便于你能将其投入到你的 10 年（10000 小时）的编程时间中。编程很有趣，那是探索的喜悦。那是创造的喜悦。看到自己亲手完成的作品显示在屏幕上很有趣。有人为你的代码而惊叹很有趣。有人在公共场合称赞你的产品、邻居使用你的产品、以及在媒体上讨论你的产品很有趣。编程应该十分有趣，若并非如此，就找出导致编程无趣的问题，然后解决之。</p><h2 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h2><h3 id="令人警醒的故事"><a href="#令人警醒的故事" class="headerlink" title="令人警醒的故事"></a>令人警醒的故事</h3><p>刚上初中时我便开始了编程学习，很不幸，我读完了好几本当时普遍存在的诸如《21 天精通 C++》这类的垃圾书，当时读完也无大碍，甚至还能写点小程序。但是软件出故障了我不知道为什么，稍显庞大的编程问题无从下手，碰到现有的库做不到的事也只能两手一摊。虽然我每天不停地编码，但我发现自己的编程能力却是提高的如此缓慢，对于「迭代」与「递归」的概念只有极其有限的了解，可以说只是把计算机当成了计算器来使用。</p><p>进入大学后，我主修了物理学，最初的一段时间里我一直在记忆背诵那些物理公式，却不理解她们是如何得出的，她们之间有什么联系，亦或是她们的意义。我不停地学习如何计算解答一些常见的物理问题，却对在这些 How 背后的 Why 一无所知。</p><p>而在我尝试做一些基于物理行为的电脑游戏时我再次遇到了之前的的困难：面对新问题时无从下手，面对新问题时的恐惧不断累积滋生，我开始主动逃避，不去真正地理解，而是幻想能通过 Google 搜索复制粘贴代码解决问题。幸运的是，大二时的一堂课完全改变了我的学习方法。那是第一次我有了「开天眼」的感觉，我痛苦地意识到，我对一些学科只有少的可怜的真正的理解，包括我主修的物理与辅修的计算机科学。</p><p>关于那堂课：那时我们刚刚学习完电学和狭义相对论的内容，教授在黑板上写下了这两个主题，并画了一根线将他们连了起来。「假设我们有一个电子沿导线以相对论级别的速度移动……」，一开始教授只是写下了那些我们所熟悉的电学与狭义相对论的常见公式，但在数个黑板的代数推导后，磁场的公式神奇的出现了。虽然几年前我早已知道这个公式，但那时我根本不知道这些现象间的有着这样潜在的联系。磁与电之间的差别只是「观察角度」的问题，我猛然醒悟，此后我不再仅仅追求怎么做 (How)，我开始问为什么 (why)，开始回过头来，拾起那些最基础的部分，学习那些我之前我本该好好学的知识。这个回头的过程是痛苦的，希望你们能就此警醒，永远不要做这种傻事。</p><h3 id="警醒后的反思"><a href="#警醒后的反思" class="headerlink" title="警醒后的反思"></a>警醒后的反思</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862811/blog/program_tutotial/mu.png" alt="MU" title="MU"></p><p>这幅图取自 Douglas Hofstadter 的著作 <a href="http://en.wikipedia.org/wiki/G" target="_blank" rel="noopener">Gödel, Escher, Bach</a>。图中的每一个字母都由其他更小的字母组成。在最高层级，我们看的是 “MU”，M 这个字母由三个 HOLISM （<a href="http://zh.wikipedia.org/wiki/%25E6%2595%25B4%25E5%2585%25A8%25E8%25A7%2580" target="_blank" rel="noopener">整全观</a>）构成，U 则是由一个 REDUCTIONISM （<a href="http://zh.wikipedia.org/wiki/%2525E8%2525BF%252598%2525E5%2525" target="_blank" rel="noopener">还原论</a>）构成，前者的每一个字母都包含后者的后者整个词，反之亦然。而在最低层级，你会发现最小的字母又是由重复的 “MU” 组成的。</p><p>每一层次的抽象都蕴含着信息，如果你只是幼稚地单一运用整体论在最高层级观察，或运用还原论观察最低层级，你所得到的只有 “MU” （在一些地区的方言中 mu 意味着什么都没有）。问题来了，怎样才能尽可能多的获取每个层级的信息？或者换句话说，该怎样学习复杂领域（诸如编程）包含的众多知识？</p><p>教育与学习过程中普遍存在一个关键问题：初学者们的目标经常过于倾向<a href="http://zh.wikipedia.org/wiki/%25E6%2595%25B4%25E5%2585%25A8%25E8%25A7%2580" target="_blank" rel="noopener">整全观</a>而忽略了基础，举个常见的例子，学生们非常想做一个机器人，却对背后的</p><p>理解物理模型 → 理解电子工程基础 → 理解伺服系统与传感器 → 让机器人动起来</p><p>这一过程完全提不起兴趣。</p><p>在这里对于初学者有两个大坑：</p><ol><li>如果初学者们只与预先构建好的「发动机和组件」接触（没有理解和思考它们构造的原理），这会严重限制他们在将来构建这些东西的能力，并且在诊断解决问题时无从下手。</li><li>第二个坑没有第一个那么明显：幼稚的「整体论」方法有些时候会显得很有效，这有一定的隐蔽性与误导性，但是一两年过后（也许没那么长），当你在学习路上走远时，再想回过头来「补足基础」会有巨大的心理障碍，你得抛弃之前自己狭隘的观念，耐心地缓步前进，这比你初学时学习基础知识困难得多。</li></ol><p>但也不能矫枉过正，陷入还原论的大坑，初学时便一心试图做宏大的理论，这样不仅有一切流于理论的危险，枯燥和乏味还会让你失去推动力。这种情况经常发生在计算机科班生身上。</p><p>为了更好理解，可以将学习编程类比为学习厨艺：你为了烧得一手好菜买了一些关于菜谱的书，如果你只是想为家人做菜，这会是一个不错的主意，你重复菜谱上的步骤也能做出不赖的菜肴，但是如果你有更大的野心，真的想在朋友面前露一手，做一些独一无二的美味佳肴，甚至成为「大厨」，你必须理解这些菜谱背后大师的想法，理解其中的理论，而不仅仅是一味地实践。但是如果你每天唯一的工作就是阅读那些厚重的理论书籍，因为缺乏实践，你只会成为一个糟糕的厨子，甚至永远成为不了厨子，因为看了几天书后你就因为枯燥放弃了厨艺的学习。</p><p>总之，编程是连接理论与实践的纽带，是<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>与计算机应用技术相交融的领域。正确的编程学习方法应该是：通过自顶而下的探索与项目实践，获得编程直觉与推动力；从自底向上的打基础过程中，获得最重要的通用方法并巩固编程思想的理解。</p><p>作为初学者，应以后者为主，前者为辅。</p><h3 id="启蒙"><a href="#启蒙" class="headerlink" title="启蒙"></a>启蒙</h3><p>「学编程应该学哪门语言？」这经常是初学者问的第一个问题，但这是一个错误的问题，你最先考虑的问题应该是「哪些东西构成了编程学习的基础」？</p><p>编程知识的金字塔底部有三个关键的部分：</p><ol><li>算法思想：例如怎样找出一组数中最大的那个数？首先你得有一个 maxSoFar 变量，之后对于每个数……</li><li>语法：我怎样用某种编程语言表达这些算法，让计算机能够理解。</li><li>系统基础：为什么 while(1) 时线程永远无法结束？为什么 int *foo() { int x = 0; return &x; } 是不可行的？</li></ol><p>启蒙阶段的初学者若选择 C 语言作为第一门语言会很困难并且枯燥，这是因为他们被迫要同时学习这三个部分，在能做出东西前要花费很多时间。</p><p>因此，为了尽量最小化「语法」与「系统基础」这两部分，建议使用 Python 作为学习的第一门语言，虽然 Python 对初学者很友好，但这并不意味着它只是一个「玩具」，在大型项目中你也能见到它强大而灵活的身影。熟悉 Python 后，学习 C 语言是便是一个不错的选择了：学习 C 语言会帮助你以靠近底层的视角思考问题，并且在后期帮助你理解操作系统层级的一些原理。</p><p>下面给出了一个可供参考的启蒙阶段导引，完成后你会在头脑中构建起一个整体框架，帮助你进行自顶向下的探索。下面的材料没有先后顺序，如果卡壳的话可以考虑换另一份材料。</p><ol><li>完成 [MIT 6.00.1x]（<a href="http://www.xuetangx.com/courses/course-v1%3AMITx%2B6_00_1x%2Bsp/about" target="_blank" rel="noopener">麻省理工：计算机科学和 Python 编程导论</a>）。虽然该课程的教学语言为 Python，但作为一门优秀的导论课，它强调学习计算机科学领域里的重要概念和范式，而不仅仅是教你特定的语言。如果你不是科班生，这能让你在自学时开阔眼界；课程内容：计算概念，Python 编程语言，一些简单的数据结构与算法，测试与调试。</li><li>完成 <a href="https://www.edx.org/course/introduction-computer-science-harvardx-cs50x" target="_blank" rel="noopener">Harvard CS50x</a> （<a href="http://v.163.com/special/opencourse/cs50.html" target="_blank" rel="noopener">哈佛大学：计算机科学</a>）。同样是导论课，但这门课与 MIT 的导论课互补。教学语言涉及 C, PHP, JavaScript + SQL, HTML + CSS，内容的广度与深度十分合理，还能够了解到最新的一些科技成果，可以很好激发学习计算机的兴趣。支线任务：阅读《<a href="https://book.douban.com/subject/20260928/" target="_blank" rel="noopener">编码</a>》</li><li>完成 <a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">Python 教程</a></li></ol><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>结束启蒙阶段后，初学者积累了一定的代码量，对编程也有了一定的了解。这时你可能想去学一门具体的技术，诸如 Web 开发，Android 开发，iOS 开发什么的，你可以去尝试做一些尽可能简单的东西，给自己一些正反馈，补充自己的推动力。但记住别深入，这些技术有无数的细节，将来会有时间去学习；同样的，这时候也别过于深入特定的框架和语言，现在是学习<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>通用基础知识的时候，不要试图去抄近路直接学你现在想学的东西，这是注定会失败的。</p><p>那么入门阶段具体该做些什么呢？这时候你需要做的是反思自己曾经写过的程序，去思考程序为什么 (Why) 要这样设计？思考怎样 (How) 写出更好的程序？试图去探寻理解编程的本质：利用计算机解决问题。</p><p>设想：</p><p>X = 用于思考解决方案的时间，即「解决问题」 部分</p><p>Y = 用于实现代码的时间，即「利用计算机」部分</p><p>编程能力 = F(X, Y) （X&gt;Y）</p><p>要想提高编程能力，就得优化 X，Y 与函数 F(X, Y)，很少有书的内容能同时着重集中在这三点上，但有一本书做到了——<a href="https://github.com/sarabander/sicp-pdf" target="_blank" rel="noopener">Structure and Interpretation of Computer Programs</a> (SICP)《<a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">计算机程序的构造和解释</a>》，它为你指明了这三个变量的方向。在阅读 SICP 之前，你也许能通过调用几个函数解决一个简单问题。但阅读完 SICP 之后，你会学会如何将问题抽象并且分解，从而处理更复杂更庞大的问题，这是编程能力巨大的飞跃，这会在本质上改变你思考问题以及用代码解决问题的方式。此外，SICP 的教学语言为 Scheme，可以让你初步了解<a href="http://zh.wikipedia.org/wiki/%25E5%2587%25BD%25E6%2595%25B8%25E7%25A8%258B%25E5%25BC%258F%25E8%25AA%259E%25E8%25A8%2580" target="_blank" rel="noopener">函数式编程</a>。更重要的是，他的语法十分简单，你可以很快学会它，从而把更多的时间用于学习书中的编程思想以及复杂问题的解决之道上。</p><p><a href="http://zh.wikipedia.org/wiki/%25E5%25BD%25BC%25E5%25BE%25B7%25C2%25B7%25E8%25AB%25BE%25E7%25B1%25B3%25E6%25A0%25BC" target="_blank" rel="noopener">Peter Norvig</a> 曾经写过一篇非常精彩的 SICP <a href="http://www.amazon.com/review/R403HR4VL71K8/ref%3Dcm_cr_rdp_perm" target="_blank" rel="noopener">书评</a>，其中有这样一段：</p><blockquote><p>To use an analogy, if SICP were about automobiles, it would be for the person who wants to know how cars work, how they are built, and how one might design fuel-efficient, safe, reliable vehicles for the 21st century. The people who hate SICP are the ones who just want to know how to drive their car on the highway, just like everyone else.</p></blockquote><p>如果你是文中的前者，阅读 SICP 将成为你衔接启蒙与入门阶段的关键点。</p><p>虽然 SICP 是一本「入门书」，但对于初学者还是有一定的难度，以下是一些十分有用的辅助资源：</p><ol><li><a href="https://www.udacity.com/course/cs212" target="_blank" rel="noopener">Udacity CS212 Design of Computer Program</a>：由上文提到的 Google 研究主管 Peter Norvig 主讲，教学语言为 Python，内容有一定难度。</li><li><a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/Draft/index.html" target="_blank" rel="noopener">How to Design Programs, Second Edition</a>：HtDP 的起点比 SICP 低，书中的内容循循善诱，对初学者很友好，如果觉得完成 SICP 过于困难，可以考虑先读一读 HtDP。</li><li><a href="https://github.com/DeathKing/Learning-SICP/" target="_blank" rel="noopener">UC Berkeley SICP 授课视频</a>以及 SICP 的两位作者给 Hewlett-Packard 公司员工培训时的录像</li><li><a href="http://composingprograms.com/" target="_blank" rel="noopener">Composing Programs</a>：一个继承了 SICP 思想但使用 Python 作为教学语言的编程导论（其中包含了一些小项目）</li><li><a href="http://sicp.readthedocs.org/en/latest/index.html" target="_blank" rel="noopener">SICP 解题集</a>：对于书后的习题，作为初学者应尽力并量力完成。</li></ol><p>完成了这部分学习后，你会逐步建立起一个自己的程序设计模型，你的脑子里不再是一团乱麻，你会意识到记住库和语法并不会教你如何解决编程问题，接下来要学些什么，在你心里也会明朗了很多。这时候才是真正开始进行项目实践，补充推动力的好时机。关于项目实践：对于入门阶段的初学者，参与开源项目还为时过早，这时候应该开始一些简单的项目，诸如搭建一个网站并维护它，或是编写一个小游戏再不断进行扩展，如果你自己的想法不明确，推荐你关注 <a href="http://zhuanlan.zhihu.com/alchemelon" target="_blank" rel="noopener">炼瓜研究所</a>，或者从 <a href="https://github.com/karan/Projects/" target="_blank" rel="noopener">Mega Project List</a> 中选取自己喜欢的项目。</p><p>如果你觉得 SICP 就是搞不定，也不要强迫自己，先跳过，继续走常规路线：开始读 <a href="http://book.douban.com/subject/1998341/" target="_blank" rel="noopener">The Elements of Computing Systems</a> 吧，它会教会你从最基本的 Nand 门开始构建计算机，直到俄罗斯方块在你的计算机上顺利运行。<a href="http://www.nand2tetris.org/course.php" target="_blank" rel="noopener">具体内容</a>不多说了，这本书会贯穿你的整个编程入门阶段，你入门阶段的目标就是坚持完成这本书的所有项目（包括一个<strong>最简的</strong>编译器与操作系统）。</p><p><strong>为了完全搞定这本书，为了继续打好根基。为了将来的厚积薄发，在下面这几个方面你还要做足功课（注意：下面的内容没有绝对意义上的先后顺序）：</strong></p><h4 id="计算机系统基础"><a href="#计算机系统基础" class="headerlink" title="计算机系统基础"></a>计算机系统基础</h4><p>有了之前程序设计的基础后，想更加深入地把握计算机科学的脉络，不妨看看这本书：<a href="http://csapp.cs.cmu.edu/" target="_blank" rel="noopener">Computer Systems: A Programmer’s Perspective, 3/E</a>《深入理解计算机系统》。这里点名批评这本书的中译名，其实根本谈不上什么深入啦，这本书只是 <a href="http://zh.wikipedia.org/wiki/%25E5%258D%25A1%25E5%2586%2585%25E5%259F%25BA%25E6%25A2%2585%25E9%259A%2586%25E5%25A4%25A7%25E5%25AD%25A6" target="_blank" rel="noopener">CMU</a> 的「<a href="https://www.cs.cmu.edu/%7E213/" target="_blank" rel="noopener">计算机系统导论</a>」的教材而已。CMU 的计算机科学专业相对较偏软件，该书就是从一个程序员的视角观察计算机系统，以「程序在计算机中如何执行」为主线，全面阐述计算机系统内部实现的诸多细节。</p><p>如果你看书觉得有些枯燥的话，可以跟一门 Coursera 上的 MOOC: <a href="https://www.coursera.org/course/hwswinterface" target="_blank" rel="noopener">The Hardware/Software Interface</a>，这门课的内容是 CSAPP 的一个子集，但是最经典的实验部分都移植过来了。同时，可以看看 <a href="https://book.douban.com/subject/1139336/" target="_blank" rel="noopener">The C Programming Language</a>，回顾一下 C 语言的知识。</p><p>完成这本书后，你会具备坚实的系统基础，也具有了学习操作系统，编译器，计算机网络等内容的先决条件。当学习更高级的系统内容时，翻阅一下此书的相应章节，同时编程实现其中的例子，一定会对书本上的理论具有更加感性的认识，真正做到经手的代码，从上层设计到底层实现都了然于胸，并能在脑中回放数据在网络-&gt;内存-&gt;缓存-&gt;CPU 的流向。</p><h4 id="数据结构与算法基础"><a href="#数据结构与算法基础" class="headerlink" title="数据结构与算法基础"></a>数据结构与算法基础</h4><p>如今，很多人认为编程（特别是做 web 开发）的主要部分就是使用别人的代码，能够用清晰简明的方式表达自己的想法比掌握硬核的数学与算法技巧重要的多，数据结构排序函数二分搜索这不都内置了吗？工作中永远用不到，学算法有啥用啊？这种扛着实用主义大旗的「码农」思想当然不可取。没有扎实的理论背景，遭遇瓶颈是迟早的事。</p><p>数据结构和算法是配套的，入门阶段你应该掌握的主要内容应该是：这个问题用什么算法和数据结构能更快解决。这就要求你对常见的数据结构和算法了熟于心，你不一定要敲代码，用纸手写流程是更快的方式。对你不懂的<a href="https://en.wikipedia.org/wiki/List_of_data_structures" target="_blank" rel="noopener">数据结构</a>和<a href="https://en.wikipedia.org/wiki/List_of_algorithms" target="_blank" rel="noopener">算法</a>，你要去搜它主要拿来干嘛的，使用场景是什么。</p><p>供你参考的学习资源：</p><ol><li>《<a href="https://book.douban.com/subject/1152912/" target="_blank" rel="noopener">算法导论</a>》：有人说别把这本书当入门书，这本书本来就不是入门书嘛，虽说书名是 Introduction to Algorithms，这只不过是因为作者不想把这本书与其他书搞重名罢了。当然，也不是没办法拿此书入门，读第一遍的时候跳过习题和证明就行了嘛，如果还觉得心虚先看看这本《<a href="https://book.douban.com/subject/1139426/" target="_blank" rel="noopener">数据结构与算法分析</a>》</li><li>​Algorithms: Design and Analysis [<a href="https://www.coursera.org/course/algo" target="_blank" rel="noopener">Part 1</a>] &amp; [<a href="https://www.coursera.org/course/algo2" target="_blank" rel="noopener">Part 2</a>]：Stanford 开的算法课，不限定语言，两个部分跟下来算法基础基本就有了；如果英文不过关：<a href="https://v.163.com/special/opencourse/algorithms.html" target="_blank" rel="noopener">麻省理工学院：算法导论</a></li><li>入门阶段还要注意培养使用常规算法解决小规模问题的能力，结合前文的 SICP 部分可以读读这几本书：《<a href="https://book.douban.com/subject/3227098/" target="_blank" rel="noopener">编程珠玑</a>》，《<a href="https://book.douban.com/subject/1173548/" target="_blank" rel="noopener">程序设计实践 </a>》</li></ol><h4 id="编程语言基础"><a href="#编程语言基础" class="headerlink" title="编程语言基础"></a>编程语言基础</h4><p>Different languages solve the same problems in different ways. By learning several different approaches, you can help broaden your thinking and avoid getting stuck in a rut. Additionally, learning many languages is far easier now, thanks to the wealth of freely available software on the Internet.</p><p>–<a href="https://book.douban.com/subject/1152111/" target="_blank" rel="noopener">The Pragmatic Programmer</a></p><p>此外还要知道，学习第 n 门编程语言的难度是第 (n-1) 门的一半，所以尽量去尝试不同的编程语言与编程范式，若你跟寻了前文的指引，你已经接触了：「干净」的脚本语言 Python, 传统的命令式语言 C, 以及<a href="http://matt.might.net/articles/i-love-you-in-racket/" target="_blank" rel="noopener">浪漫</a>的函数式语言 Scheme 三个好朋友。但仅仅是接触远远不够，你还需要不断继续加深与他们的友谊，并尝试结交新朋友，美而雅的 <a href="http://mislav.uniqpath.com/poignant-guide/" target="_blank" rel="noopener">Ruby</a> 小姑娘，Hindley-Milner 语言家族的掌中宝 <a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Haskell</a> 都是不错的选择。至于 C++，喜欢的话学学也无妨。</p><p>现实是残酷的，在软件工程领域仍旧充斥着一些狂热者，他们只掌握着一种编程语言，也只想掌握一种语言，他们认为自己掌握的这门语言是最好的，其他异端都是傻 X。这种人也不是无药可救，有一种很简单的治疗方法：让他们写一个编译器。要想真正理解编程语言，你必须亲自实现一个。现在是入门阶段，不要求你去上一门编译器课程，但要求你能至少实现一个简单的解释器。</p><p>供你参考的学习资源：</p><ol><li><a href="http://book.douban.com/subject/2152385/" target="_blank" rel="noopener">《程序设计语言-实践之路》</a>：CMU 编程语言原理的教材，程序语言入门书，现在就可以看，会极大扩展你的眼界，拉开你与普通人的差距。</li><li><a href="https://www.coursera.org/course/proglang" target="_blank" rel="noopener">Programming Languages</a> 课堂上你能接触到极端 FP （函数式）的 SML，中性偏 FP 的 Racket，以及极端 OOP （<a href="https://zh.wikipedia.org/wiki/%25E9%259D%25A2%25E5%2590%2591%25E5%25AF%25B9%25E8%25B1%25A1%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE" target="_blank" rel="noopener">面向对象</a>）的 Ruby，并学会问题的 FP 分解 vs OOP 分解、ML 的模式匹配、Lisp 宏、不变性与可变性、解释器的实现原理等，让你在将来学习新语言时更加轻松并写出更好的程序。</li><li><a href="https://www.udacity.com/course/cs262" target="_blank" rel="noopener">Udacity CS262 Programming Language</a>：热热身，教你写一个简单的浏览器——其实就是一个 JavaScript 和 HTML 的解释器，完成后的成品还是很有趣的；接下来，试着完成一个之前在 SICP 部分提到过的项目：用 Python 写一个 <a href="http://inst.eecs.berkeley.edu/%7Ecs61a/fa13/proj/scheme/scheme.html" target="_blank" rel="noopener">Scheme Interpreter</a></li></ol><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>编程入门阶段比较容易忽视的几点：</p><ol><li>学会提问：学习中肯定会遇到问题，应该学会正确的使用搜索引擎。当单靠检索无法解决问题时，去 <a href="http://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a> 或知乎提问，提问前读读这篇文章：<a href="http://mp.weixin.qq.com/s%3F__biz%3DMzI3NDI5ODQ2Ng%3D%3D%26mid%3D2247483666%26idx%3D1%26sn%3D201c119360515cfd7765a6fe6fb5d855" target="_blank" rel="noopener">能有效解决问题的提问方法</a>。</li><li>不要做一匹独狼：尝试在 <a href="http://cocode.cc/" target="_blank" rel="noopener">CoCode</a> 与他人交流想法。尝试搭建一个像<a href="https://zhuanlan.zhihu.com/%22h" target="_blank" rel="noopener">这样</a>简单的个人网站。试着在博客上记录自己的想法。订阅自己喜欢的编程类博客，推荐几个供你参考：<a href="http://www.joelonsoftware.com/" target="_blank" rel="noopener">Joel on Software</a>, <a href="http://www.norvig.com/index.html" target="_blank" rel="noopener">Peter Norvig</a>, <a href="http://blog.codinghorror.com/" target="_blank" rel="noopener">Coding Horror</a></li><li>学好英语：英语是你获取高质量学习资源的主要工具，但在入门阶段，所看的那些翻译书信息损耗也没那么严重，以你自己情况权衡吧。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上的内容你不应该感到惧怕，编程的入门不是几个星期就能完成的小项目。期间你还会遇到无数的困难，当你碰壁时试着尝试<a href="http://www.quora.com/Education/How-can-you-learn-faster/answer/Acaz-Pereira" target="_blank" rel="noopener">「费曼」技巧</a>：将难点分而化之，切成小知识块，再逐个对付，之后通过向别人清楚地解说来检验自己是否真的理解。当然，依旧会有你解决不了的问题，这时候不要强迫自己——很多时候当你之后回过头来再看这个问题时，一切豁然开朗。</p><p>此外不要局限于上文提到的那些材料，还有一些值得在入门阶段以及将来的提升阶段反复阅读的书籍。这里不得不提到在 <a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read" target="_blank" rel="noopener">Stack Overflow</a> 上票选得出的程序员必读书单中，排在前两位的两本书：</p><p><a href="http://book.douban.com/subject/1477390/%3Fi%3D0" target="_blank" rel="noopener">Code Complete</a>：不管是对于经验丰富的程序员还是对于那些没有受过太多的正规训练的新手程序员，此书都能用来填补自己的知识缺陷。对于入门阶段的新手们，可以重点看看涉及变量名，测试，个人性格的章节。</p><p><a href="https://book.douban.com/subject/1417047/" target="_blank" rel="noopener">The Pragmatic Programmer</a>：有人称这本书为代码小全：从 <a href="https://zh.wikipedia.org/wiki/%25E4%25B8%2580%25E6%25AC%25A1%25E4%25B8%2594%25E4%25BB%2585%25E4%25B8%2580%25E6%25AC%25A1" target="_blank" rel="noopener">DRY</a> 到 <a href="https://zh.wikipedia.org/wiki/KISS%25E5%258E%259F%25E5%2588%2599" target="_blank" rel="noopener">KISS</a>，从做人到做程序员均有涉及。</p><p>这本书的作者 Dave，在书中开篇留了这样一段话：</p><blockquote><p>You’re a Pragmatic Programmer. You aren’t wedded to any particular technology, but you have a broad enough background in the science, and your experience with practical projects allows you to choose good solutions in particular situations. Theory and practice combine to make you strong. You adjust your approach to suit the current circumstances and environment. And you do this continuously as the work progresses. Pragmatic Programmers get the job done, and do it well.</p></blockquote><p>这段话以及他创立的 <a href="https://pragprog.com/" target="_blank" rel="noopener">The Pragmatic Bookshelf</a> 一直以来都积极地影响着我，因此这篇指南我也尽量贯彻了这个思想，引导并希望你们成为一名真正的 Pragmatic Programmer。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>如果你能设法完成以上的所有任务，恭喜你，你已经真正实现了编程入门。这意味着你在之后更深入的学习中，不会畏惧那些学习新语言的任务，不会畏惧那些「复杂」的 API，更不会畏惧学习具体的技术，甚至感觉很容易。当然，为了掌握这些东西你依旧需要大量的练习，腰还是会疼，走路还是会费劲，一口气也上不了 5 楼。但我能保证你会在思想上有巨大的转变，获得极大的自信，看老师同学和 <a href="http://link.zhihu.com/?target=http%3A//www.csdn.net/" target="_blank" rel="noopener">CSDN</a> 的眼光会变得非常微妙，虽然只是完成了编程入门，但已经成为了程序员精神世界的高富帅。不，我说错了，即使是高富帅也不会有强力精神力，他也会怀疑自己，觉得自己没钱就什么都不是了。但总之，你遵循指南好好看书，那就会体验「会当凌绝顶」的感觉。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862833/blog/program_tutotial/bosh.png" alt="&quot;Chris&quot;" title="Chris"></p>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NexT 主题配置备份（二）</title>
      <link href="/posts/654861fb/"/>
      <url>/posts/654861fb/</url>
      <content type="html"><![CDATA[<p>这篇博客是承接上一篇 <a href="../a40f8cd0/">Next 主题配置备份</a>，按照个人喜好做了一些修改。</p><h3 id="加密文章"><a href="#加密文章" class="headerlink" title="加密文章"></a>加密文章</h3><p>网上针对 Hexo 博客加密文章的办法有两种：</p><h4 id="js-的阻塞机制"><a href="#js-的阻塞机制" class="headerlink" title="js 的阻塞机制"></a>js 的阻塞机制</h4><p>在 <code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code> 中的 \<meta> 标签后添加以下代码：</p><pre><code class="javascript">&lt;script&gt;    (function(){        if(&#39;{{ page.password }}&#39;){            if (prompt(&#39;请输入文章密码&#39;, &#39;&#39;) !== &#39;{{ page.password }}&#39;){                alert(&#39;密码错误&#39;);                history.back();            }        }    })();&lt;/script&gt;</code></pre><a id="more"></a><p>这里的 <code>page</code> 变量就是文章的首部：需要在首部自行添加 <code>password</code> 字段，再设置一个密码值：</p><pre><code class="markdown">---title: NexT主题配置备份（二）type: categoriescategories: 笔记tags:    - NexT    - 博客copyright: truedate: 2017/06/20 10:55:34password: ffffff---</code></pre><p>当然这个并不是真的加密，用查源代码的方式还是能看出博客的内容，不过这已经可以阻挡绝大部分访客了。</p><h4 id="crypto-js-的-AES-加密"><a href="#crypto-js-的-AES-加密" class="headerlink" title="crypto-js 的 AES 加密"></a>crypto-js 的 AES 加密</h4><p>采用的是 <a href="https://github.com/edolphin-ydf/hexo-encrypt" target="_blank" rel="noopener">hexo-encrypt</a> 插件，原理见作者<a href="http://edolphin.site/2016/05/31/encrypt-post/" target="_blank" rel="noopener">博客</a>，这个就属于真正的加密了，不知道密码查看源代码就是一堆无法辨认的字符。</p><h3 id="添加一言"><a href="#添加一言" class="headerlink" title="添加一言"></a>添加一言</h3><p>使用效果见我的博客侧边栏的底部。</p><p>需要修改 <code>themes-&gt;next-&gt;layout-&gt;_macro-&gt;sidebar.swig</code>，在倒数第三行的  后面加上：</p><pre><code class="html">&lt;div class = &quot;cost&quot;&gt;&lt;/div&gt;&lt;div class=&quot;cost-inner&quot;&gt;&lt;script language=&quot;Javascript&quot; src=&quot;https://rawgit.com/WincerChan/d314ff3a0ddc197134ad56efaeb34da0/raw/f4c3e73cdb08235fb01cd8849457c81d52236a1d/hitokoto.js&quot;&gt;&lt;/script&gt;&lt;/div&gt;</code></pre><p>这里的 Js 文件是我自己写的，托管在「<a href="https://gist.github.com/d314ff3a0ddc197134ad56efaeb34da0.git" target="_blank" rel="noopener">Gist</a>」，当然你可以自由修改这其中的每一句。我以后也会添加的越来越多</p><p>然后修改 <code>themes-&gt;next-&gt;source-&gt;css-&gt;_schemes-&gt;Pisces</code>，添加：</p><pre><code class="css">.cost {  margin-top: 10px;}.cost-inner {  box-sizing: border-box;  width: 240px;  padding: 20px 10px;  background: white;  box-shadow: $box-shadow;  border-radius: $border-radius;}</code></pre><h3 id="压缩博客文章"><a href="#压缩博客文章" class="headerlink" title="压缩博客文章"></a>压缩博客文章</h3><p>这里采用的是 <code>gulp</code> 插件，hexo 根目录新建 <code>gulpfile.js</code> 文件：</p><pre><code class="javascript">var gulp = require(&#39;gulp&#39;),    uglify = require(&#39;gulp-uglify&#39;),    del = require(&#39;del&#39;);    rename = require(&#39;gulp-rename&#39;),    cssmin = require(&#39;gulp-minify-css&#39;);    htmlclean = require(&#39;gulp-htmlclean&#39;);    htmlmin = require(&#39;gulp-htmlmin&#39;);    imagemin = require(&#39;gulp-imagemin&#39;);    runSequence = require(&#39;run-sequence&#39;);    Hexo = require(&#39;hexo&#39;);//清除publicgulp.task(&#39;clean&#39;, function(){    return del([&#39;public/**/*&#39;]);});// 利用Hexo API 来生成博客内容， 效果和在命令行运行： hexo g 一样// generate html with &#39;hexo generate&#39;var hexo = new Hexo(process.cwd(), {});gulp.task(&#39;generate&#39;, function(cb) {    hexo.init().then(function() {        return hexo.call(&#39;generate&#39;, {            watch: false        });    }).then(function() {        return hexo.exit();    }).then(function() {        return cb()    }).catch(function(err) {        console.log(err);        hexo.exit(err);        return cb(err);    })})//JS压缩gulp.task(&#39;uglify&#39;, function() {    return gulp.src(&#39;././public/js/*.js&#39;)        .pipe(uglify())        .pipe(gulp.dest(&#39;././public/js/&#39;));});//public-fancybox-js压缩gulp.task(&#39;fancybox:js&#39;, function() {    return gulp.src(&#39;././public/fancybox/jquery.fancybox.js&#39;)        .pipe(uglify())        .pipe(gulp.dest(&#39;././public/fancybox/&#39;));});//public-fancybox-css压缩gulp.task(&#39;fancybox:css&#39;, function() {    return gulp.src(&#39;././public/fancybox/jquery.fancybox.css&#39;)        .pipe(cssmin())        .pipe(gulp.dest(&#39;././public/fancybox/&#39;));});//CSS压缩gulp.task(&#39;cssmin&#39;, function() {    return gulp.src(&#39;././public/css/style.css&#39;)        .pipe(cssmin())        .pipe(gulp.dest(&#39;././public/css/&#39;));});// 压缩public目录下的所有htmlgulp.task(&#39;minify-html&#39;, function() {    return gulp.src(&#39;./public/**/*.html&#39;)        .pipe(htmlclean())        .pipe(htmlmin({            removeComments: true,            minifyJS: true,            minifyCSS: true,            minifyURLs: true,        }))        .pipe(gulp.dest(&#39;./public&#39;))});// 同上，压缩图片，这里采用了： 最大化压缩效果。gulp.task(&#39;minify-img-aggressive&#39;, function() {    return gulp.src(&#39;./public/images/**/*.*&#39;)        .pipe(imagemin(        [imagemin.gifsicle({&#39;optimizationLevel&#39;: 3}),         imagemin.jpegtran({&#39;progressive&#39;: true}),         imagemin.optipng({&#39;optimizationLevel&#39;: 7}),         imagemin.svgo()],        {&#39;verbose&#39;: true}))        .pipe(gulp.dest(&#39;./public/images&#39;))})// 用run-sequence并发执行，同时处理html，css，js，imggulp.task(&#39;compress&#39;, function(cb) {    runSequence([&#39;minify-html&#39;, &#39;cssmin&#39;, &#39;uglify&#39;, &#39;fancybox:js&#39;, &#39;fancybox:css&#39;, &#39;minify-img-aggressive&#39;], cb);});// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆gulp.task(&#39;build&#39;, function(cb) {    runSequence(&#39;clean&#39;, &#39;generate&#39;, &#39;compress&#39;, cb)});gulp.task(&#39;default&#39;, [&#39;build&#39;])</code></pre><p>需要用 npm 安装一些包：</p><pre><code class="json">&quot;del&quot;: &quot;^3.0.0&quot;,&quot;gulp&quot;: &quot;^3.9.1&quot;,&quot;gulp-clean-css&quot;: &quot;^3.4.2&quot;,&quot;gulp-htmlclean&quot;: &quot;^2.7.14&quot;,&quot;gulp-htmlmin&quot;: &quot;^3.0.0&quot;,&quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;,&quot;gulp-rename&quot;: &quot;^1.2.2&quot;,&quot;gulp-sourcemaps&quot;: &quot;^2.6.0&quot;,&quot;gulp-uglify&quot;: &quot;^3.0.0&quot;,&quot;run-sequence&quot;: &quot;^1.2.2&quot;,&quot;gulp-imagemin&quot;: &quot;^3.3.0&quot;,</code></pre><p>在执行 <code>gulp build</code> 时，会自动执行 <code>hexo clean</code>、<code>hexo g</code>，这时直接 <code>hexo d</code> 就行了。</p><h3 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h3><p>修改 <code>node_modules/hexo-generator-index/lib/generator</code> 内的代码为：</p><pre><code class="javascript">&#39;use strict&#39;;var pagination = require(&#39;hexo-pagination&#39;);module.exports = function(locals){  var config = this.config;  var posts = locals.posts;    posts.data = posts.data.sort(function(a, b) {        if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排            else return b.top - a.top; // 否则按照top值降序排        }        else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）            return -1;        }        else if(!a.top &amp;&amp; b.top) {            return 1;        }        else return b.date - a.date; // 都没定义按照文章日期降序排    });  var paginationDir = config.pagination_dir || &#39;page&#39;;  return pagination(&#39;&#39;, posts, {    perPage: config.index_generator.per_page,    layout: [&#39;index&#39;, &#39;archive&#39;],    format: paginationDir + &#39;/%d/&#39;,    data: {      __index: true    }  });};</code></pre><p>在文章的首部添加 <code>top</code> 值，数值越大越靠前：</p><pre><code class="markdown">---title: NexT主题配置备份（二）type: categoriescategories: 笔记tags:  - NexT  - 博客copyright: truetop: 888date: &#39;2017/06/30 10:55:34&#39;abbrlink: 654861fb---</code></pre><h3 id="隐藏文章"><a href="#隐藏文章" class="headerlink" title="隐藏文章"></a>隐藏文章</h3><p>可实现在首页和归档隐藏指定文章</p><p>首先在需要隐藏文章的 <code>Front-matter</code> 添加 <code>visible</code> 值，值为 <code>hide</code> 就表示隐藏。</p><h4 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h4><p>修改 <code>next/layout/index.swig</code> 中的</p><pre><code class="javascript">{% for post in page.post %}  {% if post.visible !== 'hide' %}    {{ post_template.render(post, true) }}  {% endif %}{% endfor %}</code></pre><p>在第 14 行左右，将 <code>for post in page.post</code> 中的内容修改成以上</p><h4 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h4><p>修改 <code>next/layout/index.swig</code>：</p><pre><code class="javascript">{% if post.visible !== 'hide' %}    {{ post_template.render(post, true) }}{% endif %}</code></pre><p>在第 42 行左右，将原本的 <code>post_template.render(post)</code> 改成以上。</p><p>不建议在归档中隐藏是因为归档提供的是一个统计的功能，隐藏后统计的文章篇数没变，但却显示不出来，有点别扭，不想要别人看就直接加密就好了。至于 <code>type</code> 和 <code>tags</code>，删除文章的相应字段就行了。</p><h3 id="分享页面"><a href="#分享页面" class="headerlink" title="分享页面"></a>分享页面</h3><p>NexT 主题自带的是 <a href="http://www.jiathis.com/" target="_blank" rel="noopener">JiaThis</a>，可是太丑了，还不支持 <code>https</code>，找了好久终于到了「<a href="http://overtrue.me/share.js/" target="_blank" rel="noopener">Share.js</a>」，简直把 JiaThis 秒成渣：</p><p>新增文件：<code>next/layout/_partials/share/sharejs.swig</code></p><pre><code class="javascript">&lt;div class=&quot;share-component&quot; data-mobile-sites=&quot;weibo,qq,qzone,tencent&quot;&gt;&lt;/div&gt;&lt;!-- share.css --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css&quot;&gt;&lt;!-- share.js --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>随后修改 <code>next\layout\post.swig</code>：</p><pre><code class="javascript">&lt;div class=&quot;post-spread&quot;&gt;            //在这一行后面添加：  {% include '_partials/share/sharejs.swig' %}...</code></pre><p>效果见下方</p>]]></content>
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NexT </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>启用新域名 itswincer.com</title>
      <link href="/posts/cd8ce2d7/"/>
      <url>/posts/cd8ce2d7/</url>
      <content type="html"><![CDATA[<p>之前的域名是 <code>wincer.top</code>，当时是博客新建站时看着便宜才买的（4 元一年），而且 <code>top</code> 虽为顶级域名，却显得不够主流。考试那几天就一直在思考买什么域名，后来终于敲定 <code>itswincer.com</code>，一年 70，不是没有考虑过 <code>me</code>、<code>info</code>、<code>cn</code> 等等，思考了一下都因为各种原因否定了，于是：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862358/blog/new_domain/bills.png" alt=""></p><p>一次性购买了 3 年（应该是不会换了）。</p><a id="more"></a><p>目前 <code>wincer.top</code> 已经 301 至新域名，Google Search Console 的转移也已经提交。</p><p>由于更改了域名，之前的评论也已经失效（喂喂，来必力你就不能出一个评论转移的功能吗），本准备将评论系统迁移至 Disqus，不过尝试了半天，还是否定这个想法，不是因为别的，就是因为被墙掉了，毕竟也不是所有人都会翻墙嘛。</p>]]></content>
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于男乒退赛的一点看法</title>
      <link href="/posts/2cdb7149/"/>
      <url>/posts/2cdb7149/</url>
      <content type="html"><![CDATA[<blockquote><p>6 月 23 日。马龙、樊振东、许昕宣布退出 2017 年国际乒联中国公开赛。</p></blockquote><p>本来针对这个事，我想写一篇长文来讲讲最近中国某些「魔幻」的地方，奈何后天就要考网络，只好暂且放下。</p><p>我一般不在博客上转载文章，不过鉴于这几天实在没有时间写，于是决定转载一下微博的一篇文章，出处已无法考证。</p><a id="more"></a><hr><p>憋了一晚上了，大半夜了，看着事情从最初了英勇豪迈，从振奋人心，担忧，到最后深深的无能为力。<br>看它空降热搜，一路爬到第一，半个榜内都是国乒。<br>看它被封，被禁，被删博。<br>截了一路的图。<br>这是国球。</p><p>国家体育总局关心的是那几块闪闪发亮的金牌。所以呢，给他们空降教练组长，突然之间毫无征兆的给他们的恩师「另谋高就」，他们没法反抗，禁言，被收手机，不能发声，不能上微博。<br>金牌可以再有，但国乒，这个从 2006 到 2016 年，敢在体育总局面前下军令状的梦之队，被瓦崩了，就不能重来。<br>看到了吗，从杜塞世乒赛临阵换走孔令辉，到成都公开赛明升暗降刘国梁，风云诡辩，赛场上闪闪发亮的新老双子星，四个大满贯，转眼间就只剩下了马龙一人。<br>有人说他们，不爱国，退赛，逃避，搞得和国旗上印的是刘国梁的脸一样。<br>那你是没有看过，孔令辉在夺冠后的瞬间扯起衣服亲吻胸口的那个国旗小标。你是没有看过，许昕在赢下赛点后，扯着衣服指给全世界看，他是中国人，然后指着背后的 CHINA 留给世人一个坚不可摧的背影。<br>你是没有见过，一个体育项目，2006 至 2016，在漫长的十年里，一个队伍包揽了世界大赛中，他们在制度约束下所能获得的所有金牌银牌，以及铜牌。<br>是中国乒乓球。<br>爱不爱国，铁骨铮铮，天地可鉴。<br>所以为什么他们会放弃他们热爱的赛场，扣除上百的世界排名积分，在一个不用升国旗奏国歌的比赛中以这种极端的方式伸张正义？<br>他们心寒。<br>孔令辉走了，刘国梁走了。捧起国球一片天，使这个精神漫漫延续的人，都以这样的方式离开了他们所热爱的赛场，不是功满圆退，而是二话不说让你离开。<br>国乒在今年刚刚重新聘选重组完教练组，刘国梁说不想从政只想呆在球场。马琳王皓，曾经世界冠军重新回到了国家队，以另一种方式，教练员的方式。<br>然而，半年未到，体育总局下令国乒取消总教练主教练职位，设立组长分管男女队，让刘国梁去做乒协副主席。<br>连李永波在内，有 20 多位的乒协副主席。<br>毫无征兆。<br>你让他们如何接受。<br>这几天里，从东京到成都，他们到底经历了什么，只有他们自己知道。<br>下午蔡振华蔡局到了成都，对刘国梁的卸任发表了态度。<br>晚上，所有能发生声的运动员，无论是国家一队二队还是省队，退役没退役，还有教练员，都发了一条微博。他们都选择了用这种方式来抗议。<br>后果是什么，禁赛，谩骂，卸甲归田？<br>他们知道吗，同样也不知道。<br>马龙，赌上了他最好的现在，樊振东，赌上了他前途无量的未来，许昕，赌上了奥运后好不容易重拾的好状态。<br>他们怎么可以这么傻。<br>国乒不是没了刘国梁就转不下去，也不是没了许昕马龙张继科樊振东就转不下去，事实上，马龙，刘国梁在里约后都有过退役的念头，但是又是什么让他们选择了依旧留在了赛场上？<br>是那方寸球台，和牵动着万千国人心的白色小球。<br>刘国梁，大满贯。退役后的第一天站在了教练员的位置上，至此，整整十四年。<br>在这十四年，他有了两个可爱的女儿，一个叫赢赢，一个叫一一。<br>赢，是中国队赢。一，使中国队第一。<br>他这半生，都叱咤风云于这赛场，这一生中最重要的人，也与乒乓球挂了勾。</p><p>发声，这只是见不惯也不能接受一代功臣沦落如此地步。<br>不能反抗，唯有自燃。</p><p>没有任何一个项目可以做到如此地步。教练员，运动员，把自己串在一起，做同一条绳上的蚂蚱。<br>没有任何一个项目可以做到如此地步。女队教练员不够，男队教练去补，男队教练员不够，那运动员还可以坐镇场外。<br>没有一个项目任何一个项目，和乒乓球一样可以看到四面五星红旗闪闪升旗的模样。</p><p>拿什么赌？拿自己赌，拿世界第一去赌，拿整个职业生涯去赌。<br>他们是连赛后忘记握手都要大肆报道严重批评的运动员，罢赛简直是想都不敢想的事情，而如今却发生了。<br>为何会做出如此举动，我们都应该明白。</p><p>这是中国乒乓球队历史上最没有把握的一次比赛。<br>但我希望他们赢。</p><p>那句话没有变，无论怎样都不会变，国乒长虹，剑指东京。</p><p>不知道他们在酒店怎么样，有没有手机，看不看得到我们。</p><p>如果看得到，想告诉他们。</p><p>整个中国都在支持他们。</p><hr><p>很气愤，想起了祁同伟说的一句话：</p><blockquote><p>英雄只不过是权利的工具。</p></blockquote><p>很奇怪，国乒为什么要改革？改革不是应该改掉不好的吗？日本队今年复制中国管理模式，韩国金泽洙回来重新凝聚团队，各国都在学习认可的管理模式，就因为上层的政治斗争，就随意改革？</p><p>要建立一个国乒体系花了刘国梁 20 年的心血，而毁掉只需要一个会议。</p><p>教练组扁平化，这是好听的说法，真实意思是业务和权力分开，由官僚进行垂直管理，中央集权。新建的“管理组”谁来空降？懂不懂乒乓球？会比一群世界冠军的教练还要懂？和教练组有分歧，谁听谁的？外行领导内行？</p><p>政治斗争，高于金牌利益，高于项目，高于运动员。这就是中国体育界。</p><p>为什么每一次，都要在巅峰的时候收割别人的心血，提走功勋，然后等低谷了再急巴巴请人来「临危受命」？前有中国女排，后，可能就是乒乓球。</p><p>不仅是体育总局，其实这就是中国的现实。</p><p>我很乐意看到中国这样最后会变得怎么样 :D</p>]]></content>
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国乒 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简谈 TCP 协议的三次握手和四次挥手</title>
      <link href="/posts/a8e25856/"/>
      <url>/posts/a8e25856/</url>
      <content type="html"><![CDATA[<p>最近计算机网络考试，无奈本学期没听多少，对三次握手和四次挥手的概念是模模糊糊，在看了哈工的网课后，了解了一些，就写篇博客记录和分享一下。</p><h3 id="TCP-定义"><a href="#TCP-定义" class="headerlink" title="TCP 定义"></a>TCP 定义</h3><p><strong>传输控制协议</strong>（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。</p><a id="more"></a><h3 id="TCP-建立链接"><a href="#TCP-建立链接" class="headerlink" title="TCP 建立链接"></a>TCP 建立链接</h3><p>TCP 用三次握手过程来创建一个连接。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862686/blog/tcp_connection/tcp_hand.png" alt="图片来自网络"></p><p>但是为什么是三次握手来保证一个稳定的连接呢，两次行不行？四次不行吗？</p><p>引用网上一个通俗的例子来让我们快速了解一下，当然这个例子并不严谨，但对我们的理解是有帮助的。</p><blockquote><p>三次握手：</p><p>A：“喂，你听得到我说话吗？”</p><p>B：“我听得到啊，你能听得到我吗？”</p><p>A：“我也能听到你，今天我……”</p></blockquote><blockquote><p>两次握手：</p><p>A：“喂，你听得到我说话吗？”</p><p>B：“我听的到啊，你能听得到我吗？”</p><p>A：“喂喂，你听得到吗？”</p><p>B：“草，我听得到啊！”</p><p>A：“你 TM 到底能不能听到我讲话啊！喂？”</p><p>B：“……”</p></blockquote><blockquote><p>四次握手：</p><p>A：“喂，你听得到我说话吗？”</p><p>B：“我听的到啊，你能听得到我吗？”</p><p>A：“我能听到你，你能听到我吗？”</p><p>B：“……不想跟傻逼说话”</p></blockquote><p>也就是说，如果通信的双方需要就某个问题达成一致，无论你在消息中包含什么信息，三次通信是理论上最合适的，两次通信并不能保证通信双方建立了可靠的连接，而四次通信就多余了。所以三次握手不是 TCP 本身的要求，而是为了满足「在不可靠信道上可靠地传输信息」这一需求。请注意这里的本质需求，信道不可靠，数据传输要可靠。三次达到了，那后面你想接着握手也好，发数据也好，跟进行可靠信息传输的需求就没关系了。</p><h3 id="TCP-头部"><a href="#TCP-头部" class="headerlink" title="TCP 头部"></a>TCP 头部</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862713/blog/tcp_connection/header.png" alt=""></p><p>上图就是 TCP 协议头部的格式，下面详细说明一下需要了解的信息：</p><ol><li>source port（源端口）和 dest port（目的端口）：分别占用 16 位，用于区别主机中不同的进程，配合 IP 地址就可以确定主机上的唯一一个 TCP 连接。</li><li>sequence Number（序号）：用来标识从 TCP 客户端向 TCP 服务端发送的数据流，它表示在这个报文段中的第一个数据字节在数据流中的序号。</li><li>acknowledgment Number（确认号）：确认号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应是上次成功收到的数据序号 + 1。不过只有当标志位中的 ACK 标志为 1 时该确认序列号的字段才有效。</li><li>ACK：此标志表示应答域有效，就是说前面的 TCP 应答号会包含在 TCP 数据包内，为 1 的时候表示应答域有效。</li><li>SYN：表示同步序号，用来建立连接。SYN 和 ACK 标志位搭配使用，当连接请求时，SYN = 1，ACK = 0；连接被响应的时候，SYN = 1，ACK = 1；</li><li>FIN：表示发送端已经到达数据末尾，也就是说双方的数据传输已经完成，发送 FIN 标志位后，连接将被断开。</li></ol><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862750/blog/tcp_connection/procedure.jpg" alt=""></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol><li>第一次握手：建立连接。客户端发送连接请求报文段，将 SYN 置 1，seq 为客户端的选择的一个初始序列号 x；然后等待服务器的确认；</li><li>第二次握手：服务器同意建立连接，返回一个报文段，SYN 仍然为 1，seq 设置为服务端的初始序列号 y，ack 设置为 x + 1；</li><li>第三次握手：客户端收到服务器的返回报文段。将 ack 置为 y + 1；向服务器发送 ACK 报文段，发送完毕后，三次握手结束。</li></ol><p>那么三次握手的意义何在？</p><blockquote><p>“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”                                    ——《计算机网络》谢希仁著</p></blockquote><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ol><li>第一次挥手：客户端设置 sequence number 和 acknowledgment number 向服务端发送一个 FIN 报文段，表示这时已经没有数据要发送给服务端了；</li><li>第二次挥手：服务端收到了客户端发送的 FIN 报文段，向客户端回一个 ACK 报文段，acknowledgment number 为 sequence number + 1；服务端同意你客户端的关闭请求，发送 FIN 报文段；</li><li>第三次挥手：客户端收到服务端发来的 FIN 报文段，向服务端回复 ACK 报文段；此时，客户端进入等待时间，如果重复收到 FIN 报文段，依据可靠传输机制，会重新发送 ACK；</li><li>第四次挥手：服务端收到客户端的 ACK 报文段后，就关闭连接了；若 timeout 之后依然没有回复则证明服务端已经关闭，那么客户端也可以关闭链接了。</li></ol><p>那么四次分手又是为何？TCP 是全双工模式，这就意味着，当客户端发出 FIN 报文段时，只是表示客户端已经没有数据要发送给服务端了；但是这个时候客户端还是可以接受来自服务端的数据；</p><p>当服务端返回 ACK 报文段时，表示他知道客户端没有数据发送了，但是他还是可以发送给客户端数据；当服务端也发送 FIN 报文段时，表示服务端也没有数据发送了，就会告诉客户端我也没有数据发送给你了，之后就会断开这次 TCP 连接。</p><p>参考：</p><p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">TCP 为什么是三次握手，为什么不是两次或四次？</a></p><p><a href="http://www.icourse163.org/learn/HIT-154005" target="_blank" rel="noopener">计算机网络</a></p>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP 协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 抽象类和接口</title>
      <link href="/posts/43fc1528/"/>
      <url>/posts/43fc1528/</url>
      <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在说抽象类之前，先说说抽象方法。抽象方法是用 <code>abstract</code> 修饰的方法，这种方法只声明返回的数据类型、方法名称和所需的参数，没有方法体，也就是说抽象方法只需要声明而不需要实现。</p><p>在《Java 编程思想》一书中，将抽象类定义为「包含抽象方法的类」，但是如果一个类不包含抽象方法，只是用 <code>abstract</code> 修饰的话也是抽象类。许多初学者会觉得很奇怪：如果一个抽象类不包含任何抽象方法，为何还要设计为抽象类？记住以下这一点：</p><blockquote><p>一个抽象类里面没有一个抽象方法可用来禁止产生这种类的对象。</p></blockquote><p>对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行具体的实现，那么就可以就将这个方法声明为 <code>abstract</code> 方法，此时这个类也就成为了 <code>abstract</code> 类了。如：</p><pre><code class="java">[public] abstract class Name{    abstract void func();} </code></pre><a id="more"></a><p>抽象类和普通类一样，同样可以拥有成员变量和普通的成员方法。抽象类和普通类主要区别有三点：</p><ol><li>抽象方法修饰词必须为 <code>public</code> 或者 <code>protected</code>（因为如果为 private，则不能被子类继承），缺省情况下默认为 <code>public</code>。</li><li>抽象类不能创建对象。</li><li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为 <code>abstract</code> 类。</li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口泛指实体把自己提供给外界的一种抽象化物，用以由内部操作分离出外部沟通方法，使其能够被修改外部而不影响外界其他实体与其交互的方式。</p><p>接口中可以含有变量和方法。但是要注意，接口中的变量会被隐式指定（并且只能是）为 <code>public</code>、<code>static</code>、<code>final</code> 变量，用 <code>private</code> 修饰会编译错误，而方法会被隐式地指定（并且只能是）为 <code>public</code>、<code>abstract</code> 方法，其他关键字如 <code>private</code>、<code>protected</code>、<code>static</code>、<code>final</code> 等修饰会编译错误（<strong>经提醒，JAVA 8 中对接口做了两点修改：1. 在接口中可以使用 default 关键字修饰非的抽象方法，该方法在子类实现的接口上可直接使用；2. 在接口中可以声明静态方法</strong>），并且接口中所有的方法不能用具体的实现，也就是说，接口中的方法必须都是抽象方法。如：</p><pre><code class="java">[public] interface InterfaceName{    //...}class ClassName implements Interface1, Interface2, [...]{    //...}</code></pre><p>允许一个类遵循多个特定的接口。如果一个非抽象类遵循某个接口，就必须实现该接口中所有的方法。而对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="语法层面"><a href="#语法层面" class="headerlink" title="语法层面"></a>语法层面</h3><ol><li>抽象类可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8" target="_blank" rel="noopener">可复用性</a>，这是抽象类的优势，而接口中只能存在抽象的方法；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口；</li><li>接口中不能含有静态代码快和静态方法，而抽象类可以有静态代码块和静态方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <code>public</code>、<code>static</code>、<code>final</code>类型的。</li></ol><h3 id="设计层面"><a href="#设计层面" class="headerlink" title="设计层面"></a>设计层面</h3><p>抽象类是一种对事物本质的抽象，而接口是对动作的抽象。</p><ol><li>对于抽象类，比如男人、女人这两个类设计一个更抽象的类：人；</li><li>对于接口，比如鸟、飞机、老鹰是不同的食物，但他们都有一个共性（接口），就是飞。</li></ol><p>也就是说：继承是一种描述“是不是”的关系，而接口则是“有没有”的关系。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>下面举一个门和响铃的例子：</p><p>门都有 <code>open()</code>、<code>close()</code> 两个动作，此时我们可以定义抽象类和接口来定义这个抽象概念：</p><pre><code class="java">abstract class Door{    public abstract void open();    public abstract void close();}</code></pre><p>或者：</p><pre><code class="java">interface Door{    public abstract void open();    public abstract void close();}</code></pre><p>但是现在如果我们需要门具有门铃 <code>ring()</code> 的功能，那么该如何实现呢？</p><ol><li>将这三个功能都放在抽象类里面，但是这样以来所有继承于这个抽象类的子类都具备了门铃功能，但是有的门并不具备门铃功能；</li><li>将这三个功能都放在接口里面，需要用到门铃功能的类就需要实现这个接口中的 <code>open()</code>、<code>close()</code>，也许这个类根本就不具备 <code>open()</code>、<code>close</code> 这两个功能，比如闹钟。</li></ol><p>从这里可以看出，Door 的 <code>open()</code>、<code>close()</code>、<code>ring()</code> 根本就属于两个不同范畴的行为，<code>open()</code> 和 <code>close()</code> 属于门本身固有的行为，而 <code>ring()</code> 属于延伸的附加行为。因此最好的解决办法是单独将响铃设计为一个接口，包含 <code>ring()</code> 行为，Door 设计为单独的一个抽象类，包含 <code>open()</code>、<code>close()</code> 两种行为。在设置一个有门铃的门继承 Door 类和实现 Ring 接口。</p><pre><code class="java">interface Ring{    void ring();}abstract class Door{    void open();    void close();}class RingDoor extends Door implements Ring{    void open(){        //...    }    void close(){        //...    }    void alarm(){        //...    }}</code></pre><p>参考：</p><p><a href="http://blog.csdn.net/ttgjz/article/details/2960451" target="_blank" rel="noopener">抽象类与接口的区别</a></p><p><a href="http://www.cnblogs.com/chenssy/p/3376708.html" target="_blank" rel="noopener">java 提高篇(五)—–抽象类与接口</a></p>]]></content>
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 的重载和重写</title>
      <link href="/posts/af291f12/"/>
      <url>/posts/af291f12/</url>
      <content type="html"><![CDATA[<h2 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h2><p>重载是让类以统一的方式处理不同类型的数据的一种手段。多个同名的函数同时存在，具有不同的参数类型。最典型的应用是：构造函数。</p><pre><code class="java">class Dog{    public void bark(){        System.out.println(&quot;狗可以吠叫&quot;);    }    public void bark(String name){        System.out.println(name+&quot;可以吠叫&quot;);    }}</code></pre><a id="more"></a><ol><li>被重载的方法必须改变参数列表；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或者更广的检查异常；</li><li>方法能够在同一个类或子类中被重载；</li><li>无法以返回值作为重载函数的区分标准。</li></ol><h2 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h2><p>重写（又称“覆盖”）是子类对父类的函数的重新定义，返回值和形参都不能改变，好处在于子类可以根据需要，定义特定的行为。</p><p>重写的方法不能抛出比父类更宽泛的异常。</p><pre><code class="java">class Animal{    public void move(){        System.out.println(&quot;动物可以移动&quot;);    }}class Dog extends Animal{    public void move(){        System.out.println(&quot;狗可以跑&quot;);    }}public class TestDog{    public static void main(String args[]){        Animal a1 = new Animal();        Animal a2 = new Dog();                a1.move();        a2.move();    }}</code></pre><p>输出结果：</p><blockquote><p>动物可以移动</p><p>狗可以跑</p></blockquote><p>上例中，<code>a2</code> 对象被定义为 <code>Animal</code> 类型。在编译器会检查 <code>Animal</code> 类中是否有可访问的 <code>move()</code> 方法，只要其中包含 <code>move()</code>，那么就可以编译通过。在运行期，<code>Dog</code> 对象被 new 出来，并复制给 <code>a2</code> 变量，这时，JVM 明确知道 <code>a2</code> 变量指向的其实是 <code>Dog</code> 对象的引用。所以，当 <code>a2</code> 调用 <code>move()</code> 方法的时候，就会调用 <code>Dog</code> 类中定义的 <code>bark()</code> 方法。这就是所谓的动态多态性。</p><ol><li>参数列表必须完全与被重写方法相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类访问权限更低；（如：父类的方法声明 public，则子类该方法声明不能为 protected。）</li><li>父类的成员方法只能被它的子类重写；</li><li>声明为 final 的方法不允许被重写；</li><li>声明为 static 的方法不能被重写，但可以被声明；</li><li>重写的方法不能抛出比被重写的方法声明更广泛的异常；</li><li>构造方法不能被重写。</li></ol><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:center">重载</th><th style="text-align:center">重写</th></tr></thead><tbody><tr><td style="text-align:center">参数类型</td><td style="text-align:center">必须修改</td><td style="text-align:center">一定不能修改</td></tr><tr><td style="text-align:center">返回类型</td><td style="text-align:center">可以修改</td><td style="text-align:center">一定不能修改</td></tr><tr><td style="text-align:center">异常</td><td style="text-align:center">可以修改</td><td style="text-align:center">可以减少或删除，一定不能抛出新的或更广泛的</td></tr><tr><td style="text-align:center">访问权限</td><td style="text-align:center">可以修改</td><td style="text-align:center">一定不能做更严格的限制</td></tr></tbody></table><ol><li>重载是一个编译时期概念，遵循「编译期绑定」，又称为编译时的多态，即在编译时根据参数变量的类型判断应该调用哪个方法。</li><li>重写是一个运行时期概念，遵循「运行期绑定」，又称为运行时的多态，即在运行时根据引用变量所指向的实际对象的类型来调用方法。</li></ol>]]></content>
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义域名的 GitHub Pages 添加 SSL 的方案</title>
      <link href="/posts/444a2b9d/"/>
      <url>/posts/444a2b9d/</url>
      <content type="html"><![CDATA[<blockquote><p>从 2017 年 1 月份正式发布的 Chrome 56 开始，Google 将把某些包含敏感内容的 HTTP 页面标记为“不安全”，比如含有密码或支付表单信息。</p></blockquote><a id="more"></a><p>GitHub Pages 不支持用户自定义证书，所以当你用自定义域名的时候是不能用自己购买的 SSL 证书的，会和 GitHub 的起冲突，这里采用的是 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">CloudFlare</a> 自主研发的 <a href="https://www.cloudflare.com/ssl/keyless-ssl/" target="_blank" rel="noopener">Keyless SSL</a> 服务。简单来说就是你把网站放在 CloudFlare 的 cdn 上，不用提供自己的私钥，也能使用 SSL 加密链接。</p><h2 id="创建-CloudFlare-账户"><a href="#创建-CloudFlare-账户" class="headerlink" title="创建 CloudFlare 账户"></a>创建 CloudFlare 账户</h2><p>首先你需要购买自己的域名，然后添加 CNAME 确定通过购买的域名能访问到 GitHub Pages，我的 CNAME 写的是 <code>wincer.top</code>。</p><ol><li>点击注册 <a href="https://www.cloudflare.com/a/sign-up" target="_blank" rel="noopener">CloudFlare</a></li><li>登录后，添加域名，例如：wincer.top（大约需要等待 1 分钟扫描）。注意：<strong>不要填写前缀</strong></li></ol><h2 id="添加-DNS-记录"><a href="#添加-DNS-记录" class="headerlink" title="添加 DNS 记录"></a>添加 DNS 记录</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862957/blog/customer_ssl/dns_record.png" alt=""></p><p>按照上图，将 <code>wincer.top</code> 换成你自己的域名，ip 地址不用换，是 GithHub 服务器的 IP。</p><p>完成之后，去你的域名提供商处修改你的 DNS 服务器为 CloudFlare 提供的（完成上一步后 CloudFlare 会提供两个 DNS 服务器给你）。</p><blockquote><p>官方说明修改域名服务器需要最快 72 小时生效，我大概花了 10 分钟生效，如下图代表已生效。</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862978/blog/customer_ssl/active.png" alt=""></p><h2 id="设置-SSL"><a href="#设置-SSL" class="headerlink" title="设置 SSL"></a>设置 SSL</h2><p>点击上方菜单的 Crypto 选项，设置 Flexible</p><p>再点击 Page Rules 选项，添加如下两条规则</p><ol><li>将 <code>www.wincer.top</code> 重定向至 <code>https://www.wincer.top</code></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862995/blog/customer_ssl/redirect.png" alt=""></p><ol start="2"><li>强制站内所有网页使用 HTTPS</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530863011/blog/customer_ssl/https.png" alt=""></p><p>添加 SSL 的教程就此完成。</p><p><strong>注意：CloudFlare 为你的网站颁发的 SSL 证书需要最多 24 小时才会生效，请耐心等待，我是半小时生效的。</strong></p><p>参考：<a href="https://blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/" target="_blank" rel="noopener">Secure and fast GitHub Pages with CloudFlare</a></p>]]></content>
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程创建两种方式的比较</title>
      <link href="/posts/c10dafe5/"/>
      <url>/posts/c10dafe5/</url>
      <content type="html"><![CDATA[<h3 id="线程创建的两种方式"><a href="#线程创建的两种方式" class="headerlink" title="线程创建的两种方式"></a>线程创建的两种方式</h3><h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h4><pre><code class="java">class DemoThread extends Thread{  ......    @Override    public void run(){      ......    }}DemoThread dt = new DemoThread();dt.start();</code></pre><a id="more"></a><h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><pre><code class="java">class DemoRunnable implements Runnable{  ......    @Override    public void run(){      ......    }}DemoRunnable dr = new DemoRunnable();Thread td = new Thread(dr);td.start();</code></pre><p>我们知道，在 Java 中是单继承机制，即一个子类只能继承自一个父类，故采用继承 Thread 类的方法会有缺陷，而 Runnable 的资源可以被多个线程所共享，适合多个线程处理<strong>同一资源</strong>的情况，接下来通过一个具体的例子来讲解一下：</p><h3 id="模拟火车站售票"><a href="#模拟火车站售票" class="headerlink" title="模拟火车站售票"></a>模拟火车站售票</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862783/blog/different_thread/sell_ticket.png" alt=""></p><p>现在还剩下 5 张火车票，共有 3 个售票窗口售卖这 5 张票，我们看看分别用两种方式来模拟会出现什么结果</p><h3 id="Thread-模拟"><a href="#Thread-模拟" class="headerlink" title="Thread 模拟"></a>Thread 模拟</h3><pre><code class="java">public class DemoThread extends Thread{    private int tickets = 5;        //火车票总数    private String name;            //窗口(线程)名字    public DemoThread(String name){        this.name = name;    }    public void run(){        while(tickets &gt; 0){            tickets --;        //票还有富余，卖掉一张            System.out.println(name+                               &quot;出票1张,剩余票数&quot;+ tickets);        }    }    public static void main(String[] args){        //创建3个线程，模拟三个窗口        DemoThread dt1 = new DemoThread(&quot;窗口1&quot;);        DemoThread dt2 = new DemoThread(&quot;窗口2&quot;);        DemoThread dt3 = new DemoThread(&quot;窗口3&quot;);        //进程启动        dt1.start();        dt2.start();        dt3.start();    }}</code></pre><p>首先看看 Thread 的运行结果：</p><blockquote><p>窗口 1 出票 1 张，剩余票数 4<br>窗口 1 出票 1 张，剩余票数 3<br>窗口 1 出票 1 张，剩余票数 2<br>窗口 1 出票 1 张，剩余票数 1<br>窗口 1 出票 1 张，剩余票数 0<br>窗口 2 出票 1 张，剩余票数 4<br>窗口 2 出票 1 张，剩余票数 3<br>窗口 2 出票 1 张，剩余票数 2<br>窗口 3 出票 1 张，剩余票数 4<br>窗口 2 出票 1 张，剩余票数 1<br>窗口 3 出票 1 张，剩余票数 3<br>窗口 3 出票 1 张，剩余票数 2<br>窗口 3 出票 1 张，剩余票数 1<br>窗口 3 出票 1 张，剩余票数 0<br>窗口 2 出票 1 张，剩余票数 0</p></blockquote><p>分析一下这个结果：窗口 1 抢占到了 CPU，卖了 5 张票，随后窗口 2 和窗口 3 居然也卖了 5 张票，也就是说这三个窗口一共卖了 15 张票，这显然不是我们需要的结果</p><h3 id="Runnable-模拟"><a href="#Runnable-模拟" class="headerlink" title="Runnable 模拟"></a>Runnable 模拟</h3><pre><code class="java">public class DemoRunnable implements Runnable{    private int tickets = 5;    public void run(){        while(tickets &gt; 0){            tickets --;         //票数有富余，出票1张            System.out.println(Thread.currentThread().getName()+                               &quot;出票,剩余票数&quot;+ -- tickets);        }    }    public static void main(String[] args){        DemoRunnable dr = new DemoRunnable();        Thread t1 = new Thread(dr, &quot;窗口1&quot;);        Thread t2 = new Thread(dr, &quot;窗口2&quot;);        Thread t3 = new Thread(dr, &quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    }}</code></pre><p>接下来看看 Runnable 的运行结果：</p><blockquote><p>窗口 1 出票，剩余票数 4<br>窗口 3 出票，剩余票数 2<br>窗口 3 出票，剩余票数 0<br>窗口 2 出票，剩余票数 3<br>窗口 1 出票，剩余票数 1</p></blockquote><p>这就正常了，三个窗口一共售卖了 5 张票，但是我们看出票的顺序：4-2-0-3-1，为什么不是 4-3-2-1-0 呢？</p><p>这是因为 Java 的线程的执行时机是不确定的，我们分析一下结果：</p><ol><li>t1 首先获得了 CPU 的资源：窗口 1 开始出票，并打印剩余票数 4，让出资源；</li><li>t2 其次获得了 CPU 的资源：窗口 2 开始出票，此时剩余票数为 3，在准备打印剩余票数的时候出现了一点小问题；</li><li>t3 出现并抢占 CPU 的资源：在窗口 2 出了票但是还没打印结果的时候，这个时候 t3 开始出票，并且打印出剩余票数 2；</li><li>t1 再次获得了 CPU 的资源：在窗口 1 出了票，在准备打印出剩余票数 1 的时候，又被窗口 3 抢得了资源；</li><li>t3 再次获得了 CPU 的资源：在窗口 3 出了票并打印出剩余票数 0，让出资源；</li><li>t2 终于获得了资源，打印出剩余票数 3，让出资源；</li><li>t1 最后获得了资源，开始打印出剩余票数 1，结束；</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在程序开发中只要是多线程肯定永远以实现 Runnable 接口为主，因为实现 Runnable 接口比继承 Thread 类有如下好处：</p><ol><li><strong>避免单继承的局限</strong>，<strong>一个类可以继承多个接口；</strong></li><li><strong>适合于资源的共享。</strong></li></ol>]]></content>
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Manjaro 大法好</title>
      <link href="/posts/7e325dad/"/>
      <url>/posts/7e325dad/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从去年 8 月到现在，终于无法忍受 Ubuntu 了，原因有以下几点：</p><ol><li>依赖太过混乱，自带 Python 默认版本居然是 2.7，而且更改默认版本后安装软件会各种报错</li><li>时不时报一个内部错误</li><li>软件版本更新太慢</li></ol><p>考虑到以上三点，我选择了  <a href="https://www.archlinux.org/" target="_blank" rel="noopener">Arch</a> 系的 <a href="https://manjaro.org/" target="_blank" rel="noopener">Manjaro Linxu</a>，选择 Arch 是因为去年有装过，是滚动更新模式，提供最新版本的软件，而不直接用的原因是安装步骤太过繁琐，没有必要，故而选择了基于 Arch 的 Manjaro 发行版。<br><a id="more"></a></p><h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><p>建议采用「<a href="https://rufus.akeo.ie/" target="_blank" rel="noopener">rufus</a>」烧制到 u 盘，制作的时候选择 dd 模式，不要选择 iso 模式，否则会无法从 u 盘启动，随后一路点点点。</p><h3 id="安装后的配置"><a href="#安装后的配置" class="headerlink" title="安装后的配置"></a>安装后的配置</h3><p>安装完成后，界面挺丑的，首先：</p><ol><li>更换中国的源，建议 USTC，这是<a href="https://mirrors.ustc.edu.cn/help/manjaro.html" target="_blank" rel="noopener">教程</a></li><li>换一张壁纸</li><li>将面板从底部删除，在顶部新建一个，添加一些部件</li><li>工作空间主题中更换观感和桌面主题</li><li>应用风格中更换窗口样式</li><li>更换图标包</li><li>fcitx 输入法</li><li>安装 docky</li><li>美化终端，安装 zsh、Oh my zsh、powerline</li><li>配置 conky（之前 Ubuntu 上的不知道为什么不能用了）</li></ol><h3 id="使用感想"><a href="#使用感想" class="headerlink" title="使用感想"></a>使用感想</h3><ol><li>Arch 的包管理 pacman 比 Ubuntu 的不知道高到哪里去了，还有 Octopi 图形界面客户端</li><li>特效比 Ubuntu 华丽多了</li><li>可随意切换工作区，效率确实高了一些</li><li>KDE 设置确实较多，需要花时间</li><li>KDE Connect 简直方便到爆炸！</li></ol><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861702/blog/manjaro_great/result.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KDE </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为终端使用 SS 代理</title>
      <link href="/posts/39613bbd/"/>
      <url>/posts/39613bbd/</url>
      <content type="html"><![CDATA[<p>Shadowsocks 是我们最常用的代理工具，它使用 socks 协议，而我们目前使用的终端只支持 http、https 协议，所以我们需要用软件来将 socks 协议转化为 http 等协议，我采用的是 Proxychains 软件（SS 的安装和配置自行谷歌）</p><h4 id="Proxychains-安装"><a href="#Proxychains-安装" class="headerlink" title="Proxychains 安装"></a>Proxychains 安装</h4><pre><code class="bash">git clone https://github.com/rof10r/proxychains-ng.gitcd proxychains-ng./configmake &amp;&amp; make installcp ./src/proxychains.conf /etc/proxychains.confcd .. &amp;&amp; rm -rf proxychains-ng</code></pre><h4 id="编辑-Proxychains-配置"><a href="#编辑-Proxychains-配置" class="headerlink" title="编辑 Proxychains 配置"></a>编辑 Proxychains 配置</h4><pre><code class="bash">vim /etc/proxychains.conf</code></pre><a id="more"></a><p>将最后一行</p><pre><code>socks4 127.0.0.1 9095</code></pre><p>改成：</p><pre><code>socks5 127.0.0.1 1080</code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在需要代理的命令前加上 <code>proxychains</code>，可用 <code>curl ip.gs</code> 命令测试一下</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861827/blog/terminal_proxy/before.png" alt="未使用"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861842/blog/terminal_proxy/after.png" alt="已使用"></p>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 博客备份</title>
      <link href="/posts/7efd2818/"/>
      <url>/posts/7efd2818/</url>
      <content type="html"><![CDATA[<p>使用 Hexo 在 github 搭建的博客，博客作为一个单独的 GitHub 仓库存在，但是这个仓库只有生成的静态网页文件，并没有 Hexo 的源文件，如果要换电脑或者重装系统后，就比较麻烦了，这里推荐一种方法。</p><a id="more"></a><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><ol><li>创建仓库 <a href="https://wincerchan.github.io" target="_blank" rel="noopener">WincerChan.github.io</a>，如果同名仓库之前已经创建，请将之前的仓库改名，新建的仓库必须是 Username.github.io；</li><li>创建两个分支：master 和 hexo；</li><li>设置 hexo 为默认分支；</li><li>将刚刚创建的新仓库 <code>clone</code> 至本地，将之前的 hexo 文件夹中的<code>_config.yml</code>、<code>themes/</code>、<code>source/</code>、<code>scaffolds/</code>、<code>package.json</code> 和 <code>.gitignore</code> 复制至 WincerChan.github.io 文件夹；</li><li>将 themes/next/(我用的是 NexT 主题) 中的 <code>.git/</code> 删除，否则无法将主题文件夹 push；</li><li>在 WincerChan.github.io 文件夹执行 <code>npm install</code> 和 <code>npm install hexo-deployer-git</code>（这里可以看一看分支是不是显示为 hexo）；</li><li>执行 <code>git add</code>、<code>git commit -m &quot;&quot;</code>、<code>git push origin hexo</code> 来提交 hexo 网站源文件；</li><li>执行 <code>hexo g -d</code> 生成静态网页部署至 Github 上。</li></ol><p>这样一来，<a href="https://wincerchan.github.io" target="_blank" rel="noopener">WincerChan.github.io</a> 仓库就有 master 分支和 hexo 分支，分别保存静态网页和源文件。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>在本地对博客修改（包括修改主题样式、发布新文章等）后：</p><ol><li>依次执行 <code>git add</code>、<code>git commit -m &quot;&quot;</code> 和 <code>git push origin hexo</code> 来提交 hexo 网站源文件；</li><li>执行 <code>hexo g -d</code> 生成静态网页部署至 Github 上。</li></ol><p>即重复备份的 7-8 步骤，以上两步没有严格的顺序。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>重装电脑后，或者在其它电脑上想修改博客：</p><ol><li>安装 git；</li><li>安装 Nodejs 和 npm；</li><li>使用 <code>git clone git#github.com:WincerChan/WincerChan.github.io.git</code> 将仓库拷贝至本地；</li><li>在文件夹内执行以下命令 <code>npm install hexo-cli -g</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>。</li></ol><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>这里稍作说明：</p><h5 id="添加-ssh-keys"><a href="#添加-ssh-keys" class="headerlink" title="添加 ssh-keys"></a>添加 ssh-keys</h5><ol><li>在终端下运行：<code>ssh-keygen -t rsa -C &quot;yourname#email.com&quot;</code>，一路回车；</li><li>会在 .ssh 目录生成 <code>id_rsa</code>、<code>id_rsa.pub</code> 两个文件，这就是密钥对，id_rsa 是私钥，千万不能泄漏出去；</li><li>登录 Github，打开「Settings」–&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意 Title，在 Key 文本框里粘贴公钥 <code>id_rsa.pub</code> 文件的内容，注意不要粘贴成 <code>id_rsa</code>，最后点击「Add SSH Key」。</li></ol><h5 id="hexo-的源文件"><a href="#hexo-的源文件" class="headerlink" title="hexo 的源文件"></a>hexo 的源文件</h5><p>这里说一下步骤 4 为什么只需要拷贝 6 个，而不需要全部：</p><ol><li><code>_config.yml</code>站点的配置文件，需要拷贝；</li><li><code>themes/</code>主题文件夹，需要拷贝；</li><li><code>source</code> 博客文章的 .md 文件，需要拷贝；</li><li><code>scaffolds/</code> 文章的模板，需要拷贝；</li><li><code>package.json</code> 安装包的名称，需要拷贝；</li><li><code>.gitignore</code> 限定在 push 时哪些文件可以忽略，需要拷贝；</li><li><code>.git/</code> 主题和站点都有，标志这是一个 git 项目，不需要拷贝；</li><li><code>node_modules/</code> 是安装包的目录，在执行 <code>npm install</code> 的时候会重新生成，不需要拷贝；</li><li><code>public</code> 是 <code>hexo g</code> 生成的静态网页，不需要拷贝；</li><li><code>.deploy_git</code> 同上，<code>hexo g</code> 也会生成，不需要拷贝；</li><li><code>db.json</code>文件，不需要拷贝。</li></ol><p>其实不需要拷贝的文件正是 <code>.gitignore</code> 中所忽略的。</p>]]></content>
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 教程 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NexT 主题配置备份</title>
      <link href="/posts/a40f8cd0/"/>
      <url>/posts/a40f8cd0/</url>
      <content type="html"><![CDATA[<h3 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h3><p>参照 <a href="http://theme-next.iissnan.com/getting-started.html#theme-settings" target="_blank" rel="noopener">NexT 使用文档</a>，设置中文语言、头像、作者、网站描述和 URL 等。</p><h3 id="动态背景"><a href="#动态背景" class="headerlink" title="动态背景"></a>动态背景</h3><p>修改 <code>themes/next/layout/_layout.swig</code>:</p><p>加上下面内容：</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot; src=&quot;js/src/particle.js&gt;&lt;script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot; count=&quot;50&quot; zindex=&quot;-2&quot; opacity=&quot;1&quot; color=&quot;0,104,183&quot;&gt;&lt;/script&gt;</code></pre><p>目前的 NexT 主题已经自带 canvas_nest 等四个特效，可以在主题配置文件搜索并将对应的值改为 <code>true</code>，这里不用自带是因为想添加彩色的线条，自带的只有黑色。</p><a id="more"></a><p>然后在 <code>thmems/next/source/js/src/</code> 目录新建 <code>particle.js</code>，文件写入以下代码：</p><pre><code class="javascript">! function() {    function n(n, e, t) {        return n.getAttribute(e) || t    }    function e(n) {        return document.getElementsByTagName(n)    }    function t() {        var t = e(&quot;script&quot;),            o = t.length,            i = t[o - 1];        return {            l: o,            z: n(i, &quot;zIndex&quot;, -1),            o: n(i, &quot;opacity&quot;, .5),            c: n(i, &quot;color&quot;, &quot;0,0,0&quot;),            n: n(i, &quot;count&quot;, 99)        }    }    function o() {        c = u.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, a = u.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight    }    function i() {        l.clearRect(0, 0, c, a);        var n, e, t, o, u, d, x = [w].concat(y);        y.forEach(function(i) {            for (i.x += i.xa, i.y += i.ya, i.xa *= i.x &gt; c || i.x &lt; 0 ? -1 : 1, i.ya *= i.y &gt; a || i.y &lt; 0 ? -1 : 1, l.fillRect(i.x - .5, i.y - .5, 1, 1), e = 0; e &lt; x.length; e++) n = x[e], i !== n &amp;&amp; null !== n.x &amp;&amp; null !== n.y &amp;&amp; (o = i.x - n.x, u = i.y - n.y, d = o * o + u * u, d &lt; n.max &amp;&amp; (n === w &amp;&amp; d &gt;= n.max / 2 &amp;&amp; (i.x -= .03 * o, i.y -= .03 * u), t = (n.max - d) / n.max, l.beginPath(), l.lineWidth = t / 2, l.strokeStyle = &quot;rgba(&quot; + m.c + &quot;,&quot; + (t + .2) + &quot;)&quot;, l.moveTo(i.x, i.y), l.lineTo(n.x, n.y), l.stroke()));            x.splice(x.indexOf(i), 1)        }), r(i)    }    var c, a, u = document.createElement(&quot;canvas&quot;),        m = t(),        d = &quot;c_n&quot; + m.l,        l = u.getContext(&quot;2d&quot;),        r = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(n) {            window.setTimeout(n, 1e3 / 45)        },        x = Math.random,        w = {            x: null,            y: null,            max: 2e4        };    u.id = d, u.style.cssText = &quot;position:fixed;top:0;left:0;z-index:&quot; + m.z + &quot;;opacity:&quot; + m.o, e(&quot;body&quot;)[0].appendChild(u), o(), window.onresize = o, window.onmousemove = function(n) {        n = n || window.event, w.x = n.clientX, w.y = n.clientY    }, window.onmouseout = function() {        w.x = null, w.y = null    };    for (var y = [], s = 0; m.n &gt; s; s++) {        var f = x() * c,            h = x() * a,            g = 2 * x() - 1,            p = 2 * x() - 1;        y.push({            x: f,            y: h,            xa: g,            ya: p,            max: 6e3        })    }    setTimeout(function() {        i()    }, 100)}();</code></pre><h3 id="鼠标点击小红心"><a href="#鼠标点击小红心" class="headerlink" title="鼠标点击小红心"></a>鼠标点击小红心</h3><p>修改 <code>themes/next/layout/_layout.swig</code>:</p><p>加上下面内容：</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</code></pre><p>然后在 <code>themes/next/source/js/src/</code> 目录新建文件 <code>love.js</code>，添加以下代码：</p><pre><code class="javascript">! function(e, t, a) {    function n() {        c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;), o(), r()    }    function r() {        for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);        requestAnimationFrame(r)    }    function o() {        var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick;        e.onclick = function(e) {            t &amp;&amp; t(), i(e)        }    }    function i(e) {        var a = t.createElement(&quot;div&quot;);        a.className = &quot;heart&quot;, d.push({            el: a,            x: e.clientX - 5,            y: e.clientY - 5,            scale: 1,            alpha: 1,            color: s()        }), t.body.appendChild(a)    }    function c(e) {        var a = t.createElement(&quot;style&quot;);        a.type = &quot;text/css&quot;;        try {            a.appendChild(t.createTextNode(e))        } catch (t) {            a.styleSheet.cssText = e        }        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)    }    function s() {        return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;    }    var d = [];    e.requestAnimationFrame = function() {        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) {            setTimeout(e, 1e3 / 60)        }    }(), n()}(window, document);</code></pre><h3 id="文章的标签"><a href="#文章的标签" class="headerlink" title="文章的标签"></a>文章的标签</h3><p>文章的 tags 是用「#」来标注，将「#」换成图标：</p><p>修改 <code>layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 # 换成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h3 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h3><p>修改 <code>hexo-generator-index</code> 插件：</p><p>修改文件：<code>node_modules/hexo-generator-index/lib/generator.js</code> 为：</p><pre><code class="javascript">&#39;use strict&#39;;var pagination = require(&#39;hexo-pagination&#39;);module.exports = function(locals){  var config = this.config;  var posts = locals.posts;    posts.data = posts.data.sort(function(a, b) {        if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排            else return b.top - a.top; // 否则按照top值降序排        }        else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）            return -1;        }        else if(!a.top &amp;&amp; b.top) {            return 1;        }        else return b.date - a.date; // 都没定义按照文章日期降序排    });  var paginationDir = config.pagination_dir || &#39;page&#39;;  return pagination(&#39;&#39;, posts, {    perPage: config.index_generator.per_page,    layout: [&#39;index&#39;, &#39;archive&#39;],    format: paginationDir + &#39;/%d/&#39;,    data: {      __index: true    }  });};</code></pre><p>在文章的 <code>Front-matter</code> 中添加 <code>top</code> 值，数值越大文章越靠前，如：</p><pre><code class="yaml">title: Next主题配置备份type: categoriescategories: 笔记tags:- Nextcopyright: truetop: 10date: 2017-05-31 18:04:00</code></pre><h3 id="NexT-主题自定义无序列表样式"><a href="#NexT-主题自定义无序列表样式" class="headerlink" title="NexT 主题自定义无序列表样式"></a>NexT 主题自定义无序列表样式</h3><p>打开 <code>\themes\next\source\css\_custom\custom.styl</code> 加入：</p><pre><code class="css">ul {list-style-type: circle;  // 空心圆，实心圆为 disc}</code></pre><h3 id="修改侧边栏头像为圆形"><a href="#修改侧边栏头像为圆形" class="headerlink" title="修改侧边栏头像为圆形"></a>修改侧边栏头像为圆形</h3><p>修改文件 <code>themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>，修改其中的 <code>.site-author-image</code> 段代码，改为如下形式：</p><pre><code class="css">.site-author-image {  display: block;  margin: 0 auto;  max-width: 96px;  height: auto;  border: 2px solid #333;  padding: 2px;  border-radius: 50%;}</code></pre><p>鼠标悬停旋转效果：</p><pre><code class="css">.site-author-image {  display: block;  margin: 0 auto;  max-width: 96px;  height: auto;  border: 2px solid #333;  padding: 2px;  border-radius: 50%  webkit-transition: 1.4s all;  moz-transition: 1.4s all;  ms-transition: 1.4s all;  transition: 1.4s all;}.site-author-image:hover {  background-color: #55DAE1;  webkit-transform: rotate(360deg) scale(1.1);  moz-transform: rotate(360deg) scale(1.1);  ms-transform: rotate(360deg) scale(1.1);  transform: rotate(360deg) scale(1.1);}</code></pre><p>参考链接：</p><ul><li><a href="http://codepub.cn/2016/03/20/Hexo-blog-theme-switching-from-Jacman-to-NexT-Mist/" target="_blank" rel="noopener">http://codepub.cn/2016/03/20/Hexo-blog-theme-switching-from-Jacman-to-NexT-Mist/</a></li></ul><h3 id="文章链接唯一化"><a href="#文章链接唯一化" class="headerlink" title="文章链接唯一化"></a>文章链接唯一化</h3><p>也许你会数次更改文章题目或者变更文章发布时间，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。安装此插件后，不要在 <code>hexo s</code> 模式下更改文章文件名，否则文章将成空白。</p><p>安装：<code>npm install hexo-abbrlink --save</code></p><p>在站点配置文件中查找代码 <code>permalink</code>，将其更改为：<code>permalink: posts/:abbrlink/  # “posts/” 可自行更换</code></p><p>同样在站点配置文件中添加代码：</p><pre><code class="yaml"># abbrlink configabbrlink:  alg: crc32  # 算法：crc16(default) and crc32   rep: hex    # 进制：dec(default) and hex</code></pre><p>可选模式：</p><ul><li>crc16 &amp; hex</li><li>crc16 &amp; dec</li><li>crc32 &amp; hex</li><li>crc32 &amp; dec</li></ul><h3 id="文章底部增加版权信息"><a href="#文章底部增加版权信息" class="headerlink" title="文章底部增加版权信息"></a>文章底部增加版权信息</h3><p>自定义版权信息，不采用 NexT 本身的版权设置</p><p>添加 <code>next/layout/_macro/my-copyright.swig</code> 文件：</p><pre><code class="swig">&lt;div class=&quot;my_post_copyright&quot;&gt;  &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt;  &lt;!-- JS库 sweetalert 可修改路径 --&gt;  &lt;script src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js&quot;&gt;&lt;/script&gt;  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css&quot;&gt;  &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;{{ url_for(page.path) }}&quot;&gt;{{ page.title }}&lt;/a&gt;&lt;/p&gt;  &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 {{ theme.author }} 的个人博客&quot;&gt;{{ theme.author }}&lt;/a&gt;&lt;/p&gt;  &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;{{ page.date.format("YYYY年MM月DD日 - HH:MM") }}&lt;/p&gt;  &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;{{ page.updated.format("YYYY年MM月DD日 - HH:MM") }}&lt;/p&gt;  &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;{{ url_for(page.path) }}&quot; title=&quot;{{ page.title }}&quot;&gt;{{ page.permalink }}&lt;/a&gt;    &lt;span class=&quot;copy-path&quot;  title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;{{ page.permalink }}&quot;  aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt;  &lt;/p&gt;  &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt;  &lt;/div&gt;&lt;script&gt;     var clipboard = new Clipboard(&#39;.fa-clipboard&#39;);    clipboard.on(&#39;success&#39;, $(function(){      $(&quot;.fa-clipboard&quot;).click(function(){        swal({             title: &quot;&quot;,             text: &#39;复制成功&#39;,             html: false,          timer: 500,             showConfirmButton: false        });      });    }));  &lt;/script&gt;</code></pre><p>在目录 <code>next/source/css/_common/components/post/</code> 下添加 <code>my-post-copyright.styl</code>：</p><pre><code class="css">.my_post_copyright {  width: 85%;  max-width: 45em;  margin: 2.8em auto 0;  padding: 0.5em 1.0em;  border: 1px solid #d3d3d3;  font-size: 0.93rem;  line-height: 1.6em;  word-break: break-all;  background: rgba(255,255,255,0.4);}.my_post_copyright p{margin:0;}.my_post_copyright span {  display: inline-block;  width: 5.2em;  color: #b5b5b5;  font-weight: bold;}.my_post_copyright .raw {  margin-left: 1em;  width: 5em;}.my_post_copyright a {  color: #808080;  border-bottom:0;}.my_post_copyright a:hover {  color: #a3d2a3;  text-decoration: underline;}.my_post_copyright:hover .fa-clipboard {  color: #000;}.my_post_copyright .post-url:hover {  font-weight: normal;}.my_post_copyright .copy-path {  margin-left: 1em;  width: 1em;  +mobile(){display:none;}}.my_post_copyright .copy-path:hover {  color: #808080;  cursor: pointer;}</code></pre><p>修改 <code>next/layout/_macro/post.swig</code>，在代码</p><pre><code class="javascript">&lt;div&gt;      {% if not is_index %}        {% include 'wechat-subscriber.swig' %}      {% endif %}&lt;/div&gt;</code></pre><p>之前添加增加如下代码：</p><pre><code class="javascript">&lt;div&gt;      {% if not is_index %}        {% include 'my-copyright.swig' %}      {% endif %}&lt;/div&gt;</code></pre><p>修改 <code>next/source/css/_common/components/post/post.styl</code> 文件，在最后一行增加代码：<code>@import &quot;my-post-copyright&quot;</code></p><p>每当发布一篇文章，需要在 <code>Front-matter</code> 添加 <code>copyright: true</code></p><p>参考链接：<a href="http://www.wuxubj.cn/" target="_blank" rel="noopener">务虚笔记</a></p>]]></content>
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NexT </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>端午记</title>
      <link href="/posts/859c63e4/"/>
      <url>/posts/859c63e4/</url>
      <content type="html"><![CDATA[<p>5 月马上就要过去</p><p>似乎还没开始的这个学期，怎么就快结束了</p><p>时间怎么这么快？</p><a id="more"></a><p>长眠于 4 月之前的海子，对于时间，有一个生动的说法叫「打马而过」</p><p>有时觉得，这种匀速流淌不可改变的东西，才是真 TMD 残忍。</p><p>雨滴的出生到结束，就是从天空落向大地</p><p>似乎它的宿命就是滴落大地</p><p><br></p><p>回到家中，躺在沙发上</p><p>空气中弥漫着「熟悉的味道」</p><p>想必那就是家的味道吧？</p><p><br></p><p>临近期末</p><p>似乎应该很担心成绩挂科</p><p>我理想中的大学不是这样的</p><p>我讨厌把自己的能力和思考，都锁在一个 for 循环里</p><p>循环的条件是：你是一个大学生</p><p>那样该多无趣啊</p><p>我想 break，就像现在躺在沙发上</p><p>可以暂时跳出这个循环</p><p><br></p><p>突兀的断网</p><p>调试了许久之后</p><p>终于意识到可能没有网了</p><p>这是 break 出循环的代价？</p><p><br></p><p>在家里总可以敞开去吃</p><p>喝啤酒到胃涨还能强迫去吃饭</p><p>吃的饱了</p><p>总算能真切感受到自己不在循环里</p><p><br></p><p>明媚而灿烂的五月啊</p><p>要是心情烦躁的时候，写写博客吧</p><p>这也是断网唯一能做的开心事了</p>]]></content>
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随感 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 正则表达式</title>
      <link href="/posts/fc635c56/"/>
      <url>/posts/fc635c56/</url>
      <content type="html"><![CDATA[<p>目前在跟 Udacity 的 <a href="https://classroom.udacity.com/courses/cs212" target="_blank" rel="noopener">cs212</a> 课程，避免懒癌发作，开篇博客来记录一下</p><h2 id="Python-的正则表达式"><a href="#Python-的正则表达式" class="headerlink" title="Python 的正则表达式"></a>Python 的正则表达式</h2><h3 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h3><table><thead><tr><th style="text-align:center">special</th><th style="text-align:center">example</th><th style="text-align:center">match</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">a*</td><td style="text-align:center">‘’, a, aa, aaa, . . .</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">a?</td><td style="text-align:center">‘’, a, . . .</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">.</td><td style="text-align:center">a, b, c, 7, ! . . .</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">^b</td><td style="text-align:center">ba, bb, . . .  <del>abc</del></td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">a$</td><td style="text-align:center">ba, . . . <del>ab</del></td></tr><tr><td style="text-align:center">‘’</td><td style="text-align:center">‘’</td><td style="text-align:center">‘’</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">ba</td><td style="text-align:center">bba</td><td style="text-align:center">ba, <del>aa</del>, <del>bb</del></td></tr></tbody></table><a id="more"></a><h3 id="re-match-和-re-search-的区别"><a href="#re-match-和-re-search-的区别" class="headerlink" title="re.match 和 re.search 的区别"></a>re.match 和 re.search 的区别</h3><p>re.macth 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None；</p><p>re.search 匹配整个字符串的所有位置，如果整个字符串都匹配不到，则返回 None.</p><p>如：</p><pre><code class="python">def test():    assert search(&#39;baa*!&#39;, &#39;Sheep said baaaa!&#39;)    assert search(&#39;baa*!&#39;, &#39;Sheep said baaaa humbug&#39;) == False    assert match(&#39;baa*!&#39;, &#39;Sheep said baaa!&#39;) == False    assert match(&#39;baa*!&#39;, &#39;baaaaaaaa! said the sheep&#39;)</code></pre><h3 id="自己实现的-match-和-search"><a href="#自己实现的-match-和-search" class="headerlink" title="自己实现的 match 和 search"></a>自己实现的 match 和 search</h3><pre><code class="python">def search(pattern, text):    &quot;Return True if pattern appears anywhere in text.&quot;    if pattern.startswith(&#39;^&#39;):        return match(pattern[1:], text)    else:        return match(&#39;.*&#39; + pattern, text)def match(pattern, text):    &quot;Return True if pattern appears at the start of text.&quot;    if pattern == &#39;&#39;:        return True    elif pattern == &#39;$&#39;:        return (text == &#39;&#39;)    elif len(pattern) &gt; 1 and pattern[1] in &#39;*?&#39;:        p, op, pat = pattern[0], pattern[1], pattern[2:]        if op == &#39;*&#39;:            return match_star(p, pat, text)        elif op == &#39;?&#39;:            if match1(p, text) and match(pat, text[1:]):                return True            else:                return match(pat, text)    else:        return (match1(pattern[0], text) and                match(pattern[1:], text[1:]))def match1(p, text):    &quot;&quot;&quot;Return true if first character of text matches    pattern character p.&quot;&quot;&quot;    if not text: return False    return p == &#39;.&#39; or p == text[0]def match_star(p, pattern, text):    &quot;&quot;&quot;Return true if any number of char p,    followed by pattern, matches text.&quot;&quot;&quot;    return (match(pattern, text) or    (match1(p, text) and     match_star(p, pattern, text[1:])))print(search(&#39;ba*!&#39;, &#39;this a baaa!&#39;))</code></pre><h3 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h3><pre><code class="python">def match(pattern, text):    &quot;Match pattern against start of text; return longest match found or None.&quot;    print(pattern)    remainders = pattern(text)    if remainders:        shortest = min(remainders, key=len)        return text[:len(text)-len(shortest)]def lit(s): return lambda t: set([t[len(s):]]) if t.startswith(s) else nulldef seq(x, y): return lambda t: set().union(*map(y, x(t)))def alt(x, y): return lambda t: x(t) | y(t)def oneof(chars): return lambda t: set([t[1:]]) if (t and t[0] in chars) else nulldot = lambda t: set([t[1:]]) if t else nulleol = lambda t: set([&#39;&#39;]) if t == &#39;&#39; else nulldef star(x): return lambda t: (set([t]) |                                set(t2 for t1 in x(t) if t1 != t                                   for t2 in star(x)(t1)))null = frozenset([])</code></pre>]]></content>
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown 入门参考</title>
      <link href="/posts/3e793072/"/>
      <url>/posts/3e793072/</url>
      <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>以下分别代表一至五级标题：</p><pre><code class="markdown">#h1##h2###h3####h4#####h5</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在段落等内容前使用 <code>&gt;</code> 符号，可以将这段内容标记为<strong>引用</strong>的内容：</p><pre><code class="markdown">&gt;引用内容&gt;&gt;二级引用</code></pre><a id="more"></a><blockquote><p>引用内容</p><blockquote><p>二级引用</p></blockquote></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><pre><code class="markdown">* 可以作为标记+ 也可以- 同样可以</code></pre><ul><li>可以作为标记</li></ul><ul><li>也可以</li></ul><ul><li>同样可以</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><pre><code class="markdown">1. 以数字和`. `开始；3. 数字的顺序并不会影响生成的列表序列；</code></pre><ol><li>以数字和 <code>.</code> 开始；</li><li>数字的顺序并不会影响生成的列表序列；</li></ol><h4 id="嵌套的列表"><a href="#嵌套的列表" class="headerlink" title="嵌套的列表"></a>嵌套的列表</h4><pre><code class="markdown">1. 第一层    + 1-1    + 1-22. 无序列表和有序列表可以随意嵌套    1. 2-1    2. 2-2</code></pre><ol><li>第一层<ul><li>1-1</li><li>1-2</li></ul></li><li>无序列表和有序列表可以随意嵌套<ol><li>2-1</li><li>2-2</li></ol></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>在代码的头部和尾部用 ``` 包围起来，需要高亮的话，在 ``` 包围的代码块头部标注语法的名字：</p><pre><code class="python">s = &#39;Python syntax highlighting&#39;for chr in s:    print (s)</code></pre><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><p>通过 <code></code> 插入行内代码：</p><p><code>print(Hello world)</code></p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>一行中使用三个即以上的 <code>*</code>、<code>-</code>、<code>_</code>来添加分隔线：</p><pre><code class="markdown">****</code></pre><hr><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>需要显示的文本为 [] 的内容，小括号中的链接可以是本地也可以是网络</p><pre><code class="markdown">[Google](https://google.com)</code></pre><p><a href="https://google.com" target="_blank" rel="noopener">Google</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>语法与超链接基本一致，只是需要在前面加一个 !：</p><pre><code class="markdown">![title](https://cdn.pixabay.com/photo/2012/10/26/00/45/senegal-pechlibelle-62964_960_720.jpg)</code></pre><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><h4 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h4><p>使用 <code>** **</code> 或 <code>__ __</code> 包括的文本会转化成<strong>粗体</strong></p><h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><p>使用 <code>* *</code> 或 <code>_ _</code> 包括的文本会转化为_斜体_</p><h3 id="字符的转义"><a href="#字符的转义" class="headerlink" title="字符的转义"></a>字符的转义</h3><p>当需要显示一些特殊的字符的时候，需要使用反斜线 <code>\</code> 来进行转义：</p><pre><code class="markdown">这是一个*转义*的_例子_这是一个\*转义\*的\_例子\_</code></pre><p>这是一个<em>转义</em>的_例子_</p><p>这是一个*转义*的_例子_</p><h2 id="进阶语法"><a href="#进阶语法" class="headerlink" title="进阶语法"></a>进阶语法</h2><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><pre><code class="markdown">这是~~删除线~~</code></pre><p>这是<del>删除线</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>Markdown 原生并无下划线语法，可以通过 HTML 来实现：</p><pre><code class="html">&lt;u&gt;这是下划线&lt;/u&gt;</code></pre><p><u>这是下划线</u></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h4 id="单元格和表头"><a href="#单元格和表头" class="headerlink" title="单元格和表头"></a>单元格和表头</h4><p>使用 <code>|</code> 来分隔不同单元格，使用 <code>-</code>  来分隔表头和其他行：</p><pre><code class="markdown">| name  | age  || ----- | ---- || Leo   | 16   || Virgo | 18   |</code></pre><table><thead><tr><th>name</th><th>age</th></tr></thead><tbody><tr><td>Leo</td><td>16</td></tr><tr><td>Virgo</td><td>18</td></tr></tbody></table><h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><p>在表头下方的分隔线标记加入 <code>:</code>，可更换下方单元格的对齐方式：</p><pre><code class="markdown">| left | center | right || ---- | :----: | ----: || left | center | right |</code></pre><table><thead><tr><th>left</th><th style="text-align:center">center</th><th style="text-align:right">right</th></tr></thead><tbody><tr><td>left</td><td style="text-align:center">center</td><td style="text-align:right">right</td></tr></tbody></table><h3 id="待办事宜（hexo-不支持以下语法）"><a href="#待办事宜（hexo-不支持以下语法）" class="headerlink" title="待办事宜（hexo 不支持以下语法）"></a>待办事宜（hexo 不支持以下语法）</h3><pre><code class="markdown">- [ ] 吃饭- [x] 唱歌</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861733/blog/markdown_tutorial/todo.png" alt=""></p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>以 flow 为关键字</p><pre><code class="flow">st=&gt;start: Starte=&gt;end: Endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861760/blog/markdown_tutorial/flow.png" alt=""></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>以 sequence 为关键字</p><pre><code class="sequence">Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861777/blog/markdown_tutorial/sequence.png" alt=""></p><h3 id="Latex-公式"><a href="#Latex-公式" class="headerlink" title="Latex 公式"></a>Latex 公式</h3><h4 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h4><p>用 <code>$ $</code> 包括起来的表示行内公式：</p><pre><code class="markdown">质能守恒方程：$E=mc^2$</code></pre><p>质能守恒方程：$E=mc^2$</p><h4 id="整行公式"><a href="#整行公式" class="headerlink" title="整行公式"></a>整行公式</h4><p>用 <code>$$ $$</code> 包括起来的表示整行公式：</p><pre><code class="markdown">$$\sum_{i=1}^n a_i=0$$$$f(x_1,x_x,\ldots,x_n)=x_1^2+x_2^2+\cdots+x_n^2$$</code></pre><p>$$\sum_{i=1}^n a_i=0$$</p><p>$$f(x_1,x_x,\ldots,x_n)=x_1^2+x_2^2+\cdots+x_n^2$$</p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>使用 <code>[^keyword]</code> 表示脚注：</p><pre><code class="markdown">这是一个脚注[^1]的例子[^1]: 这是一个脚注 </code></pre>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解除百度云下载限速</title>
      <link href="/posts/cfd78fa9/"/>
      <url>/posts/cfd78fa9/</url>
      <content type="html"><![CDATA[<p>目前关于破解百度云限速的方法网上提供了许多种，实则是殊途同归，即：高速链接 + 多线程下载工具。而目前获取的链接的方法并非完美且存在一些限制，但聊胜于无。</p><a id="more"></a><h2 id="Axel-下载"><a href="#Axel-下载" class="headerlink" title="Axel 下载"></a>Axel 下载</h2><p>本文以下将采用 Axel 代替 aria2c 作为多线程下载工具，原因是 aria2c 最多只能设置 16 线程下载，Axel 对此则没有限制。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>Ubuntu:</p><pre><code>sudo apt-get install axel</code></pre></li><li><p>CentOS:</p><pre><code>sudo yum install axel</code></pre></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>终端输入 <code>axel --help</code>:</p><pre><code>用法: axel [选项] 地址1 [地址2] [地址...]--max-speed=x        -s x    指定最大速率（字节 / 秒）--num-connections=x    -n x    指定最大连接数--output=f        -o f    指定本地输出文件--search[=x]        -S [x]    搜索镜像并从 X 服务器下载--no-proxy        -N    不使用任何代理服务器--quiet            -q    使用输出简单信息模式--verbose        -v    更多状态信息--alternate        -a    文本式进度指示器--help            -h    帮助信息--version        -V    版本信息</code></pre><p>以下为实例。</p><blockquote><p>友情提示：如果获取的链接仍无法多线程下载，可尝试把链接的协议从 HTTPS 改为 HTTP</p></blockquote><h2 id="下载助手修改版"><a href="#下载助手修改版" class="headerlink" title="下载助手修改版"></a>下载助手修改版</h2><p>此方法适用性应当比较高，活得也比较持久。</p><p>缺点就是有些麻烦：需复制 Header 信息才可掉调用下载工具（如 Axel 等）下载，获得 Header 的方法就是打开调试窗口，粘贴该链接在 Chrome 地址栏，在 Network 选项卡中查看该链接的 Request Headers，至少需要将 Cookie、User-Agent 两项传入给下载工具。</p><blockquote><p><strong>注意：这里的 Cookie 并不是当前域名（pan.baidu.com）的 Cookie，是 <code>pcs.baidu.com</code> 的 Cookie，其实所需要的仅仅是 Cookie 的 <code>BDUSS</code> 和 <code>pcsett</code> 值</strong></p></blockquote><p>这个方法会让每个线程的速度只有 10Kb/s，以下是 128 线程的示例：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530843976/blog/baiduyun_accelerate/thread_sample.png" alt="下载实例"></p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ol><li><p>下载<a href="http://tampermonkey.net/" target="_blank" rel="noopener">油猴脚本管理器</a></p></li><li><p>安装<a href="https://greasyfork.org/zh-CN/scripts/39776" target="_blank" rel="noopener">下载助手修改版</a>脚本</p></li><li><p>打开百度云，勾选需要下载的文件</p></li><li><p>随后打开百度云，勾选需要下载的文件后，上方会出现「下载助手」的按钮，依次点击：<code>压缩按钮-&gt;获取压缩按钮</code>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844040/blog/baiduyun_accelerate/assistant.png" alt="下载助手"></p></li></ol><h2 id="baidudl"><a href="#baidudl" class="headerlink" title="baidudl"></a>baidudl</h2><p>这是爱吾破解的一位大佬开发的插件，已在 GitHub 上<a href="https://github.com/Kyle-Kyle/baidudl" target="_blank" rel="noopener">开源</a>，同时也已上架 <a href="https://chrome.google.com/webstore/detail/baidudl/lflnkcmjnhfedgibjackiibmcdnnoadb" target="_blank" rel="noopener">Chrome 应用商店</a></p><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><ol><li>在百度云盘的界面点击「baidudl 图标」：会列出当前文件夹的所有文件</li><li>点击 <code>Generate</code> 按钮</li><li>复制生成的 <code>Glinks</code>，即为「高速链接」</li></ol><blockquote><p><strong>注意：此插件原理与「下载助手」类似，只能针对可以分享的文件，而对于一些敏感资源（如新出的电影等等）是无法使用的</strong></p></blockquote><h2 id="ADM-ES"><a href="#ADM-ES" class="headerlink" title="ADM + ES"></a>ADM + ES</h2><p>那么，针对无法分享的文件，该怎么办呢？</p><p>目前我可以想到的就只有用手机端「ES 文件浏览器」+「ADM」的方法了</p><p>同样该方法并非完美，用「ES 文件浏览器」获取的百度云链接只能在该手机端使用，因为该链接是通过本地端口远程链接所生成的，故还是有一些限制，速度倒是挺快（会有一些不稳定的波动）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844066/blog/baiduyun_accelerate/adm.png" alt="ADM 下载"></p><p>基本可以达到满速。</p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ol><li>安装 <a href="https://www.coolapk.com/apk/com.estrongs.android.pop" target="_blank" rel="noopener">ES 文件浏览器</a></li><li>安装 ADM（酷安手机客户端下载）</li><li>线程数调至 9</li><li>修改 User-Agent：<code>ADM -&gt; 设置 -&gt; 下载 -&gt; 用户代理 -&gt; &lt;Custom&gt;</code>，将以下内容复制进去：<code>netdisk;7.8.1;Red;android-android;4.3</code></li><li><code>ES 文件浏览器 -&gt; 网络 -&gt; 新建 -&gt; 百度网盘</code>，随后登录就会进入网盘界面，进入文件夹找到需要下载的文件后：<code>长按 -&gt; 更多 -&gt; 打开为 -&gt; 视频 -&gt; ADM</code>，这样就会调用 ADM 下载了</li></ol><blockquote><p><strong>注意：下载过程中需要保证「ES 文件浏览器」在后台运行</strong></p></blockquote><h2 id="BaiduExporter"><a href="#BaiduExporter" class="headerlink" title="BaiduExporter"></a>BaiduExporter</h2><blockquote><p><del>自本文最近一次更新起， 该方法获取的链接已无法在 Axel 中使用，原因是 URL 参数中的 app_id 失效，但这失效的 app_id 的 URL 却仍然可以用 aria2c 下载。</del>可以使用我 Fork 后修改的<a href="https://github.com/WincerChan/BaiduExporter" target="_blank" rel="noopener">版本</a>作为代替。</p></blockquote><p><a href="https://github.com/acgotaku/BaiduExporter" target="_blank" rel="noopener">该项目</a>同样开源在 GitHub，算是目前比较完美的解决方案了，以下是使用 Axel 开启 256 个线程后的速度（不要在意中间的乱码）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844096/blog/baiduyun_accelerate/axel.png" alt="截图"></p><p>原项目是将链接导出至 ariac2 下载，但是 ariac2 却只能最多开启 16 个线程，这对一般下载任务也够了，但是对于百度这种老流氓来说（每个连接限速至 10Kb/s ），还是不够用的，所以这里采用 Axel 代替 ariac2，Axel 可以设置任意连接数）。</p><h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><ol><li><p>git clone 该仓库</p></li><li><p><code>Chrome -&gt; 更多工具 -&gt; 扩展程序 -&gt; 加载已解压的扩展程序（需勾选开发者模式） -&gt; chrome/release（文件夹）</code></p></li><li><p>进入想要下载文件的界面</p></li><li><p>勾选，点击 <code>导出下载 -&gt; 文本导出 -&gt; 拷贝下载链接</code>：<img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844131/blog/baiduyun_accelerate/export.png" alt="导出下载"></p></li><li><p>复制链接后，是一串格式类似以下内容的命令：</p><pre><code class="bash">axel -o &quot;xxxxxx&quot; -H &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot; -H &quot;Cookie: BDUSS=9aRnpJYjF-THlHUbbjxkTYUnjk^&amp;8naddR2NscTF-cFZJVWV3cDBvVkVaeHpHOFNJcXRhQVFBQUFBJCQAAAAAAAAAAAEAAADvjlIvY3cwODI5OQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABKVg1oSlYNaS0; pcsett=4789643579-hukfa445465a15156c1515a5f12cxzw4&quot; &quot;URL&quot; -n 233</code></pre><p>其中包含两个 HTTP 首部信息：分别是 UA、Cookie，这两个信息在上一步骤的框里均会显示，<strong>不要直接复制我的，Cookie 会过期</strong>。其中 <code>-n 233</code> 是需要你手动输入的线程数量，即为采取 233 个线程下载。</p></li></ol><p>本文持续更新中。</p>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 百度云加速 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TFZ King 图集</title>
      <link href="/posts/92e17eb5/"/>
      <url>/posts/92e17eb5/</url>
      <content type="html"><![CDATA[<p>前两天逛耳机吧的时候发现了一条新耳机，顺手查了一下，一查到宣传海报就被这条耳机深深的吸引，与之高调的外观设计相符的是 King 这个名称，于是右手不听使唤的点下了购买键。<br>蓝色的电镀面板简直是犯规一般的设计，到手拆开包装时，庆幸不是「方便面套路 」，并没有感到塑料的丝毫廉价感，面板为中心的同心圆印着品牌和型号，同心圆边缘有一圈偏向于深蓝的细节处理，在日光灯的照射下显得优雅且梦幻，内侧材质为半透明的深蓝色树脂，曲线柔和，腔体稍微有一点大。</p><a id="more"></a><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530845146/blog/tfzking_atlas/pic1.jpg" alt="图 1"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530845146/blog/tfzking_atlas/pic2.jpg" alt="图 2"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530845146/blog/tfzking_atlas/pic3.jpg" alt="图 3"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530845146/blog/tfzking_atlas/pic4.jpg" alt="图 4"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530845146/blog/tfzking_atlas/pic5.jpg" alt="图 5"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530845146/blog/tfzking_atlas/pic6.jpg" alt="图 6"></p>]]></content>
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随拍 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>新增评论功能</title>
      <link href="/posts/daaac5bb/"/>
      <url>/posts/daaac5bb/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>前</strong>两天建站，最近忙于为网站添加评论功能，现在比较大的第三方评论网站有多说、畅言、网易云跟帖、Disqus。<br><a id="more"></a></p><ul><li><strong>Disqus</strong>    很方便，配置起来最快，但是由于我们身在墙内，故无法使用</li><li><strong>多说</strong>    现在最多用户使用的评论，但可惜的是 2017 年 6 月将暂停服务，故排除</li><li><strong>畅言</strong>    搜狐提供的评论组件，功能丰富，体验优异；但域名必须进行备案，而 Github Pages 很遗憾的使用不了</li><li><strong>网易云跟帖</strong>   就决定是你了</li></ul><h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3><p><strong>网</strong>易云跟帖并不支持 GitHub 的二级域名，故需要再买一个一级域名，<del>我选择在</del>并不推荐在<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">万网</a>买一个，接下来的问题是如何将这个域名和 myname.github.io 关联起来：</p><h4 id="创建-CNAME-文件"><a href="#创建-CNAME-文件" class="headerlink" title="创建 CNAME 文件"></a>创建 CNAME 文件</h4><p>在个人博客仓库的根目录下新建文件 <strong>CNAME</strong>（注意没有后缀），在该文件中添加一行文字：自己刚刚购买的域名，不能包含前缀信息，即不能添加 http 和 https。</p><h4 id="CNAME-绑定域名"><a href="#CNAME-绑定域名" class="headerlink" title="CNAME 绑定域名"></a>CNAME 绑定域名</h4><p>登录域名控制台，在<strong>域名解析</strong>中添加下图所示的解析</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862317/blog/comment_function/domain_resolution.png" alt=""></p><p>在域名解析中，A 记录就是直接指定一个 IP，CNAME 就是重定向指向另一个域名。</p><ol><li>在阿里云控制台，设置主机记录 <strong>www</strong>，记录类型为 A，记录值 IP 为在终端使用 <em>ping myname.github.io</em> 的 IP 地址，即 Github Pages 服务器指定的 IP 地址。</li><li>在阿里云控制台，设置主机记录 <strong>@</strong>，记录类型为 CNAME，记录值是 <strong>myname.github.io.</strong>，千万不要忘记域名后面还有一个点<strong>.</strong>!</li></ol><p>等待全球解析生效，也可以先 ping 一下域名看对不对，几分钟后，域名就可以被访问了。</p><h3 id="跟帖设置"><a href="#跟帖设置" class="headerlink" title="跟帖设置"></a>跟帖设置</h3><p><del><strong>域名</strong>可以正常访问博客之后，在<a href="https://manage.gentie.163.com/#/code" target="_blank" rel="noopener">网易云跟帖</a>登记完<strong>站点信息</strong>后，点击<strong>获取代码</strong>–&gt;<strong>通用代码</strong>：</del></p><p><del>复制上图的<em>productKey</em>项的值，即马赛克部分，至主题的<em>_config.yml</em>的以下：</del></p><pre><code class="yaml">#2、网易云跟帖wangyiyun: &#39;将prductKey复制到这里&#39;</code></pre><p><del>随后重新部署博客就会生效了，效果如下：</del></p><h4 id="来必力"><a href="#来必力" class="headerlink" title="来必力"></a>来必力</h4><p>登陆 「<a href="https://livere.com/" target="_blank" rel="noopener">来必力</a>」 获取你的 LiveRe UID。编辑 <strong>主题配置文件</strong>，编辑 <code>livere_uid</code> 字段，设置如下：</p><pre><code>livere_uid: #your livere_uid</code></pre><hr><p>至此，本篇教程结束，使用愉快。</p>]]></content>
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 评论 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>书推：雪中悍刀行</title>
      <link href="/posts/9a260fa1/"/>
      <url>/posts/9a260fa1/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>有个白狐儿脸，佩双刀绣冬春雷，要做那天下第一；</p><p>湖底有白发老魁爱吃荤；</p><p>缺门牙老仆背剑匣；</p><p>山上有个骑青牛的年轻师叔祖，不敢下山；</p><p>有个骑熊猫扛向日葵不太冷的少女杀手；</p><p>这个江湖，高人出行要注重出尘装扮，女侠行走江湖要注意培养人气，宗派要跟庙堂打好关系；</p><p>而主角，则潇洒带刀，把江湖捅了一个通透；</p><p>江湖是一张珠帘。大人物小人物，是珠子，大故事小故事，是串线。情义二字，则是那些珠子的精气神。</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=33544132&auto=0&height=66"></iframe><h3 id="简评（转）"><a href="#简评（转）" class="headerlink" title="简评（转）"></a>简评（转）</h3><p>年少时，看武侠电视剧里的侠踪剑影，总是莫名憧憬，甚至意犹未尽处，还会忍不住幻想自己是位飞流倜傥、快意恩仇的大侠，剑收于鞘时渊渟岳峙、剑起时又能挥出一片水银泻地云卷云舒。</p><p>日思夜想久了，于是便在心中有了一片江湖，有了一场江湖梦。</p><p>我想不止我是如此。</p><p>有句老话说，一千个读者的心中，就有一千个哈姆雷特。</p><p>同样的，一千个被现实社会的条条框框桎梏住的俗人们心间，便也有一千座不同的江湖。</p><p>求名者得名、求利者得利、求快意者得快意、求安稳者得安稳——这些在现实中并不存在的江湖就像是我们圆梦的地方，我们被称之为“规矩”“方圆”“社会准则”的枷锁束缚得越紧，就越是想要在内心最深处那片江湖里翻江倒海自在逍遥。</p><p>说白了，我们心中江湖上的那个状若侠客的自己，才是我们真正想成为的自己。</p><p>但人生有太多弯路，太多不可回头的路，一步踏错便再无转圜的余地，南辕北撤说的便是这个道理——有时候回头看，我们一路行来的方向，竟是和最初的梦想背道而驰，可我们被所谓社会的进步、所谓年轻人的成熟、所谓命运的安排这一类的东西追迫着、驱赶着，又着实没有时间停下来感伤，于是渐行渐远、梦想和现实也被拉扯得越来越沧海桑田。</p><p>到最后，我们的梦想，只剩下一副骨架、一副残骸，即是那座每每热血沸腾时便在心间浮起的海市蜃楼般的偌大一个江湖。</p><p>在那个江湖里，我们是最自在最洒脱不羁的那位侠客。</p><h3 id="文摘"><a href="#文摘" class="headerlink" title="文摘"></a>文摘</h3><hr><p><strong>李淳罡</strong>：</p><ol><li><p>大雨依旧磅礴。</p><p>她不起身，徐凤年便一直撑着伞。</p><p>老剑神李淳罡望向这一幕，瞪大眼睛。</p><p>随即眼中黯然落寞缅怀追忆皆有。</p><p>那一年背负那女子上斩魔台，一样是大雨天气，一样是撑伞。</p><p>世人不知这位剑神当年被齐玄帧所误，木马牛被折并不算什么，只剩独臂也不算什么，这都不是李淳罡境界大跌的根由，哪怕在听潮亭下被困二十年，李淳罡也不曾走出那个自己的画地为牢。</p><p>原本与世已是无敌，与己又当如何？</p><p>李淳罡想起她临终时的容颜，当时她已说不出一个字，可今曰想来，不就是那不悔两字吗？</p><p>李淳罡走到大雪坪崖畔，身后是一如他与绿袍女子场景的撑伞男女。</p><p>她被一剑洞穿心胸时，曾惨白笑言：“天不生你李淳罡，很无趣呢。”</p><p>李淳罡大声道：“剑来！”</p><p>徽山所有剑士的数百佩剑一齐出鞘，向大雪坪飞来。</p><p>龙虎山道士各式千柄桃木剑一概出鞘，浩浩荡荡飞向牯牛大岗。</p><p>两拨飞剑。</p><p>遮天蔽日。</p><p>这一日，剑神李淳罡再入陆地剑仙境界。</p><p>​</p><p>​</p></li></ol><hr><p><strong>洪洗象</strong>：</p><ol><li><p>正在经楼找寻一部典籍的陈繇踉跄跑到窗口，颤颤巍巍推开窗户，老泪纵横，嘴唇颤抖道：“王师兄，小师弟成了！”</p><p>山中炼丹的宋知命顾不得一鼎炉被凡人视作仙物的丹药，扑通一声跪下去，磕头道：“武当三十六弟子宋知命，恭迎祖师爷！”</p><p>在东海寻觅到一名骨骼清奇闭关弟子的俞兴瑞，正坐蒲台上传授那名弟子内功心法，抚掌大笑，笑出了眼泪，激动万分道：“李玉釜，你掌教师叔终于要下山了！”</p><p>七十二峰朝大顶，二十四涧水长流。其中最长一条飞流直下的瀑布犹如神助，低端被掀起拉直，通向毗邻那座唯有一名年轻道人修习天道的小莲花峰，瀑布如一条白练横贯长空，数万香客见到此景，仿佛置身仙境，更加寂静无声，偌大一座武当山，几乎落针可闻。水起作桥为谁横？齐仙侠亲眼见到古剑连鞘飞出太虚宫，尾随其后，沿着悬挂两峰峰顶水桥奔掠向小莲花峰，看到骑牛的怔怔靠着龟驼碑，喃喃自语：“今曰解签，宜下江南。”</p><p>一身朴素道袍的洪洗象拍了拍尘土，骑上一只体型巨大的黄鹤，望向江南。</p><p>江南好，最好是红衣。</p></li><li><p>徐脂虎缓缓转头，问道：“你到底是谁？”  一直被寄予厚望去肩扛天道的年轻道士羞赧嚅喏道：“洪洗象啊。”</p><p>徐脂虎重复问道：“你来做什么？”</p><p>年轻道士壮着胆子说道：“那年在莲花峰，你说你想骑鹤。”</p><p>她转过身，背对着这个胆小鬼。</p><p>这个放言要斩断赵氏王朝气运的道人，深呼吸一口，笑道：“徐脂虎，我喜欢你。” </p><p>“不管你信不信，我已经喜欢你七百年。” </p><p>“所以这世上再没有人比我喜欢你更久了。” </p><p>“下辈子，我还喜欢你。”</p><p>丫鬟二乔眨巴眨巴水灵眸子，小脑袋一团浆糊，只看到小姐捂着嘴哭哭笑笑的，就更不懂了，唉，看来小姐说自己年纪小不懂事是真的呀。</p><p>年轻道士伸出手，轻声道：“你想去哪里，我陪你。”</p><p>这一曰，武当年轻掌教骑鹤至江南，与徐脂虎骑鹤远离江湖。</p><p>仙人骑鹤下江南，才入江湖，便出江湖。</p></li><li><p>年轻道士深呼吸一口，等女子依偎在他怀中，那柄横放在龟驼碑边缘的所谓吕祖佩剑出鞘，冲天而起，朝天穹激射而去，仿佛要直达天庭才罢休。</p><p>九天之云滚滚下垂。</p><p>整座武当山紫气浩荡。</p><p>他朗声道：“贫道五百年前散人吕洞玄，五十年前龙虎山齐玄帧，如今武当洪洗象，已修得七百年功德。”</p><p>“贫道立誓，愿为天地正道再修三百年！”</p><p>“只求天地开一线，让徐脂虎飞升！”</p><p>年轻道士声如洪钟，响彻天地间。</p><p>“求徐脂虎乘鹤飞升！”</p><p>黄鹤齐鸣。</p><p>吕祖转世的年轻道士盘膝坐下，望着注定要兵解自己的那下坠一剑，笑着合上眼睛。</p><p>陈繇等人不忍再看，老泪纵横。</p><p>有一虹在剑落后，在年轻道士头顶生出，横跨大小莲花峰，绚烂无双。</p><p>千年修行，只求再见。</p></li></ol><hr><p><strong>轩辕敬城：</strong></p><ol><li><p>修身在正其心。</p><p>莫道书生无胆气，敢叫天地沉入海。</p><p>成事者，不惟有超世之才，亦必有坚韧不拔之志。</p><p>轩辕青锋脑海中走马观灯，那些诗词文章一一浮现。</p><p>“我入陆地神仙了。”</p><p>轩辕敬城闭上眼睛，只见他七窍流血，却神情自若地双手摊开，似乎想要包容那整座天地。</p><p>以他为圆心，大雪坪积水层层向外炸起。</p><p>那一瞬间，有九道雷电由天庭而来。</p></li><li><p>辕敬城每年酿当归酒三坛，两坛都让人送来庭院，自己只余一坛。</p><p>所以他从来都是喝不够酒，而这里却是从来不喝，任由年年两坛酒搁着闲置，年复一年，酒坛子越多，酒香也愈发醇厚。</p><p>她终于启封一坛酒，搬来一套尘封多年的酒具，酒具是那男人自制而成。<br>反正除了习武，那人仿佛没有不擅长的事情。</p><p>独坐的她盛了一杯酒，放在桌上，好似对于喝不喝酒，犹豫不决，她没来由开始恼恨自己，伸手猛地拍掉酒杯。</p><p>半响后她起身去拿回酒杯，才发现杯底刻有两行小字，字迹清逸出尘。</p><p>人生当苦无妨，良人当归即好。</p></li></ol><hr><p><strong>许涌关：</strong></p><ol><li><p>一刹那。</p><p>瞎子老许头脑一片空白。</p><p>他既然能活着走下累累白骨破百万的沙场，能是一个蠢蛋？</p><p>在北凉，谁敢说这一句徐骁不过是驼背老卒？</p><p>除了大柱国，还有谁？</p><p>瞎子老许那一架需要拐杖才能行走的干枯身体剧烈颤颤巍巍起来。</p><p>最后这位北凉赖活着的老卒竟是泪流满面，转过头，嘴唇颤抖，哽咽道：“大柱国？”</p><p>那人并未承认也未否认，只是喊了一声瞎子老许：“许老弟。”</p><p>只见瞎子老许如同癫狂，挣扎着起身，不顾大柱国的阻止，丢掉拐杖，跪于地上，用尽全身所有力气，用光了三十年转战六国的豪气，用光了十年苟延残喘的精神，死死压抑着一位老卒的激情哭腔，磕头道：“锦州十八-老字营之一，鱼鼓营末等骑卒，许涌关，参见徐将军！”</p><p>锦州十八营，今曰已悉数无存，如那威名曰渐逝去的六百铁甲一样，年轻一些的北凉骑兵，最多只是听说一些热血翻涌的事迹。</p><p>鱼鼓营。</p><p>号称徐字旗下死战第一。</p><p>最后一战便是那西垒壁，王妃缟素白衣如雪，双手敲鱼鼓营等人高的鱼龙鼓，一鼓作气拿下了离阳王朝的问鼎之战。近千人鱼鼓营死战不退，最终只活下来十六人，骑卒许涌关，便是在那场战役中失去一目，连箭带目一同拔去，拔而再战，直至昏死在死人堆中。</p><p>其实，在老卒心中，大柱国也好，北凉王也罢，那都是外人才称呼的，心底还是愿意喊一声徐将军！</p><p>被徐骁搀扶着重新坐在木墩上的瞎子老许，满脸泪水，却是笑着说道：“这辈子，活够了。徐将军，小卒斗胆问一句，那徐小子莫不是？”</p><p> 徐骁轻声道：“是我儿徐凤年。”</p><p>老卒脸贴着被大柱国亲手拿回的拐杖，重复呢喃道：“活够了，活够了……”</p><p>鱼鼓营最后一人，老卒许涌关缓缓闭目。</p><p>徐将军，王妃，有一个好儿子啊。</p><p>我老许得下去找老兄弟们喝酒去了，与他们说一声，三十万北凉铁骑的马蹄声只会越来越让敌人胆寒，小不去，弱不了。</p><p>徐字王旗下，鱼龙鼓响。</p><p>老卒许涌关，死于安详。</p></li></ol><hr><p><strong>温华：</strong></p><ol><li><p>一个时辰后黄龙士缓缓走下马车，马车渐渐远去，消失于风雪中。</p><p>黄龙士没有急于入院，而是在巷弄来回走了两趟，这才推开门扉。</p><p>短短一炷香后，一名年轻男子断一臂，瘸一腿，自断全身筋脉，只存一条性命，只拎上那柄原本就属于自己的木剑，离开了院子。</p><p>巷中雪上长长一条血。</p><p>“在老子家乡那边，借人钱财，借你十两就还得还十二三两，我温华的剑，是你教的，我废去全身武功，再还你一条手臂一条腿！”</p><p>他在院中，就对那个黄老头说了这么一句话。</p><p>然后这个雪中血人在拐角处颓然蹲下，手边只剩下一柄带血木剑。</p><p>年轻游侠儿泪眼模糊，凄然一笑，站起身，拿木剑对准墙壁，狠狠折断。</p><p>此后江湖再无温华的消息，这名才出江湖便已名动天下的木剑游侠儿，一夜之间，以最决然的苍凉姿态，离开了江湖。</p><p>刺骨大雪中，他最后对自己说了一句。</p><p>“不练剑了。”</p></li></ol><hr><p><strong>徐凤年：</strong></p><ol><li><p>徐凤年闭上眼睛，双手搭在春雷上，有些明白一些事情了，为何徐骁如今还像个老农那般喜欢缝鞋？轩辕敬城本该像张巨鹿那般经略天下，最不济也可以去跟荀平靠拢，却被自己堵在了一家三口的家门以外，堵在了轩辕一姓的徽山之上，即使一举成为儒圣，仍是不曾跨出半步。骑牛的最终还是下了山，但这种下山与在山上，又有什么两样？羊皮裘李老头儿十六岁金刚十九岁指玄二十四岁达天象，为何断臂以后仍是在江上鬼门关为他当年的绿袍儿，几笑一飞剑？</p><p>说到底，都是一个字。</p><p>徐凤年想着她的酒窝，摇晃站起身。</p><p>他就算不承认，也知道自己喜欢她。不喜欢，如何能看了那么多年，却也总是看不厌？</p><p>只是不知道，原来是如此的喜欢。</p><p>既然喜欢了，却没能说出口，那就别死在这里！</p><p>徐凤年睁眼以后，拿袖口抹了抹血污，笑着喊道：“姜泥！老子喜欢你！”</p><p>拓跋春隼冷笑不止，只不过再一次笑不出来。</p><p>一名年轻女子御剑而来，身后有青衫儒士凌波微步，逍遥踏空。</p><p>女子站在一柄长剑之上，在身陷必死之地的家伙身前悬空。</p><p>她瞪眼怒道：“喊我做什么？不要脸！”</p></li></ol><hr><p><strong>李当心：</strong></p><ol><li><p>唉，闺女，等你大些，就会明白只要在一个男人心中好看，你就是天下最好看的姑娘了。”</p><p>“啊？可徐凤年说我长得一般呐，完了！”</p><p>“闺女真是长大了，娘很欣慰呐。闺女，娘真不好看？不行，再下山一趟，还得买些胭脂水粉，多扑一些在脸上就好看了。”</p><p>“娘你又乱花钱，爹肯定要跟笨南北蹲墙角唠叨去了，他们一起叨叨叨，可烦了。”</p><p>“让他们叨叨去。哪天不叨了才不好。”</p><p>这娘俩，似乎挺俗气。</p><p>亏得各自身后爱慕着她们两个的光头，是那般佛气。</p><p>小和尚将洗好的袈裟晾好，望向房内自语到，“又是一个天晴的好日子。李子，师父说我没悟性，你也说我笨，咱们寺里两个禅，我都不修。你便是我的禅，秀色可参。”</p><p>千山以外是千山，这就是江山；六宫粉黛独看你，这就是美人。</p><p>白衣僧人笑道：“去吧，睡觉去。” 小和尚嗯了一声，道：“东西怕打雷，我去门外给她念经去。” 白衣僧人摸了摸自己光头，这徒弟。站在千佛殿门口，看到在泥泞中奔跑顾不得雨水的笨南北，白衣僧人呢喃道：“笨南北啊，你有一禅，不负如来不负卿。</p><p>少妇才喊完，嗖一下，一名白衣僧人就以屁滚尿流的姿态窜出那栋巍峨阁楼，来到少妇面前，笑呵呵道：“媳妇，走累了没，给敲敲腿？”</p><p>若是外人在场，定要认为以这女子一路行来表现出的蛮横，肯定要好生拾掇一番白衣僧人才会罢休，但真见着了自己男人，她却是轻柔说道：“不累呢，只是好几天没见着你，有点想你啦。”</p><p>本名原来是李当心的白衣僧人笑容醉人，也不说话。</p><p>既然有她，天下无禅。</p></li></ol>]]></content>
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书推 </tag>
            
            <tag> 文摘 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 WebDav（坚果云）同步 SafeInCloud</title>
      <link href="/posts/c7bc4900/"/>
      <url>/posts/c7bc4900/</url>
      <content type="html"><![CDATA[<h4 id="SafeInCloud-介绍"><a href="#SafeInCloud-介绍" class="headerlink" title="SafeInCloud 介绍"></a>SafeInCloud 介绍</h4><p><a href="https://www.safe-in-cloud.com/en/" target="_blank" rel="noopener">SafeInCloud</a> 密码管理器允许您保存您的登录名、密码和其他私人信息在安全和牢固的加密数据库中。您可以通过您的云帐户与另一台电话，平板电脑，Mac 或 PC 同步您的数据。<a id="more"></a></p><p>应用下载：<a href="http://www.coolapk.com/apk/com.safeincloud" target="_blank" rel="noopener">酷安下载</a>   <a href="https://play.google.com/store/apps/details?id=com.safeincloud" target="_blank" rel="noopener">谷歌商店</a></p><h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p>SafeInCloud 支持的云同步大多都是国外的，考虑到国内的网络环境，可以选择 OneDrive 和坚果云同步，OneDrive 同步直接登录就可以，本文主要讲解如何利用 WebDav 和坚果云同步：</p><ol><li><p>登录<a href="https://www.jianguoyun.com/" target="_blank" rel="noopener">坚果云</a>，左上角 <strong>创建–&gt;新建个人同步文件夹</strong>。记住该文件夹的名字</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862043/blog/webdav_sync/jianguoyun.png" alt=""></p></li><li><p>进入 SafeInCloud，在登录界面选择 WebDav 登录：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862067/blog/webdav_sync/safeincloud.png" alt=""></p><ul><li>协议：https</li><li>Host（主机）：dav.jianguoyun.com/dav</li><li>端口：空</li><li>本地路径：刚刚创建的个人同步文件夹名字</li><li>用户名：坚果云账户名</li><li>密码：坚果云账户密码</li></ul></li></ol><p>至此，本篇教程结束，祝使用愉快。</p>]]></content>
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 云同步 </tag>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      <content type="html"><![CDATA[<p><strong>在</strong>朋友的推荐下，这个简易的博客搭建起来了。</p><p><strong>折腾</strong>了一天多，第一天结束的时候在 Github Pages 上看到自己的博客加载出来的时候，突然有种错综复杂的恍惚感。是的，它不是自己的 QQ 空间，不是新浪博客，不是豆瓣小站，也不是百度贴吧。它更像是属于自己的一块小小的领地，因而我满足这种归属感。我愿意、更乐于在上面安静劳作。</p><p><strong>一个</strong>之前为地主打工的农民，现在通过自身努力终于分到了一块地，不再需要帮地主的土地创造价值时，于是，这个农民重生了，他可以自豪的宣告：Hello World。当然，这个农民确切的来说是个码农。<a id="more"></a></p><p><strong>主题</strong>采用的是 Next，很好看的主题，使用文档见<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
